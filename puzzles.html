<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memo Chess - Puzzles</title>
    <script>
        // Check subscription status immediately to prevent flashing
        (function() {
            const hasActiveSubscription = localStorage.getItem('hasActiveSubscription') === 'true';
            if (hasActiveSubscription) {
                // Add CSS to hide subscription tab for subscribers
                const style = document.createElement('style');
                style.textContent = '.subscription-tab-li { display: none !important; }';
                document.head.appendChild(style);
            }
        })();
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
        }

        .navbar {
            background-color: #f5f5f5;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .logo {
            display: flex;
            align-items: center;
            color: #1e3a8a;
            font-size: 1.5rem;
            font-weight: bold;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        .logo:hover {
            color: #1e3a8a;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            margin-right: 10px;
            border-radius: 8px;
            object-fit: cover;
        }

        .nav-links {
            display: flex;
            list-style: none;
            gap: 2rem;
            align-items: center;
        }

        .nav-links a {
            color: #1e3a8a;
            text-decoration: none;
            font-weight: 500;
            font-size: 1.1rem;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
        }

        .nav-links a:hover {
            background-color: #e5e7eb;
        }

        /* Profile Button Styles */
        .profile-button {
            color: #ecf0f1;
            text-decoration: none;
            font-weight: 500;
            font-size: 1.1rem;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
        }

        .profile-button:hover {
            background-color: #34495e;
        }

        /* Profile Dropdown Styles */
        .profile-dropdown {
            position: relative;
        }

        .profile-icon {
            display: flex;
            align-items: center;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-size: 1rem;
            font-weight: 500;
            position: relative;
        }


        .profile-icon:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .profile-avatar {
            font-size: 1.2rem;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
        }

        .profile-avatar img {
            border-radius: 50%;
            background: white;
        }


        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 180px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 1000;
            border: 1px solid #e9ecef;
        }

        .profile-dropdown:hover .dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            color: #1a1a1a;
            text-decoration: none;
            transition: all 0.2s ease;
            border-bottom: 1px solid #f8f9fa;
            width: 100%;
            box-sizing: border-box;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background-color: transparent !important;
            color: #1a1a1a !important;
            transform: translateX(2px);
        }
        
        /* Initially hide subscription tab only for users with active subscription */
        .subscription-tab-li {
            display: block; /* Show by default for free users */
        }
        
        /* Hide only if user has active subscription (set by JavaScript) */
        .subscription-tab-li.hidden-for-subscriber {
            display: none;
        }

        .dropdown-icon {
            font-size: 1rem;
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }

        .dropdown-text {
            font-size: 0.9rem;
            font-weight: 500;
            color: #1a1a1a;
        }

        .nav-links a.active {
            background-color: #1e3a8a;
            color: #ffffff;
        }

        .main-layout {
            display: flex;
            flex-direction: column;
            min-height: calc(100vh - 60px);
            justify-content: center;
            align-items: center;
            padding: 0.5rem 0 2rem 0;
        }

        /* Games Tabs Styles */
        .games-tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 0;
            border-bottom: 2px solid transparent;
            width: 100%;
        }

        .games-tabs .tab {
            padding: 1rem 2rem;
            cursor: pointer;
            font-weight: 600;
            color: #7f8c8d;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            font-size: 1.1rem;
            flex: 1;
            text-align: center;
            max-width: 200px;
        }

        .games-tabs .tab.active {
            color: #1e3a8a;
            border-bottom-color: #1e3a8a;
        }

        .games-tabs .tab:hover {
            color: #1e3a8a;
        }

        /* Tab Content Styles */
        .tab-content {
            width: 100%;
            max-width: 400px;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        /* Simplified Tab Content Styles */
        .my-games-content, .gm-games-content {
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .my-games-header, .gm-games-header {
            text-align: center;
            margin-bottom: 1rem;
        }

        .my-games-header h3, .gm-games-header h3 {
            font-size: 1.3rem;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .my-games-header p, .gm-games-header p {
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .my-games-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .stat-card {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e0e0e0;
        }

        .stat-card .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1e3a8a;
            margin-bottom: 0.25rem;
        }

        .stat-card .stat-label {
            color: #7f8c8d;
            font-weight: 500;
            font-size: 0.8rem;
        }

        .my-games-list {
            min-height: 100px;
        }

        .loading {
            text-align: center;
            padding: 1rem;
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .gm-categories {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .gm-category h4 {
            font-size: 1rem;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid #1e3a8a;
        }

        .gm-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .gm-item {
            background: white;
            padding: 0.75rem;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .gm-item:hover {
            border-color: #1e3a8a;
        }

        .gm-name {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .gm-games-count {
            color: #7f8c8d;
            font-size: 0.8rem;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 0.75rem;
        }

        .game-item {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            transition: all 0.3s ease;
        }

        .game-item.completed {
            border-color: #2ecc71;
            background: #f0f9f4;
        }

        .game-item:hover {
            border-color: #1e3a8a;
        }

        .game-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }

        .game-info {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .game-moves, .game-difficulty {
            font-size: 0.8rem;
            color: #7f8c8d;
        }

        .game-status {
            font-weight: 600;
            color: #2ecc71;
            font-size: 0.8rem;
        }

        .empty-state {
            text-align: center;
            padding: 2rem;
            color: #7f8c8d;
        }

        .empty-state h4 {
            margin-bottom: 0.5rem;
            color: #2c3e50;
            font-size: 1rem;
        }

        .main-layout {
            display: flex;
            flex-direction: column;
            min-height: calc(100vh - 60px);
            justify-content: flex-start;
            align-items: center;
            padding: 0.5rem 0 2rem 0;
            position: relative;
        }

        .top-section {
            width: 100%;
            max-width: 800px;
            margin-top: 10px;
            margin-left: -95px;
            display: flex;
            justify-content: flex-start;
        }

        .bottom-section {
            display: flex;
            flex-direction: row;
            width: 100%;
            max-width: 1400px;
            gap: 1rem;
            align-items: flex-start;
            justify-content: center;
            margin-left: -20px;
        }

        .left-panel {
            flex: 0 0 310px;
            min-width: 350px;
            display: flex;
            flex-direction: column;
            margin-top: 30px;
            margin-left: 25px;
        }
        
        /* Hide left panel for Weekly tab */
        .tab-panel.active ~ .bottom-section .left-panel {
            display: none;
        }
        
        /* Adjust right panel when left panel is hidden */
        .tab-panel.active ~ .bottom-section .right-panel {
            flex: 1;
            max-width: none;
        }

        .right-panel {
            flex: 1;
            min-width: 600px;
            max-width: 1000px;
            display: flex;
            flex-direction: column;
            margin-left: -10px;
        }

        .main-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .game-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 1.25rem;
            width: 280px;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border: none;
        }

        .game-button {
            background-color: #ffffff;
            border: 2px solid #bdc3c7;
            border-radius: 12px;
            padding: 1rem;
            text-decoration: none;
            color: #2c3e50;
            text-align: center;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            width: 100%;
        }

        .game-button:hover {
            border-color: #1e3a8a;
            background-color: #f8f9fa;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .submenu-button.locked {
            position: relative;
            cursor: not-allowed;
        }

        .submenu-button.locked:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            background-color: #ffffff;
            margin: 5% auto;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            position: relative;
            animation: slideIn 0.3s ease;
        }

        .modal-header {
            margin-bottom: 1.5rem;
            position: relative;
        }

        .modal-header h2 {
            margin: 0;
            color: #2c3e50;
            font-size: 1.25rem;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            color: #2c3e50;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1rem;
            box-sizing: border-box;
        }

        .form-input:focus {
            outline: none;
            border-color: #1e3a8a;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .btn-modal {
            flex: 1;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background-color: #1e3a8a;
            color: white;
        }

        .btn-primary:hover {
            background-color: #1e40af;
        }

        .btn-secondary {
            background-color: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #7f8c8d;
        }

        .account-info {
            padding: 1rem 0;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid #f8f9fa;
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .info-item label {
            font-weight: 600;
            color: #2c3e50 !important;
            min-width: 100px;
        }

        .info-item span {
            color: #7f8c8d !important;
            text-align: right;
        }

        .register-link {
            text-align: center;
            margin-top: 1rem;
        }

        .register-link a {
            color: #1e3a8a;
            text-decoration: none;
        }

        .register-link a:hover {
            text-decoration: underline;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
        }

        .close:hover {
            color: #000;
        }

        .btn-google {
            background-color: #ffffff;
            color: #333;
            border: 1px solid #dadce0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: box-shadow 0.2s;
            width: 100%;
        }

        .btn-google:hover {
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .google-icon {
            width: 20px;
            height: 20px;
            background: url('images/google.png') no-repeat center;
            background-size: contain;
        }

        .google-signup {
            margin-top: 1rem;
            text-align: center;
        }

        /* Logout Confirmation Modal */
        .logout-confirm-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s ease;
        }

        .logout-confirm-content {
            background-color: #ffffff;
            margin: 15% auto;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            position: relative;
            animation: slideIn 0.3s ease;
            text-align: center;
        }

        .logout-confirm-header {
            margin-bottom: 1.5rem;
        }

        .logout-confirm-header h2 {
            margin: 0;
            color: #2c3e50;
            font-size: 1.25rem;
            font-weight: 600;
        }

        .logout-confirm-message {
            color: #7f8c8d;
            margin-bottom: 2rem;
            line-height: 1.5;
        }

        .logout-confirm-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .btn-logout-confirm {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .btn-logout-yes {
            background-color: #e74c3c;
            color: white;
        }

        .btn-logout-yes:hover {
            background-color: #c0392b;
        }

        .btn-logout-no {
            background-color: #95a5a6;
            color: white;
        }

        .btn-logout-no:hover {
            background-color: #7f8c8d;
        }

        /* Subscription Required Modal */
        .subscription-required-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s ease;
        }

        .subscription-required-content {
            background-color: #ffffff;
            margin: 15% auto;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 450px;
            position: relative;
            animation: slideIn 0.3s ease;
        }

        .subscription-required-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .subscription-required-header h2 {
            color: #2c3e50;
            margin: 0;
            font-size: 1.5rem;
        }

        .subscription-required-message {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .subscription-required-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .btn-subscription-required {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .btn-subscription-yes {
            background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
            color: white;
        }

        .btn-subscription-yes:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        .btn-subscription-no {
            background: #95a5a6;
            color: white;
        }

        .btn-subscription-no:hover {
            background: #7f8c8d;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .lock-overlay {
            position: absolute;
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #7f8c8d;
            font-weight: bold;
            z-index: 10;
        }

        .lock-icon {
            font-size: 1.5rem;
            margin-bottom: 0.25rem;
        }

        .lock-text {
            font-size: 0.7rem;
            text-align: center;
        }

        .game-button.active {
            border-color: #1e3a8a;
            background-color: #e0e7ff;
            color: #1e40af;
        }

        .game-button .description {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-top: 0.5rem;
            font-weight: 400;
        }

        .game-button-container {
            display: flex;
            flex-direction: column;
        }

        .game-button-container .game-button {
            background-color: #ffffff;
            border: 2px solid #bdc3c7;
            border-radius: 12px;
            padding: 1rem;
            text-decoration: none;
            color: #2c3e50;
            text-align: center;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            width: 100%;
        }

        .game-button-container .game-button:hover {
            border-color: #1e3a8a;
            background-color: #f8f9fa;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .game-button-container .game-button.active {
            border-color: #1e3a8a;
            background-color: #e0e7ff;
            color: #1e40af;
        }

        .submenu {
            display: none;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
            padding-left: 1rem;
            animation: slideDown 0.3s ease-out;
        }

        .submenu.show {
            display: flex;
        }

        .submenu-button {
            background-color: #e9ecef;
            border: 1px solid #ced4da;
            border-radius: 8px;
            padding: 0.75rem;
            text-decoration: none;
            color: #495057;
            text-align: center;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .submenu-button:hover {
            background-color: #dee2e6;
            border-color: #adb5bd;
            transform: translateX(5px);
        }

        .submenu-button.selected {
            transform: translateX(6px) !important;
            background-color: #e0e7ff !important;
            border: 1px solid #1e3a8a !important;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2) !important;
            font-weight: normal !important;
            color: #1e3a8a !important;
        }

        .submenu-button.selected:hover {
            background-color: #e0e7ff !important;
            border-color: #1e3a8a !important;
            transform: translateX(6px) !important;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2) !important;
        }

        .game-completion-badge {
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%) scale(0);
            opacity: 0;
            transition: all 0.15s ease;
            z-index: 10;
        }

        .game-completion-badge img {
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }

        .game-completion-badge.show {
            opacity: 1;
            transform: translateY(-50%) scale(1);
        }

        .game-completion-badge:hover::after {
            content: "Memory challenge completed";
            position: absolute;
            bottom: 100%;
            right: 0;
            background-color: #333;
            color: white;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            margin-bottom: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .game-completion-badge:hover::before {
            content: "";
            position: absolute;
            bottom: 100%;
            right: 8px;
            border: 4px solid transparent;
            border-top-color: #333;
            z-index: 1000;
            margin-bottom: -4px;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .game-display {
            display: block;
            padding: 1rem 2rem;
        }

        .game-display.show {
            display: block;
        }

        .game-content {
            display: flex;
            gap: 3.5rem;
            align-items: flex-start;
            justify-content: center;
            width: 100%;
            max-width: 1000px;
        }

        .board-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
        }

         .visual-modes {
             display: flex;
             flex-direction: row;
             gap: 1rem;
             justify-content: center;
             align-items: center;
             padding: 1rem;
             background-color: #f8f9fa;
             border-radius: 12px;
             border: 2px solid #dee2e6;
             box-shadow: 0 4px 12px rgba(0,0,0,0.1);
             width: 520px;
         }


        .mode-option {
            background-color: #ffffff;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            color: #495057;
            transition: all 0.2s ease;
            text-align: center;
            min-height: 40px;
            min-width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mode-option:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-1px);
        }

        .mode-option.active {
            background-color: #1e3a8a;
            border-color: #1e40af;
            color: white;
        }

        .mode-option.active:hover {
            background-color: #1e40af;
            transform: translateY(-1px);
        }


        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 520px;
            height: 520px;
            border: 3px solid #2c3e50;
            border-radius: 10px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.25);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 6px;
            position: relative;
        }

        .chess-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            border-radius: 4px;
        }

        .chess-board.dragging .chess-square {
            transition: none !important;
        }

        /* Board coordinates styles */
        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .board-coordinates {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .board-notation {
            display: flex;
            width: 502px;
            margin: 5px auto 0 auto;
            justify-content: space-between;
        }
        
        .notation-letter {
            width: 62.75px;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            color: #000000;
            padding: 5px 0;
            box-sizing: border-box;
        }
        
        .rank-notation {
            display: flex;
            flex-direction: column;
            width: 47.5px;
            height: 502px;
            position: absolute;
            right: -40.5px;
            top: 7px;
            justify-content: space-between;
        }
        
        .notation-number {
            height: 62.75px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: #000000;
            box-sizing: border-box;
        }
        
        .coordinate-labels-bottom {
            grid-area: bottom;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            height: 20px;
        }

        .coordinate-labels-right {
            grid-area: right;
            display: grid;
            grid-template-rows: repeat(8, 1fr);
            width: 20px;
        }

        .coordinate-label {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #2c3e50;
            user-select: none;
        }

        .coordinate-label.letter {
            color: #34495e;
        }

        .coordinate-label.number {
            color: #34495e;
        }

        .chess-square.light {
            background: linear-gradient(135deg, #f0d9b5 0%, #e8d5b7 100%);
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
        }

        .chess-square.dark {
            background: linear-gradient(135deg, #b58863 0%, #a67c52 100%);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .chess-square:hover {
            background: linear-gradient(135deg, #ffeb3b 0%, #ffc107 100%);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(255,235,59,0.4);
            z-index: 10;
        }

        .chess-piece {
            width: 60px;
            height: 60px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transition: all 0.2s ease;
            cursor: grab;
        }
        
        .chess-piece.dragging {
            transition: none !important;
        }

        .chess-piece:hover {
            transform: scale(1.1);
        }

        .chess-piece:active {
            cursor: grabbing;
        }

        .chess-square.valid-move {
            background-color: rgba(144, 238, 144, 0.3) !important;
            outline: 3px solid #32CD32;
            outline-offset: -3px;
        }
        
        .chess-square.valid-move:hover {
            background-color: rgba(152, 251, 152, 0.4) !important;
        }

        .chess-square.selected {
            background: #FFD700 !important;
            box-shadow: inset 0 2px 4px rgba(255, 215, 0, 0.5) !important;
        }

        .chess-square.selected.light {
            background: #FFD700 !important;
            box-shadow: inset 0 2px 4px rgba(255, 215, 0, 0.5) !important;
        }

        .chess-square.selected.dark {
            background: #FFD700 !important;
            box-shadow: inset 0 2px 4px rgba(255, 215, 0, 0.5) !important;
        }

        .moves-panel {
            width: 420px;
            background-color: #ffffff;
            margin-left: 30px;
            border: none;
            border-radius: 12px;
            padding: 1.25rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            max-height: 630px;
            overflow-y: auto;
            align-self: flex-start;
        }

        .game-header {
            background: #ffffff;
            color: #333333;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            border: 1px solid #e0e0e0;
            box-shadow: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .game-header:hover {
            background: #f5f5f5;
            border-color: #cccccc;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .game-header::after {
            content: '▼';
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.2s ease;
            font-size: 0.8rem;
            color: #666666;
        }

        .game-header.expanded::after {
            transform: translateY(-50%) rotate(180deg);
        }


        .game-title-line {
            font-size: 1rem;
            font-weight: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333333;
            text-align: center;
        }

        .move-count {
            font-size: 0.85rem;
            color: #666666;
            background: #e9ecef;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-weight: 400;
        }

        .move-count-left {
            font-size: 0.8rem;
            color: #7f8c8d;
            font-weight: 400;
            font-style: italic;
        }

        .game-title {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .game-info {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .game-details {
            background-color: #f8f9fa;
            border: none;
            border-radius: 0 0 6px 6px;
            margin-top: 0;
            max-height: 0;
            overflow: hidden;
            padding: 0 1rem;
            transition: max-height 0.4s ease, padding 0.4s ease, margin 0.4s ease;
        }

        .game-details.show {
            max-height: 600px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e9ecef;
        }

        .detail-item:last-child {
            border-bottom: none;
        }

        .detail-label {
            font-weight: bold;
            color: #2c3e50;
            font-size: 0.9rem;
            flex-shrink: 0;
            margin-right: 1rem;
        }

        .detail-value {
            color: #495057;
            font-size: 0.9rem;
            text-align: right;
            line-height: 1.4;
            flex: 1;
        }

        .detail-facts {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #dee2e6;
        }

        .facts-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .facts-text {
            color: #495057;
            font-size: 0.85rem;
            line-height: 1.4;
        }


        .move-controls {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .moves-toggle-icon {
            padding: 0;
            background: transparent;
            border: none;
        }

        .moves-toggle-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .toggle-icon {
            width: 20px;
            height: 20px;
            transition: opacity 0.2s ease;
        }

        .toggle-icon:hover {
            background: #f0f0f0;
        }

        .move-btn {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            color: #495057;
            transition: all 0.2s ease;
            min-width: 40px;
            text-align: center;
        }

        .move-btn:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-1px);
        }

        .move-btn:active {
            transform: translateY(0);
        }

        .move-btn:disabled {
            background-color: #f8f9fa;
            color: #adb5bd;
            cursor: not-allowed;
            transform: none;
        }

        .move-btn:disabled:hover {
            background-color: #f8f9fa;
            border-color: #dee2e6;
            transform: none;
        }

        .move-icon {
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #495057;
            user-select: none;
            width: 40px;
            height: 40px;
            flex-shrink: 0;
        }

        .move-icon:hover {
            background-color: #e9ecef;
            transform: translateY(-1px);
        }

        .move-icon:active {
            transform: translateY(0);
        }

        .move-icon.disabled {
            color: #adb5bd;
            cursor: not-allowed;
            transform: none;
        }

        .move-icon.disabled:hover {
            background-color: transparent;
            transform: none;
        }

          .visual-modes {
              display: flex;
              align-items: center;
              margin-top: 5px;
          }

          .mode-title {
              margin-right: 10px;
              margin-top: 4px;
          }


          .challenge-title {
              font-weight: bold;
              color: #2c3e50;
              font-size: 0.9rem;
              margin-right: 10px;
          }

          .challenge-btn {
              background-color: #ffffff;
              border: 2px solid #dee2e6;
              border-radius: 8px;
              padding: 0.75rem 1.5rem;
              cursor: pointer;
              font-size: 0.85rem;
              font-weight: 500;
              color: #495057;
              transition: all 0.2s ease;
              min-width: 120px;
              text-align: center;
              display: flex;
              align-items: center;
              justify-content: center;
          }

          .challenge-btn:hover {
              background-color: #e9ecef;
              border-color: #adb5bd;
              transform: translateY(-1px);
          }

          .challenge-btn.active {
              background-color: #dc3545;
              border-color: #c82333;
              color: white;
          }

          .test-btn {
              background: linear-gradient(135deg, #ff6b6b, #ee5a24);
              border: 2px solid #ee5a24;
              border-radius: 8px;
              padding: 0.75rem 1.5rem;
              cursor: pointer;
              font-size: 0.85rem;
              font-weight: 600;
              color: white;
              transition: all 0.2s ease;
              min-width: 80px;
              text-align: center;
              display: flex;
              align-items: center;
              justify-content: center;
              box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
          }

          .test-btn:hover {
              background: linear-gradient(135deg, #ee5a24, #d63031);
              border-color: #d63031;
              transform: translateY(-1px);
              box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
          }

          .test-btn.active {
              background: linear-gradient(135deg, #d63031, #a71e2e);
              border-color: #a71e2e;
              box-shadow: 0 2px 8px rgba(214, 48, 49, 0.4);
          }

          .test-btn.active:hover {
              background: linear-gradient(135deg, #a71e2e, #8b1538);
              border-color: #8b1538;
              transform: translateY(-1px);
          }

          .flip-board-icon {
              display: flex;
              align-items: center;
              justify-content: center;
              transition: all 0.2s ease;
          }

          .flip-board-icon:hover {
              transform: scale(1.1);
          }

          .flip-board-icon.flipped {
              transform: rotate(180deg);
          }

          .flip-board-icon.flipped:hover {
              transform: rotate(180deg) scale(1.1);
          }


          .completion-badge {
              position: fixed;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%) scale(0);
              background: #ffffff;
              color: #2c3e50;
              padding: 2.5rem 3rem;
              border-radius: 12px;
              box-shadow: 0 12px 24px rgba(0,0,0,0.15), 0 0 0 1px rgba(0,0,0,0.05);
              text-align: center;
              z-index: 9999;
              font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
              border: 2px solid #e8f5e8;
              transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
              max-width: 400px;
              backdrop-filter: blur(20px);
          }

          .completion-badge.show {
              transform: translate(-50%, -50%) scale(1);
          }

          .completion-badge .badge-icon {
              margin-bottom: 1.5rem;
              text-align: center;
              animation: bounce 1s infinite;
              filter: drop-shadow(0 2px 4px rgba(40, 167, 69, 0.2));
          }

          .completion-badge .badge-title {
              font-size: 1.75rem;
              font-weight: 700;
              margin-bottom: 0.75rem;
              color: #2c3e50;
              letter-spacing: -0.5px;
          }

          .completion-badge .badge-subtitle {
              font-size: 1rem;
              color: #7f8c8d;
              margin-bottom: 2rem;
              line-height: 1.5;
              font-weight: 400;
          }

          .completion-badge .badge-close {
              background: linear-gradient(135deg, #1e3a8a, #1e40af);
              border: 2px solid #1e3a8a;
              color: white;
              padding: 0.75rem 2rem;
              border-radius: 8px;
              cursor: pointer;
              font-size: 0.95rem;
              font-weight: 600;
              transition: all 0.2s ease;
              font-family: inherit;
              box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
          }

          .completion-badge .badge-close:hover {
              background: linear-gradient(135deg, #1e40af, #1e3a8a);
              border-color: #1e40af;
              transform: translateY(-1px);
              box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
          }

          .badge-overlay {
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: rgba(44, 62, 80, 0.85);
              backdrop-filter: blur(4px);
              z-index: 9998;
              opacity: 0;
              transition: all 0.3s ease;
              pointer-events: none;
          }

          .badge-overlay.show {
              opacity: 1;
              pointer-events: all;
          }

          @keyframes bounce {
              0%, 20%, 50%, 80%, 100% {
                  transform: translateY(0);
              }
              40% {
                  transform: translateY(-10px);
              }
              60% {
                  transform: translateY(-5px);
              }
          }

          .moves-title {
            font-size: 1.2rem;
            color: #2c3e50;
            margin-bottom: 1rem;
            text-align: center;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 0.5rem;
        }

        .move-item {
            padding: 0.25rem 0.5rem;
            background-color: #fff;
            border: none;
            margin-bottom: 0.1rem;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            color: #495057;
            transition: background-color 0.2s ease;
            user-select: none;
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
        }


        .move-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-height: 1rem;
            padding: 0.1rem 0;
        }

        .move-number {
            font-weight: bold;
            color: #6c757d;
            font-size: 0.9rem;
            min-width: 1.5rem;
            text-align: center;
        }

        .white-moves {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
            padding: 0.3rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .black-moves {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
            justify-content: flex-start;
            padding: 0.3rem 0.3rem 0.3rem 1.3rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .clickable-move {
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: background-color 0.2s ease;
            display: inline-block;
            font-size: 1rem;
            font-weight: normal;
        }

        .white-moves:hover .clickable-move {
            background-color: #f8f9fa;
        }

        .black-moves:hover .clickable-move {
            background-color: #f8f9fa;
        }

        .white-moves.clicked .clickable-move {
            background-color: #e0e7ff;
            color: #1e3a8a;
        }

        .black-moves.clicked .clickable-move {
            background-color: #e0e7ff;
            color: #1e3a8a;
        }

        .clickable-move.active-move {
            font-weight: bold;
        }


        .moves-container {
            padding: 0.5rem;
            background-color: #fff;
            border-radius: 4px;
            border: 1px solid #e9ecef;
            margin-top: 0.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.125rem;
        }


        .main-content {
            flex: 1;
            padding: 1rem 2rem;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 1200px;
            width: 100%;
        }

        .main-content h1 {
            color: #2c3e50;
            margin-bottom: 1rem;
        }

        .main-content p {
            color: #7f8c8d;
            font-size: 1.1rem;
        }

        @media (max-width: 768px) {
            .navbar {
                padding: 0.5rem 1rem;
                flex-direction: column;
                gap: 0.5rem;
            }

            .nav-links {
                gap: 1rem;
            }

            .nav-links a {
                padding: 0.4rem 0.8rem;
                font-size: 0.9rem;
            }

            .main-content {
                padding: 0.5rem 1rem;
            }

            .game-display {
                padding: 0.5rem 1rem;
            }

            .main-layout {
                flex-direction: column;
                align-items: center;
                padding: 0.25rem 0 1rem 0;
            }
            
            .bottom-section {
                flex-direction: column;
                gap: 1rem;
                align-items: center;
                padding: 0 1rem;
            }
            
            .left-panel {
                flex: none;
                width: 100%;
                max-width: 400px;
                margin-left: 40px;
            }
            
            .right-panel {
                flex: none;
                width: 100%;
                max-width: 500px;
                margin-left: 15px;
            }

            .game-buttons {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
                padding: 1.25rem;
                margin-left: 1rem;
                gap: 0.5rem;
            }

            .game-button {
                flex: 1;
                min-width: 120px;
                padding: 0.8rem 0.5rem;
                font-size: 0.9rem;
            }
        }
        
        /* Responsive styles for smaller laptops */
        @media (max-width: 1200px) {
            .bottom-section {
                gap: 1.5rem;
            }
            
            .left-panel {
                flex: 0 0 350px;
                min-width: 300px;
            }
            
            .right-panel {
                min-width: 500px;
            }
            
            .game-buttons {
                width: 240px;
                padding: 1.25rem;
            }
            
            .game-content {
                gap: 2rem;
            }
            
            .chess-board {
                width: 440px;
                height: 440px;
            }
            
            .board-coordinates {
                grid-template-columns: 440px 20px;
                grid-template-rows: 440px 20px;
            }
            
            .visual-modes {
                width: 440px;
            }
            
            .moves-panel {
                width: 360px;
                max-height: 550px;
            }
            
            .chess-piece {
                width: 50px;
                height: 50px;
            }
        }

        /* Toggle Switch Styles */
        .toggle-switch {
            position: relative;
            display: inline-block;
        }

        .toggle-switch input[type="checkbox"] {
            display: none;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 2px 4px;
            background: transparent;
            border: none;
            border-radius: 6px;
            transition: all 0.3s ease;
            font-size: 12px;
            font-weight: 500;
            color: #495057;
        }

        .toggle-label::before {
            content: '';
            width: 24px;
            height: 12px;
            background: #dee2e6;
            border-radius: 12px;
            margin-right: 6px;
            position: relative;
            transition: all 0.3s ease;
        }

        .toggle-label::after {
            content: '';
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            position: absolute;
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
            transition: all 0.3s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .toggle-switch input:checked + .toggle-label {
            background: transparent;
            border: none;
            color: #495057;
        }

        .toggle-switch input:checked + .toggle-label::before {
            background: #28a745;
        }

        .toggle-switch input:checked + .toggle-label::after {
            left: 20px;
        }

        .toggle-label:hover {
            background: transparent;
        }

        .toggle-switch input:checked + .toggle-label:hover {
            background: transparent;
        }


        .toggle-icon {
            width: 36px;
            height: 36px;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s ease;
            background: transparent;
        }

        .toggle-icon:hover {
            background: #f0f0f0;
        }


        /* Confetti styles */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #ff6b6b;
            animation: confetti-fall 3s linear infinite;
            z-index: 9999;
        }

        .confetti:nth-child(2n) {
            background: #4ecdc4;
            animation-delay: 0.1s;
        }

        .confetti:nth-child(3n) {
            background: #45b7d1;
            animation-delay: 0.2s;
        }

        .confetti:nth-child(4n) {
            background: #96ceb4;
            animation-delay: 0.3s;
        }

        .confetti:nth-child(5n) {
            background: #feca57;
            animation-delay: 0.4s;
        }

        .confetti:nth-child(6n) {
            background: #ff9ff3;
            animation-delay: 0.5s;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Game completion indicator */
        .completion-indicator {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #4CAF50;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            font-weight: bold;
            z-index: 10;
            animation: completionPulse 2s ease-in-out infinite;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
            opacity: 1;
        }

        @keyframes completionPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 4px 12px rgba(76, 175, 80, 0.6);
            }
        }

        /* Custom Game Valid Move Highlighting */
        .valid-move {
            background-color: rgba(0, 255, 0, 0.3) !important;
            outline: 2px solid #00ff00;
            outline-offset: -2px;
        }

        .valid-move:hover {
            background-color: rgba(0, 255, 0, 0.5) !important;
        }

        /* Delete Game Button - Subtle Version */
        .delete-game-btn-subtle {
            background: #f8f9fa;
            color: #6c757d;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .delete-game-btn-subtle:hover {
            background: #e9ecef;
            color: #495057;
            border-color: #adb5bd;
        }

        .delete-game-btn-subtle:active {
            transform: scale(0.98);
        }


        /* Custom Game Info Section Styles */
        .custom-game-info-section {
            margin-bottom: 15px;
        }

        .custom-game-info-section .game-header {
            background: #ffffff;
            color: #333333;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            border: 1px solid #e0e0e0;
            box-shadow: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .custom-game-info-section .game-header:hover {
            background: #f5f5f5;
            border-color: #cccccc;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .custom-game-info-section .game-header::after {
            content: '▼';
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.2s ease;
            font-size: 0.8rem;
            color: #666666;
        }

        .custom-game-info-section .game-header.expanded::after {
            transform: translateY(-50%) rotate(180deg);
        }

        .custom-game-info-section .game-details {
            background-color: #f8f9fa;
            border: none;
            border-radius: 0 0 6px 6px;
            margin-top: 0;
            max-height: 0;
            overflow: hidden;
            padding: 0 1rem;
            transition: max-height 0.4s ease, padding 0.4s ease, margin 0.4s ease;
        }

        .custom-game-info-section .game-details.show {
            max-height: 600px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .custom-game-info-section #custom-game-title-input {
            background: none;
            border: none;
            text-align: center;
            font-size: inherit;
            font-weight: inherit;
            color: inherit;
            width: 100%;
            outline: none;
            font-family: inherit;
            padding: 0;
            margin: 0;
        }

        .custom-game-info-section #custom-game-title-input:focus {
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #1e3a8a;
            border-radius: 4px;
            padding: 2px 6px;
        }

        .custom-game-info-section #custom-game-title-input::placeholder {
            color: #999;
            font-style: italic;
        }

        .custom-game-info-section #custom-game-title-input:invalid {
            border: 1px solid #e74c3c;
        }

        /* Custom Detail Input Styles */
        .custom-detail-input {
            background: #ffffff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 13px;
            font-family: inherit;
            color: #333;
            width: 100%;
            max-width: 200px;
            transition: border-color 0.2s ease;
        }

        .custom-detail-input:focus {
            outline: none;
            border-color: #1e3a8a;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .custom-detail-input[readonly] {
            background: #f8f9fa;
            color: #6c757d;
            cursor: not-allowed;
        }

        .custom-detail-select {
            background: #ffffff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 13px;
            font-family: inherit;
            color: #333;
            width: 100%;
            max-width: 200px;
            transition: border-color 0.2s ease;
            cursor: pointer;
        }

        .custom-detail-select:focus {
            outline: none;
            border-color: #1e3a8a;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e9ecef;
        }

        .detail-item:last-child {
            border-bottom: none;
        }

        @media (max-width: 900px) {
            .bottom-section {
                flex-direction: column;
                gap: 1rem;
                align-items: center;
            }
            
            .left-panel {
                flex: none;
                width: 100%;
                max-width: 500px;
                margin-left: 40px;
            }
            
            .right-panel {
                flex: none;
                width: 100%;
                max-width: 600px;
                margin-left: 15px;
            }
            
            .game-buttons {
                padding: 1.25rem;
                margin-left: 1rem;
            }
            
            .game-content {
                flex-direction: column;
                align-items: center;
                gap: 2rem;
            }
            
            .chess-board {
                width: 400px;
                height: 400px;
            }
            
            .board-coordinates {
                grid-template-columns: 400px 20px;
                grid-template-rows: 400px 20px;
            }
            
            .visual-modes {
                width: 400px;
            }
            
            .moves-panel {
                width: 360px;
                max-height: 470px;
            }
            
            .chess-piece {
                width: 46px;
                height: 46px;
            }
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <a href="index.html" class="logo">
            <img src="images/chess-board.png" alt="Memo Chess" class="logo-icon">
            <span>Memo Chess</span>
        </a>
                <ul class="nav-links">
                    <li><a href="index.html">Home</a></li>
                <li><a href="games.html">Games</a></li>
                <li><a href="puzzles.html" class="active">Puzzles</a></li>
                <!-- <li><a href="leaderboard.html">Community</a></li> -->
                <!-- <li class="subscription-tab-li"><a href="subscription.html" id="subscriptionTab">Subscription</a></li> -->
                    <!-- <li class="profile-dropdown">
                        <a href="#" id="profileLink" class="profile-button">Profile</a>
                        <div class="dropdown-menu" id="profileDropdown">
                            <a href="profile.html" class="dropdown-item" id="profileMenuItem">
                                <span class="dropdown-text">My Profile</span>
                            </a>
                            <a href="#" class="dropdown-item" id="accountInfoMenuItem" style="display: none;">
                                <span class="dropdown-text">Account Information</span>
                            </a>
                            <a href="#" class="dropdown-item" id="signInMenuItem">
                                <span class="dropdown-text">Sign In</span>
                            </a>
                            <a href="#" class="dropdown-item" id="logoutMenuItem" style="display: none;">
                                <span class="dropdown-text">Logout</span>
                            </a>
                        </div>
                    </li> -->
                </ul>
    </nav>

    <div class="main-layout">
        <!-- Top Section: Games Tabs -->
        <div class="top-section">
        <div class="games-tabs">
            <div class="tab active" data-tab="difficulty">By Difficulty</div>
            <div class="tab" data-tab="gm-games">Weekly</div>
        </div>
        </div>

        <!-- Bottom Section: Left and Right Panels -->
        <div class="bottom-section">
            <!-- Left Side: Game Selection -->
            <div class="left-panel">
                <!-- Tab Content -->
                <div class="tab-content">
                <!-- Puzzles by Difficulty Tab -->
                <div class="tab-panel active" id="difficulty-panel">
        <div class="game-buttons">
            <div class="game-button-container">
                <a href="#short-games" class="game-button active" id="short-games-btn">
                    <div>Easy</div>
                    <div class="description">Visualizing basic shapes</div>
                </a>
                <div class="submenu" id="short-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            <div class="game-button-container">
                <a href="#medium-games" class="game-button" id="medium-games-btn">
                    <div>Intermediate</div>
                    <div class="description">Tracking relationships</div>
                </a>
                <div class="submenu" id="medium-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            <div class="game-button-container">
                <a href="#long-games" class="game-button" id="long-games-btn">
                    <div>Advanced</div>
                    <div class="description">Maintaining full board image</div>
            </a>
                <div class="submenu" id="long-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            <div class="game-button-container">
                <a href="#epic-games" class="game-button" id="epic-games-btn">
                    <div>Epic</div>
                    <div class="description">Deep calculation under load</div>
                </a>
                <div class="submenu" id="epic-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
                </div>
            </div>
        </div>


        <!-- Weekly Tab -->
        <div class="tab-panel" id="gm-games-panel">
            <!-- Left panel is hidden for Weekly - puzzle loads directly -->
        </div>
        </div>
        </div>

            <!-- Right Side: Board and Moves -->
            <div class="right-panel">
        <main class="main-content">
            <div class="game-display" id="game-display">
                <div class="game-content">
                    <div class="board-section">
                        <div class="board-container">
                            <div class="board-coordinates">
                                <div class="chess-board" id="chess-board">
                                    <!-- Chess board will be generated by JavaScript -->
                                </div>
                                
                                <!-- Rank notation to the right of the board -->
                                <div class="rank-notation">
                                    <div class="notation-number">8</div>
                                    <div class="notation-number">7</div>
                                    <div class="notation-number">6</div>
                                    <div class="notation-number">5</div>
                                    <div class="notation-number">4</div>
                                    <div class="notation-number">3</div>
                                    <div class="notation-number">2</div>
                                    <div class="notation-number">1</div>
                                </div>
                            </div>
                            
                            <!-- Square notation below the board -->
                            <div class="board-notation">
                                <div class="notation-letter">a</div>
                                <div class="notation-letter">b</div>
                                <div class="notation-letter">c</div>
                                <div class="notation-letter">d</div>
                                <div class="notation-letter">e</div>
                                <div class="notation-letter">f</div>
                                <div class="notation-letter">g</div>
                                <div class="notation-letter">h</div>
                            </div>
                        </div>
                         <div class="visual-modes">
                             <div class="mode-option active" data-mode="normal">Normal</div>
                             <div class="mode-option" data-mode="grey">Black</div>
                             <div class="mode-option" data-mode="checkers">Checkers</div>
                             <div class="mode-option" data-mode="empty">Empty</div>
                             <button class="test-btn" id="challenge-btn">Test</button>
                         </div>
                     </div>
                    <div class="moves-panel" id="moves-panel">
                        <!-- Puzzle Position Info -->
                        <div id="puzzle-position-info" style="display: none; margin-bottom: 10px; padding: 12px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
                            <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px; font-size: 16px;">Puzzle Position</div>
                            <div id="puzzle-pieces-info" style="font-size: 16px; color: #34495e; line-height: 1.4; font-weight: 500;">
                                <!-- Position info will be populated dynamically -->
                            </div>
                            <div id="puzzle-turn-info" style="font-size: 15px; color: #2c3e50; font-weight: 500; margin-top: 6px;">
                                <!-- Turn info will be populated dynamically -->
                            </div>
                        </div>
                        
                        <div class="game-details" id="game-details">
                            <div class="detail-item">
                                <span class="detail-label">Description:</span>
                                <span class="detail-value" id="detail-description">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Moves:</span>
                                <span class="detail-value" id="detail-moves">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">White Player:</span>
                                <span class="detail-value" id="detail-white">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Black Player:</span>
                                <span class="detail-value" id="detail-black">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Opening:</span>
                                <span class="detail-value" id="detail-opening">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Difficulty:</span>
                                <span class="detail-value" id="detail-difficulty">-</span>
                            </div>
                            <div class="detail-facts">
                                <div class="facts-title">Interesting Facts:</div>
                                <div class="facts-text" id="detail-facts">-</div>
                            </div>
                        </div>
                        
                        <!-- Custom Game Information Tab (shown in Add Game mode) -->
                        <div id="custom-game-info" class="custom-game-info-section" style="display: none;">
                            <div class="game-header" id="custom-game-header">
                                <div class="game-title-line" id="custom-game-title-line">
                                    <input type="text" id="custom-game-title-input" value="" placeholder="Enter title" maxlength="25" required style="background: none; border: none; text-align: center; font-size: inherit; font-weight: inherit; color: inherit; width: 100%; outline: none;">
                                </div>
                            </div>
                            <div class="game-details" id="custom-game-details">
                                <div class="detail-item">
                                    <span class="detail-label">Description:</span>
                                    <input type="text" id="custom-detail-description" class="custom-detail-input" placeholder="Enter description..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Moves:</span>
                                    <input type="text" id="custom-detail-moves" class="custom-detail-input" value="0" readonly>
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">White Player:</span>
                                    <input type="text" id="custom-detail-white" class="custom-detail-input" placeholder="Enter white player name..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Black Player:</span>
                                    <input type="text" id="custom-detail-black" class="custom-detail-input" placeholder="Enter black player name..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Opening:</span>
                                    <input type="text" id="custom-detail-opening" class="custom-detail-input" placeholder="Enter opening name..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Result:</span>
                                    <select id="custom-detail-result" class="custom-detail-select">
                                        <option value="In progress">In progress</option>
                                        <option value="1-0">1-0 (White wins)</option>
                                        <option value="0-1">0-1 (Black wins)</option>
                                        <option value="1/2-1/2">1/2-1/2 (Draw)</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        
                        <div class="move-controls">
                            <div class="move-icon flip-board-icon" id="flip-board-btn" title="Flip board perspective"><img src="images/switch-camera.png" alt="Flip Board" style="width: 20px; height: 20px;"></div>
                            <div class="move-icon" id="btn-initial" title="Go to initial position"><img src="images/fast-forward.png" alt="Initial" style="width: 20px; height: 20px; transform: scaleX(-1);"></div>
                            <div class="move-icon" id="btn-back" title="Previous move"><img src="images/next.png" alt="Back" style="width: 20px; height: 20px; transform: scaleX(-1);"></div>
                            <div class="move-icon" id="btn-forward" title="Next move"><img src="images/next.png" alt="Next" style="width: 20px; height: 20px;"></div>
                            <div class="move-icon" id="btn-final" title="Go to final position"><img src="images/fast-forward.png" alt="Last" style="width: 20px; height: 20px;"></div>
                            <div class="moves-toggle-icon" id="moves-toggle" style="display: none;">
                                <img src="images/hide.png" class="toggle-icon" id="moves-toggle-img" alt="Toggle moves visibility" title="Toggle moves visibility">
                            </div>
                        </div>
                        
                        
                        <div id="moves-list" style="max-height: 300px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 8px; padding: 10px; background: #fff;">
                            <p style="text-align: center; color: #7f8c8d;">Select a game to view moves</p>
                        </div>
                        
                        
                    <!-- Delete Game Button (only for custom games) -->
                    <div id="delete-game-section" style="display: none; margin-top: 15px; text-align: center;">
                        <button id="delete-game-btn" class="delete-game-btn-subtle" title="Delete this custom game">
                            Delete Game
                        </button>
                    </div>


                    </div>
                </div>
            </div>
        </main>
        </div>
        </div>
    </div>

    <!-- Completion Badge -->
    <div class="badge-overlay" id="badge-overlay"></div>
    <div class="completion-badge" id="completion-badge">
        <div class="badge-icon"><img src="images/checklist.png" alt="Complete" style="width: 56px; height: 56px;"></div>
        <div class="badge-title">Challenge Complete!</div>
        <div class="badge-subtitle">You successfully completed the memory challenge</div>
        <button class="badge-close" onclick="hideBadge()">Continue</button>
    </div>

    <script src="chess-move-parser.js?v=2"></script>
    <script src="custom-games.js"></script>
    <script src="progress-tracker.js"></script>
    <script>
        // GameLoader class to handle loading games from files
        class PuzzleLoader {
            static async loadPuzzlesFromFiles() {
                try {
                    console.log('Loading puzzles from files...');
                    
                    // Load puzzles from puzzles.json
                    const puzzlesResponse = await fetch(`games/puzzles.json?t=${Date.now()}&v=2`);
                    
                    let allPuzzles = [];
                    
                    // Load main puzzles
                    if (puzzlesResponse.ok) {
                        const puzzlesData = await puzzlesResponse.json();
                        if (puzzlesData.puzzles && Array.isArray(puzzlesData.puzzles)) {
                            allPuzzles = allPuzzles.concat(puzzlesData.puzzles);
                            console.log(`Loaded ${puzzlesData.puzzles.length} puzzles from puzzles.json`);
                        }
                    } else {
                        console.warn('Could not load puzzles.json:', puzzlesResponse.status);
                    }
                    
                    console.log(`Total puzzles loaded: ${allPuzzles.length}`);
                    console.log('Puzzles with difficulty:', allPuzzles.map(p => ({ name: p.name, difficulty: p.difficulty })));
                    return { puzzles: allPuzzles };
                    
                } catch (error) {
                    console.error('Error loading puzzles:', error);
                    return { puzzles: [] };
                }
            }
        }
    </script>
    <script>
        // Global variables for move navigation
        let currentGame = null;
         let currentMoveIndex = 0;
         let currentVisualMode = 'empty';
         let boardFlipped = false;
         let draggedPiece = null;
         let draggedFromSquare = null;
         let validMoves = [];
         let isChallengeMode = false;
         let completedChallenges = new Set(); // Track completed challenges
         let puzzlesData = null; // Store puzzles data
         
         // Load completed challenges from progress tracker
         function loadCompletedChallenges() {
             return progressTracker.getAllCompletedChallengesSet();
         }
         let selectedPiece = null; // Track clicked/selected piece
         let selectedSquare = null; // Track selected square
         
         // Initialize progress tracker
         let progressTracker = new ProgressTracker();
         
         // Initialize the move parser
         const moveParser = new ChessMoveParser();
        
        // Audio objects for sound effects - using your custom sound file
        const customSound = new Audio('sounds/click-21156.mp3');
        
        // Function to play sound effects - using your custom sound file
        function playSound(isCapture) {
            try {
                // Reset the sound to the beginning and play
                customSound.currentTime = 0;
                customSound.play().catch(error => {
                    console.log('Sound play failed:', error);
                });
            } catch (error) {
                console.log('Could not play sound:', error);
            }
        }

        // Load games data dynamically
        let gamesData = null;
        
        // Check login status and update navigation
        function updateNavigation() {
            const profileLink = document.getElementById('profileLink');
            const profileMenuItem = document.getElementById('profileMenuItem');
            const accountInfoMenuItem = document.getElementById('accountInfoMenuItem');
            const signInMenuItem = document.getElementById('signInMenuItem');
            const logoutMenuItem = document.getElementById('logoutMenuItem');
            const subscriptionTab = document.getElementById('subscriptionTab');
            const isLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
            const hasActiveSubscription = localStorage.getItem('hasActiveSubscription') === 'true';
            
            // Show/hide subscription tab based on subscription status
            const subscriptionLi = document.querySelector('.subscription-tab-li');
            if (hasActiveSubscription) {
                subscriptionLi.classList.add('hidden-for-subscriber');
            } else {
                subscriptionLi.classList.remove('hidden-for-subscriber');
            }
            
            if (isLoggedIn) {
                // User is logged in - show profile, account info, and logout options
                profileMenuItem.style.display = 'flex';
                accountInfoMenuItem.style.display = 'flex';
                logoutMenuItem.style.display = 'flex';
                signInMenuItem.style.display = 'none';
                
                // Set up profile menu item
                profileMenuItem.onclick = function(e) {
                    e.preventDefault();
                    window.location.href = 'profile.html';
                };
                
                // Set up account info menu item
                accountInfoMenuItem.onclick = function(e) {
                    e.preventDefault();
                    showAccountInfoModal();
                };
                
                // Set up logout menu item
                logoutMenuItem.onclick = function(e) {
                    e.preventDefault();
                    logout();
                };
                
                // Profile icon click - go to profile
                profileLink.onclick = function(e) {
                    e.preventDefault();
                    window.location.href = 'profile.html';
                };
            } else {
                // User is not logged in - show sign in option
                profileMenuItem.style.display = 'none';
                accountInfoMenuItem.style.display = 'none';
                logoutMenuItem.style.display = 'none';
                signInMenuItem.style.display = 'flex';
                
                // Set up sign in menu item
                signInMenuItem.onclick = function(e) {
                    e.preventDefault();
                    showSignInModal();
                };
                
                // Profile icon click - show sign in modal
                profileLink.onclick = function(e) {
                    e.preventDefault();
                    showSignInModal();
                };
            }
        }

        // Show account information modal
        function showAccountInfoModal() {
            const userName = localStorage.getItem('userName') || 'User';
            const userEmail = localStorage.getItem('userEmail') || 'No email provided';
            const subscriptionPlan = localStorage.getItem('subscriptionPlan') || 'free';
            
            // Format subscription display
            let subscriptionDisplay = 'Free Account';
            if (subscriptionPlan === 'monthly') {
                subscriptionDisplay = 'Premium Monthly';
            } else if (subscriptionPlan === 'quarterly') {
                subscriptionDisplay = 'Premium Quarterly';
            } else if (subscriptionPlan === 'monthly_cancelled') {
                subscriptionDisplay = 'Premium Monthly (Cancelled)';
            } else if (subscriptionPlan === 'quarterly_cancelled') {
                subscriptionDisplay = 'Premium Quarterly (Cancelled)';
            }
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Account Information</h2>
                        <span class="close" onclick="closeModal()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="account-info">
                            <div class="info-item">
                                <label>Name:</label>
                                <span>${userName}</span>
                            </div>
                            <div class="info-item">
                                <label>Email:</label>
                                <span>${userEmail}</span>
                            </div>
                            <div class="info-item">
                                <label>Subscription:</label>
                                <span>${subscriptionDisplay}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.style.display = 'block';
        }

        // Logout function - shows confirmation modal
        function logout() {
            document.getElementById('logoutConfirmModal').style.display = 'block';
        }

        // Confirm logout function
        function confirmLogout() {
            // Clear user data and localStorage
            localStorage.removeItem('isLoggedIn');
            localStorage.removeItem('userName');
            localStorage.removeItem('userEmail');
            localStorage.removeItem('subscriptionPlan');
            localStorage.removeItem('hasActiveSubscription');
            
            // Update navigation
            updateNavigation();
            
            // Hide modal
            document.getElementById('logoutConfirmModal').style.display = 'none';
            
            // Redirect to home page
            window.location.href = 'index.html';
        }

        // Cancel logout function
        function cancelLogout() {
            document.getElementById('logoutConfirmModal').style.display = 'none';
        }

        // Subscription Required Modal functions
        function showSubscriptionRequiredModal() {
            document.getElementById('subscriptionRequiredModal').style.display = 'block';
        }

        function closeSubscriptionModal() {
            document.getElementById('subscriptionRequiredModal').style.display = 'none';
        }

        function goToSubscription() {
            window.location.href = 'subscription.html';
        }

        // Modal functions
        function showSignInModal() {
            document.getElementById('signInModal').style.display = 'block';
            document.getElementById('registerModal').style.display = 'none';
        }

        function showRegisterModal() {
            document.getElementById('registerModal').style.display = 'block';
            document.getElementById('signInModal').style.display = 'none';
        }

        function closeModal() {
            // Close static modals
            const signInModal = document.getElementById('signInModal');
            const registerModal = document.getElementById('registerModal');
            const logoutConfirmModal = document.getElementById('logoutConfirmModal');
            const subscriptionRequiredModal = document.getElementById('subscriptionRequiredModal');
            if (signInModal) signInModal.style.display = 'none';
            if (registerModal) registerModal.style.display = 'none';
            if (logoutConfirmModal) logoutConfirmModal.style.display = 'none';
            if (subscriptionRequiredModal) subscriptionRequiredModal.style.display = 'none';
            
            // Close dynamically created modals
            const dynamicModals = document.querySelectorAll('.modal');
            dynamicModals.forEach(modal => {
                if (modal.id !== 'signInModal' && modal.id !== 'registerModal') {
                    modal.remove();
                }
            });
        }

        // Sign in form handler
        function handleSignIn(event) {
            event.preventDefault();
            const email = document.getElementById('signInEmail').value;
            const password = document.getElementById('signInPassword').value;
            
            // Check if user exists in localStorage
            const storedEmail = localStorage.getItem('userEmail');
            const storedPassword = localStorage.getItem('userPassword');
            
            if (email === storedEmail && password === storedPassword) {
                localStorage.setItem('isLoggedIn', 'true');
                updateNavigation();
                closeModal();
                window.location.href = 'profile.html';
            }
        }

        // Register form handler
        function handleRegister(event) {
            event.preventDefault();
            const email = document.getElementById('registerEmail').value;
            const password = document.getElementById('registerPassword').value;
            const name = document.getElementById('registerName').value;
            
            // Check if email already exists
            const existingEmail = localStorage.getItem('userEmail');
            if (existingEmail === email) {
                showSignInModal();
                return;
            }
            
            // Create new account
            localStorage.setItem('isLoggedIn', 'true');
            localStorage.setItem('userEmail', email);
            localStorage.setItem('userName', name);
            localStorage.setItem('userPassword', password);
            updateNavigation();
            closeModal();
            window.location.href = 'profile.html';
        }

        // Google sign-in handler
        function signInWithGoogle() {
            // Simulate Google OAuth flow (replace with actual Google OAuth implementation)
            const mockGoogleUser = {
                email: 'user@gmail.com',
                name: 'Google User',
                id: 'google_' + Math.random().toString(36).substr(2, 9)
            };
            
            // Check if user exists in localStorage
            const storedEmail = localStorage.getItem('userEmail');
            const storedPassword = localStorage.getItem('userPassword');
            
            if (storedEmail === mockGoogleUser.email && storedPassword === mockGoogleUser.id) {
                // User exists, sign them in
                localStorage.setItem('isLoggedIn', 'true');
                updateNavigation();
                closeModal();
                window.location.href = 'profile.html';
            } else {
                // User doesn't exist, create account
                localStorage.setItem('isLoggedIn', 'true');
                localStorage.setItem('userEmail', mockGoogleUser.email);
                localStorage.setItem('userName', mockGoogleUser.name);
                localStorage.setItem('userPassword', mockGoogleUser.id);
                localStorage.setItem('authProvider', 'google');
                updateNavigation();
                closeModal();
                window.location.href = 'profile.html';
            }
        }

        // Google registration handler
        function registerWithGoogle() {
            // Simulate Google OAuth flow (replace with actual Google OAuth implementation)
            const mockGoogleUser = {
                email: 'user@gmail.com',
                name: 'Google User',
                id: 'google_' + Math.random().toString(36).substr(2, 9)
            };
            
            // Check if user already exists
            const existingEmail = localStorage.getItem('userEmail');
            if (existingEmail === mockGoogleUser.email) {
                showSignInModal();
                return;
            }
            
            // Create account with Google data
            localStorage.setItem('isLoggedIn', 'true');
            localStorage.setItem('userEmail', mockGoogleUser.email);
            localStorage.setItem('userName', mockGoogleUser.name);
            localStorage.setItem('userPassword', mockGoogleUser.id); // Use Google ID as password
            localStorage.setItem('authProvider', 'google');
            updateNavigation();
            closeModal();
            window.location.href = 'profile.html';
        }
        
        // Initialize tabs functionality
        function initializeTabs() {
            console.log('Initializing tabs...');
            const tabs = document.querySelectorAll('.games-tabs .tab');
            const panels = document.querySelectorAll('.tab-panel');
            
            console.log('Found tabs:', tabs.length);
            console.log('Found panels:', panels.length);
            
            tabs.forEach((tab, index) => {
                console.log(`Setting up tab ${index}:`, tab.textContent, tab.dataset.tab);
                tab.addEventListener('click', (e) => {
                    console.log('Tab clicked:', tab.textContent, tab.dataset.tab);
                    e.preventDefault();
                    
                    // Remove active class from all tabs and panels
                    tabs.forEach(t => t.classList.remove('active'));
                    panels.forEach(p => p.classList.remove('active'));
                    
                    // Add active class to clicked tab
                    tab.classList.add('active');
                    
                    // Show corresponding panel
                    const tabId = tab.dataset.tab;
                    const panel = document.getElementById(`${tabId}-panel`);
                    console.log('Looking for panel:', `${tabId}-panel`, panel);
                    if (panel) {
                        panel.classList.add('active');
                        console.log('Panel activated:', panel.id);
                    } else {
                        console.error('Panel not found:', `${tabId}-panel`);
                    }
                    
                    // Special handling for Weekly tab - load puzzle #2 directly
                    if (tabId === 'gm-games' && puzzlesData && puzzlesData.puzzles) {
                        const puzzle2 = puzzlesData.puzzles.find(p => p.id === 'puzzle-002');
                        if (puzzle2) {
                            console.log('Loading puzzle #2 for Weekly tab:', puzzle2);
                            displayGame(puzzle2.id);
                        } else {
                            console.error('Puzzle #2 not found');
                        }
                    } else {
                        // All other tabs use the same game functionality
                        // Games are loaded automatically by updateGameButtons()
                    }
                });
            });
        }

        // All tabs now use the same game functionality
        // The loadMyGamesContent and loadGMGamesContent functions are no longer needed
        // since all tabs display the same game categories

        // Initialize puzzles data on page load
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('DOM loaded, loading puzzles...');
            
            // Initialize tabs
            initializeTabs();
            
            try {
                puzzlesData = await PuzzleLoader.loadPuzzlesFromFiles();
                console.log('Loaded puzzles:', puzzlesData);
                console.log('Number of puzzles loaded:', puzzlesData ? puzzlesData.puzzles.length : 0);
                
                // Validate all puzzle data
                if (puzzlesData && puzzlesData.puzzles) {
                    console.log('🔍 Validating puzzle data...');
                    puzzlesData.puzzles.forEach(puzzle => {
                        const errors = validatePuzzleData(puzzle);
                        if (errors.length === 0) {
                            console.log('✅ Puzzle data valid:', puzzle.name);
                        } else {
                            console.error('❌ Puzzle data invalid:', puzzle.name, errors);
                        }
                    });
                    console.log('🔍 Puzzle validation complete');
                }
                
                // Categorize puzzles by difficulty
                const easyPuzzles = puzzlesData.puzzles.filter(puzzle => puzzle.difficulty === 'easy');
                const intermediatePuzzles = puzzlesData.puzzles.filter(puzzle => puzzle.difficulty === 'intermediate');
                const advancedPuzzles = puzzlesData.puzzles.filter(puzzle => puzzle.difficulty === 'advanced');
                const epicPuzzles = puzzlesData.puzzles.filter(puzzle => puzzle.difficulty === 'epic');
                
                console.log('Easy puzzles:', easyPuzzles.length);
                console.log('Intermediate puzzles:', intermediatePuzzles.length);
                console.log('Advanced puzzles:', advancedPuzzles.length);
                console.log('Epic puzzles:', epicPuzzles.length);
                
                // Update all tabs with the same puzzle data
                const tabPrefixes = ['', 'gm-games-'];
                
                tabPrefixes.forEach(prefix => {
                    // Update easy puzzles (short-games-submenu maps to easy)
                    updateGameCategory(prefix + 'short-games-submenu', easyPuzzles);
                    // Update intermediate puzzles (medium-games-submenu maps to intermediate)
                    updateGameCategory(prefix + 'medium-games-submenu', intermediatePuzzles);
                    // Update advanced puzzles (long-games-submenu maps to advanced)
                    updateGameCategory(prefix + 'long-games-submenu', advancedPuzzles);
                    // Update epic puzzles (epic-games-submenu maps to epic)
                    updateGameCategory(prefix + 'epic-games-submenu', epicPuzzles);
                });
            } catch (error) {
                console.error('Error loading puzzles:', error);
                puzzlesData = { puzzles: [] };
            }
            
            // Load completed challenges from progress tracker
            completedChallenges = loadCompletedChallenges();
            console.log('Loaded completed challenges:', completedChallenges);
            
            // Update the game buttons display
            updateGameButtons();
            updateNavigation();
            
            // Update completion badges after games are loaded
            updateGameListBadges();
            
            // Set up training timer click detection
            setupTrainingTimer();
            
            // Add event listeners for forms
            document.getElementById('signInForm').addEventListener('submit', handleSignIn);
            document.getElementById('registerForm').addEventListener('submit', handleRegister);
            
            // Add event listeners for close buttons
            document.querySelectorAll('.close').forEach(closeBtn => {
                closeBtn.addEventListener('click', closeModal);
            });
            
            // Close modal when clicking outside
            window.addEventListener('click', function(event) {
                const signInModal = document.getElementById('signInModal');
                const registerModal = document.getElementById('registerModal');
                const logoutConfirmModal = document.getElementById('logoutConfirmModal');
                const subscriptionRequiredModal = document.getElementById('subscriptionRequiredModal');
                if (event.target === signInModal) {
                    closeModal();
                }
                if (event.target === registerModal) {
                    closeModal();
                }
                if (event.target === logoutConfirmModal) {
                    closeModal();
                }
                if (event.target === subscriptionRequiredModal) {
                    closeModal();
                }
            });
        });
        
        // Set up training timer for piece movements
        function setupTrainingTimer() {
            // Training timer will be started when pieces are moved
            // (handled in movePiece and movePieceDirectly functions)
            
            // Reset idle timer on any user activity
            document.addEventListener('mousemove', function() {
                if (progressTracker.trainingTimer.isRunning) {
                    progressTracker.resetTrainingIdleTimer();
                }
            });
            
            document.addEventListener('keydown', function() {
                if (progressTracker.trainingTimer.isRunning) {
                    progressTracker.resetTrainingIdleTimer();
                }
            });
            
            // Stop training timer when leaving the page
            window.addEventListener('beforeunload', function() {
                progressTracker.stopTrainingTimer();
            });
        }

        // Function to reload games data
        async function reloadGamesData() {
            try {
                console.log('🔄 Reloading games data...');
                gamesData = await GameLoader.loadGamesFromFiles();
                console.log('📊 Reloaded games:', gamesData);
                console.log('📊 Total games loaded:', gamesData ? gamesData.games.length : 0);
                console.log('📊 Custom games:', gamesData ? gamesData.games.filter(g => g.id.startsWith('custom-game-')).length : 0);
                updateGameButtons();
                console.log('✅ Game buttons updated');
            } catch (error) {
                console.error('❌ Error reloading games:', error);
            }
        }
        
        // Function to clear the chess board - remove all pieces
        function clearChessBoard() {
            console.log('Clearing chess board...');
            
            // Clear all squares on the board
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.querySelector(`[data-square="${String.fromCharCode(97 + j)}${8 - i}"]`);
                    if (square) {
                        square.innerHTML = '';
                    }
                }
            }
            
            // Clear any selection or highlights on the board
            document.querySelectorAll('.selected').forEach(element => {
                element.classList.remove('selected');
            });
            document.querySelectorAll('.valid-move').forEach(element => {
                element.classList.remove('valid-move');
            });
            document.querySelectorAll('.last-move').forEach(element => {
                element.classList.remove('last-move');
            });
            
            console.log('Chess board cleared');
        }

        // Function to clear only custom game elements (not the entire right section)
        function clearCustomGameElements() {
            console.log('Clearing custom game elements...');
            
            // Hide custom game info section
            const customGameInfo = document.getElementById('custom-game-info');
            if (customGameInfo) {
                customGameInfo.style.display = 'none';
            }
            
            // Hide custom commentary section
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            
            // Hide custom save button and message
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }
            
            // Clear the chess board - remove all pieces
            clearChessBoard();
            
            console.log('Custom game elements cleared');
        }

        // Function to clear the right section (moves section)
        function clearRightSection() {
            console.log('Clearing right section...');
            
            // Clear the moves list
            const movesList = document.getElementById('moves-list');
            if (movesList) {
                movesList.innerHTML = '';
                movesList.style.display = 'none';
            }
            
            // Hide game info sections
            const gameDetails = document.getElementById('game-details');
            if (gameDetails) {
                gameDetails.style.display = 'none';
            }
            
            // Hide custom game info section
            const customGameInfo = document.getElementById('custom-game-info');
            if (customGameInfo) {
                customGameInfo.style.display = 'none';
            }
            
            
            // Hide delete game section
            const deleteGameSection = document.getElementById('delete-game-section');
            if (deleteGameSection) {
                deleteGameSection.style.display = 'none';
            }
            
            // Hide custom commentary section
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            
            // Hide custom save button and message
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }
            
            // Reset move buttons
            const btnInitial = document.getElementById('btn-initial');
            const btnBack = document.getElementById('btn-back');
            const btnForward = document.getElementById('btn-forward');
            const btnFinal = document.getElementById('btn-final');
            
            if (btnInitial) btnInitial.classList.add('disabled');
            if (btnBack) btnBack.classList.add('disabled');
            if (btnForward) btnForward.classList.add('disabled');
            if (btnFinal) btnFinal.classList.add('disabled');
            
            // Clear any highlights
            document.querySelectorAll('.clickable-move').forEach(span => {
                span.classList.remove('active-move');
            });
            document.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                section.classList.remove('clicked');
            });
            
            // Clear the chess board - remove all pieces
            clearChessBoard();
            
            console.log('Right section cleared');
        }

        // Function to delete a custom game
        async function deleteCustomGame(event, gameId) {
            event.stopPropagation(); // Prevent the game from being selected
            
            try {
                console.log('🗑️ Deleting custom game:', gameId);
                    const isProduction = !window.location.hostname.includes('localhost') && !window.location.hostname.includes('127.0.0.1');
                const apiUrl = isProduction ? `/api/delete-game?id=${gameId}` : `http://localhost:3001/delete-game/${gameId}`;
                const response = await fetch(apiUrl, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const result = await response.json();
                console.log('📡 Delete response:', result);
                
                if (result.success) {
                    console.log('✅ Game deleted successfully from server');
                    
                    // Clear the right section (moves section) after successful deletion
                    clearRightSection();
                    
                    console.log('🔄 Reloading games data...');
                    // Reload the games data to update the display
                    await reloadGamesData();
                    console.log('✅ Games data reloaded');
                } else {
                    console.error('❌ Failed to delete game:', result.message);
                }
            } catch (error) {
                console.error('❌ Error deleting game:', error);
            }
        }


        // Make functions globally accessible
        window.reloadGamesData = reloadGamesData;
        window.updateGameButtons = updateGameButtons;
        window.deleteCustomGame = deleteCustomGame;

        // Function to update game buttons display
        function updateGameButtons() {
            console.log('=== UPDATEGAMEBUTTONS CALLED ===');
            console.log('Updating puzzle buttons...');
            if (!puzzlesData || !puzzlesData.puzzles) {
                console.log('No puzzles data available');
                return;
            }
            
            // Group puzzles by difficulty
            const easyPuzzles = puzzlesData.puzzles.filter(p => p.difficulty === 'easy');
            const intermediatePuzzles = puzzlesData.puzzles.filter(p => p.difficulty === 'intermediate');
            const advancedPuzzles = puzzlesData.puzzles.filter(p => p.difficulty === 'advanced');
            const epicPuzzles = puzzlesData.puzzles.filter(p => p.difficulty === 'epic');
            console.log('=== PUZZLE CATEGORIZATION DEBUG ===');
            console.log('Total puzzles loaded:', puzzlesData.puzzles.length);
            console.log('Easy puzzles:', easyPuzzles.length, easyPuzzles.map(p => ({ name: p.name, difficulty: p.difficulty })));
            console.log('Intermediate puzzles:', intermediatePuzzles.length, intermediatePuzzles.map(p => ({ name: p.name, difficulty: p.difficulty })));
            console.log('Advanced puzzles:', advancedPuzzles.length, advancedPuzzles.map(p => ({ name: p.name, difficulty: p.difficulty })));
            console.log('Epic puzzles:', epicPuzzles.length, epicPuzzles.map(p => ({ name: p.name, difficulty: p.difficulty })));
            console.log('All puzzle IDs:', puzzlesData.puzzles.map(p => p.id));
            
            // Update all tabs with the same puzzle data
            const tabPrefixes = ['', 'gm-games-'];
            
            tabPrefixes.forEach(prefix => {
                // Update easy puzzles (short-games-submenu maps to easy)
                updateGameCategory(prefix + 'short-games-submenu', easyPuzzles);
                // Update intermediate puzzles (medium-games-submenu maps to intermediate)
                updateGameCategory(prefix + 'medium-games-submenu', intermediatePuzzles);
                // Update advanced puzzles (long-games-submenu maps to advanced)
                updateGameCategory(prefix + 'long-games-submenu', advancedPuzzles);
                // Update epic puzzles (epic-games-submenu maps to epic)
                updateGameCategory(prefix + 'epic-games-submenu', epicPuzzles);
            });
        }
        
        function updateGameCategory(categoryId, puzzles) {
            console.log(`=== UPDATEGAMECATEGORY CALLED ===`);
            console.log(`Updating category ${categoryId} with ${puzzles.length} puzzles`);
            console.log(`Puzzles for ${categoryId}:`, puzzles.map(p => ({ id: p.id, name: p.name })));
            const categoryElement = document.getElementById(categoryId);
            if (!categoryElement) {
                console.error(`Category element not found: ${categoryId}`);
                return;
            }
            
            console.log(`Clearing content for category: ${categoryId}`);
            // Clear existing content
            categoryElement.innerHTML = '';
            
            puzzles.forEach(puzzle => {
                const puzzleButton = document.createElement('a');
                puzzleButton.href = '#';
                puzzleButton.className = 'submenu-button';
                puzzleButton.setAttribute('data-game-id', puzzle.id);
                
                // Check if user has active subscription
                const hasActiveSubscription = localStorage.getItem('hasActiveSubscription') === 'true';
                const isPuzzleLocked = puzzle.locked && !hasActiveSubscription;
                
                // Add locked class if puzzle is locked and user doesn't have subscription
                if (isPuzzleLocked) {
                    puzzleButton.classList.add('locked');
                }
                
                puzzleButton.onclick = (e) => {
                    e.preventDefault();
                    console.log('Puzzle button clicked:', puzzle.id, puzzle.name);
                    if (isPuzzleLocked) {
                        // Show subscription required modal
                        showSubscriptionRequiredModal();
                        return;
                    }
                    console.log('Calling displayGame for puzzle:', puzzle.id);
                    displayGame(puzzle.id);
                };
                
                let buttonContent = `
                    <span>${puzzle.name}</span>
                    <span class="game-completion-badge" data-game="${puzzle.id}"><img src="images/checklist.png" alt="Complete" style="width: 20px; height: 20px;"></span>
                `;
                
                // Add lock overlay if puzzle is locked and user doesn't have subscription
                if (isPuzzleLocked) {
                    buttonContent += `
                        <div class="lock-overlay">
                            <div class="lock-icon">🔒</div>
                        </div>
                    `;
                }
                
                puzzleButton.innerHTML = buttonContent;
                
                categoryElement.appendChild(puzzleButton);
            });
            
            // No custom game functionality in puzzles
        }
        
        // Function to reset the board to starting position
        function resetBoard() {
            // Clear all squares
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.querySelector(`[data-square="${String.fromCharCode(97 + j)}${8 - i}"]`);
                    if (square) {
                        square.innerHTML = '';
                    }
                }
            }
            
            // Reset piece positions in parser
            moveParser.resetBoard();
            
            // Set up starting position
            setupStartingPosition();
        }
        
        function setupStartingPosition() {
            // White pieces
            const whitePieces = {
                'a1': 'Chess_rlt45.svg.png', 'b1': 'Chess_nlt45.svg.png', 'c1': 'Chess_blt45.svg.png', 'd1': 'Chess_qlt45.svg.png',
                'e1': 'Chess_klt45.svg.png', 'f1': 'Chess_blt45.svg.png', 'g1': 'Chess_nlt45.svg.png', 'h1': 'Chess_rlt45.svg.png',
                'a2': 'Chess_plt45.svg.png', 'b2': 'Chess_plt45.svg.png', 'c2': 'Chess_plt45.svg.png', 'd2': 'Chess_plt45.svg.png',
                'e2': 'Chess_plt45.svg.png', 'f2': 'Chess_plt45.svg.png', 'g2': 'Chess_plt45.svg.png', 'h2': 'Chess_plt45.svg.png'
            };
            
            // Black pieces
            const blackPieces = {
                'a8': 'Chess_rdt45.svg.png', 'b8': 'Chess_ndt45.svg.png', 'c8': 'Chess_bdt45.svg.png', 'd8': 'Chess_qdt45.svg.png',
                'e8': 'Chess_kdt45.svg.png', 'f8': 'Chess_bdt45.svg.png', 'g8': 'Chess_ndt45.svg.png', 'h8': 'Chess_rdt45.svg.png',
                'a7': 'Chess_pdt45.svg.png', 'b7': 'Chess_pdt45.svg.png', 'c7': 'Chess_pdt45.svg.png', 'd7': 'Chess_pdt45.svg.png',
                'e7': 'Chess_pdt45.svg.png', 'f7': 'Chess_pdt45.svg.png', 'g7': 'Chess_pdt45.svg.png', 'h7': 'Chess_pdt45.svg.png'
            };
            
            // Place white pieces
            Object.entries(whitePieces).forEach(([square, piece]) => {
                const squareElement = document.querySelector(`[data-square="${square}"]`);
                if (squareElement) {
                    const pieceElement = createDraggablePiece(piece, square);
                    squareElement.appendChild(pieceElement);
                }
            });
            
            // Place black pieces
            Object.entries(blackPieces).forEach(([square, piece]) => {
                const squareElement = document.querySelector(`[data-square="${square}"]`);
                if (squareElement) {
                    const pieceElement = createDraggablePiece(piece, square);
                    squareElement.appendChild(pieceElement);
                }
            });
        }
        

        // Initialize chess board
        function generateCoordinateLabels() {
            const bottomLabels = document.getElementById('coordinate-labels-bottom');
            const rightLabels = document.getElementById('coordinate-labels-right');
            
            // Clear existing labels
            bottomLabels.innerHTML = '';
            rightLabels.innerHTML = '';
            
            // Generate letter labels (a-h) for bottom
            const letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            
            for (let i = 0; i < 8; i++) {
                const bottomLabel = document.createElement('div');
                const displayLetter = boardFlipped ? letters[7 - i] : letters[i];
                
                bottomLabel.className = 'coordinate-label letter';
                bottomLabel.textContent = displayLetter;
                
                bottomLabels.appendChild(bottomLabel);
            }
            
            // Generate number labels (1-8) for right
            const numbers = ['8', '7', '6', '5', '4', '3', '2', '1'];
            
            for (let i = 0; i < 8; i++) {
                const rightLabel = document.createElement('div');
                const displayNumber = boardFlipped ? numbers[7 - i] : numbers[i];
                
                rightLabel.className = 'coordinate-label number';
                rightLabel.textContent = displayNumber;
                
                rightLabels.appendChild(rightLabel);
            }
        }

        function initializeChessBoard() {
            const board = document.getElementById('chess-board');
            board.innerHTML = '';
            
            // Create 64 squares (8x8)
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    
                    // Calculate square color based on actual chess position
                    let actualRow, actualCol;
                    if (boardFlipped) {
                        // When flipped, we want to show the board from black's perspective
                        actualRow = 7 - row;  // Flip rows
                        actualCol = 7 - col;  // Flip columns
                    } else {
                        actualRow = row;
                        actualCol = col;
                    }
                    
                    const isLight = (actualRow + actualCol) % 2 === 0;
                    square.className = `chess-square ${isLight ? 'light' : 'dark'}`;
                    
                    // Convert row/col to chess notation (a1, b1, etc.)
                    // When flipped, reverse the row and column order
                    let file, rank;
                    if (boardFlipped) {
                        file = String.fromCharCode(97 + (7 - col)); // h, g, f, etc. when flipped
                        rank = row + 1; // 1, 2, 3, etc. when flipped
                    } else {
                        file = String.fromCharCode(97 + col); // a, b, c, etc.
                        rank = 8 - row; // 8, 7, 6, etc.
                    }
                    square.dataset.square = file + rank;
                    
                    // Add drop event listeners
                    square.addEventListener('dragover', handleDragOver);
                    square.addEventListener('drop', handleDrop);
                    
                    // Add click event listener
                    square.addEventListener('click', handleSquareClick);
                    
                    board.appendChild(square);
                }
            }
        }

        // Set up initial board position
        function setupInitialPosition() {
            console.log('DEBUG: setupInitialPosition called');
            const board = document.getElementById('chess-board');
            const squares = board.querySelectorAll('.chess-square');
            
            // Clear all pieces
            squares.forEach(square => {
                square.innerHTML = '';
            });

            // Only set up pieces if a game/puzzle is selected
            if (currentGame) {
                let initialPosition;
                
                // Check if the game/puzzle has a FEN position (for puzzles)
                if (currentGame.fen) {
                    console.log('DEBUG: Using FEN for initial position:', currentGame.fen);
                    initialPosition = parseFENToPosition(currentGame.fen);
                } else if (currentGame.initial_position) {
                    console.log('DEBUG: Using initial_position');
                    // Use custom initial position (for games)
                    initialPosition = currentGame.initial_position;
                } else {
                    // Use standard starting position
                    initialPosition = {
                        // Black pieces
                        'a8': 'Chess_rdt45.svg.png', 'b8': 'Chess_ndt45.svg.png', 'c8': 'Chess_bdt45.svg.png', 'd8': 'Chess_qdt45.svg.png',
                        'e8': 'Chess_kdt45.svg.png', 'f8': 'Chess_bdt45.svg.png', 'g8': 'Chess_ndt45.svg.png', 'h8': 'Chess_rdt45.svg.png',
                        'a7': 'Chess_pdt45.svg.png', 'b7': 'Chess_pdt45.svg.png', 'c7': 'Chess_pdt45.svg.png', 'd7': 'Chess_pdt45.svg.png',
                        'e7': 'Chess_pdt45.svg.png', 'f7': 'Chess_pdt45.svg.png', 'g7': 'Chess_pdt45.svg.png', 'h7': 'Chess_pdt45.svg.png',
                        
                        // White pieces
                        'a1': 'Chess_rlt45.svg.png', 'b1': 'Chess_nlt45.svg.png', 'c1': 'Chess_blt45.svg.png', 'd1': 'Chess_qlt45.svg.png',
                        'e1': 'Chess_klt45.svg.png', 'f1': 'Chess_blt45.svg.png', 'g1': 'Chess_nlt45.svg.png', 'h1': 'Chess_rlt45.svg.png',
                        'a2': 'Chess_plt45.svg.png', 'b2': 'Chess_plt45.svg.png', 'c2': 'Chess_plt45.svg.png', 'd2': 'Chess_plt45.svg.png',
                        'e2': 'Chess_plt45.svg.png', 'f2': 'Chess_plt45.svg.png', 'g2': 'Chess_plt45.svg.png', 'h2': 'Chess_plt45.svg.png'
                    };
                }

                // Place pieces on their corresponding squares
                console.log('DEBUG: Initial position pieces:', Object.entries(initialPosition).filter(([_, img]) => img));
                Object.entries(initialPosition).forEach(([squareNotation, pieceImage]) => {
                    if (pieceImage && pieceImage !== '') { // Only place pieces if there's an image and it's not empty
                        console.log('DEBUG: Placing piece', pieceImage, 'on', squareNotation);
                        const square = board.querySelector(`[data-square="${squareNotation}"]`);
                        if (square) {
                            const pieceElement = createDraggablePiece(pieceImage, squareNotation);
                            square.appendChild(pieceElement);
                        }
                    }
                });
            }
        }

        // Validate puzzle data structure
        function validatePuzzleData(puzzle) {
            const errors = [];
            const warnings = [];
            
            if (!puzzle.moves_detailed || !Array.isArray(puzzle.moves_detailed)) {
                errors.push('Missing or invalid moves_detailed array');
                return errors;
            }
            
            puzzle.moves_detailed.forEach((move, index) => {
                if (move.white && (!move.white_from || !move.white_to)) {
                    warnings.push(`Move ${index + 1} (white): Missing coordinate data - will use parser fallback`);
                }
                if (move.black && (!move.black_from || !move.black_to)) {
                    warnings.push(`Move ${index + 1} (black): Missing coordinate data - will use parser fallback`);
                }
            });
            
            if (errors.length > 0) {
                console.error('❌ PUZZLE VALIDATION ERRORS:', {
                    puzzleId: puzzle.id,
                    puzzleName: puzzle.name,
                    errors
                });
            }
            
            if (warnings.length > 0) {
                console.warn('⚠️ PUZZLE VALIDATION WARNINGS:', {
                    puzzleId: puzzle.id,
                    puzzleName: puzzle.name,
                    warnings
                });
            }
            
            return errors;
        }

        // Parse puzzle move using the robust game parser approach
        function parsePuzzleMove(move, moveNotation, isWhiteMove) {
            console.log('Parsing puzzle move:', move, 'notation:', moveNotation);
            
            // First, try to use the solid game parser logic
            const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
            
            // For puzzles, we can enhance the parsing with provided coordinates if available
            // but only as a validation/fallback, not as the primary method
            const fromSquare = isWhiteMove ? move.white_from : move.black_from;
            const toSquare = isWhiteMove ? move.white_to : move.black_to;
            
            if (fromSquare && toSquare) {
                // Validate that the parsed move matches the provided coordinates
                if (parsedMove.source !== fromSquare || parsedMove.target !== toSquare) {
                    console.warn('⚠️ Coordinate mismatch detected:', {
                        parsed: { source: parsedMove.source, target: parsedMove.target },
                        provided: { source: fromSquare, target: toSquare },
                        notation: moveNotation
                    });
                    
                    // Use provided coordinates as fallback if parsing seems wrong
                    parsedMove.source = fromSquare;
                    parsedMove.target = toSquare;
                    console.log('Using provided coordinates as fallback');
                } else {
                    console.log('✅ Parsed coordinates match provided coordinates');
                }
            } else {
                console.warn('⚠️ No coordinate data provided for puzzle move, relying on parser');
            }
            
            // Add puzzle-specific properties
            parsedMove.isEnPassant = moveNotation.includes('e.p.') || moveNotation.includes('ep');
            parsedMove.isCheck = moveNotation.includes('+');
            parsedMove.isCheckmate = moveNotation.includes('#');
            parsedMove.promotion = moveNotation.includes('=') ? moveNotation.split('=')[1] : null;
            
            console.log('Final parsed puzzle move:', parsedMove);
            return parsedMove;
        }

        // Display puzzle position information
        function displayPuzzlePositionInfo(puzzle) {
            const puzzlePositionInfo = document.getElementById('puzzle-position-info');
            const puzzlePiecesInfo = document.getElementById('puzzle-pieces-info');
            const puzzleTurnInfo = document.getElementById('puzzle-turn-info');
            
            if (!puzzlePositionInfo || !puzzlePiecesInfo || !puzzleTurnInfo) {
                console.warn('Puzzle position info elements not found');
                return;
            }
            
            if (puzzle.fen) {
                // Parse FEN to get position and turn info
                const position = parseFENToPosition(puzzle.fen);
                // Use puzzle.turn if available, otherwise parse from FEN
                const turn = puzzle.turn === 'black' ? 'b' : (puzzle.turn === 'white' ? 'w' : puzzle.fen.split(' ')[1]);
                
                // Get piece positions
                const pieces = [];
                Object.entries(position).forEach(([square, pieceImage]) => {
                    if (pieceImage && pieceImage !== '') {
                        const pieceName = getPieceNameFromImage(pieceImage);
                        pieces.push(`${pieceName}: ${square}`);
                    }
                });
                
                // Separate black and white pieces
                const blackPieces = pieces.filter(piece => piece.includes('Black'));
                const whitePieces = pieces.filter(piece => piece.includes('White'));
                
                // Display pieces info
                puzzlePiecesInfo.innerHTML = `
                    <div style="font-size: 16px; margin-bottom: 4px;"><strong>Black:</strong> ${blackPieces.join(', ')}</div>
                    <div style="font-size: 16px;"><strong>White:</strong> ${whitePieces.join(', ')}</div>
                `;
                
                // Display turn info with piece image
                const turnImage = turn === 'w' ? 'pieces/Chess_klt45.svg.png' : 'pieces/Chess_kdt45.svg.png';
                const turnText = turn === 'w' ? 'to move' : 'to move';
                puzzleTurnInfo.innerHTML = `
                    <img src="${turnImage}" alt="${turn === 'w' ? 'White King' : 'Black King'}" style="width: 26px; height: 26px; vertical-align: middle; margin-right: 0px; margin-top: -2px;">
                    <span>${turnText}</span>
                `;
                
                // Show the puzzle position info
                puzzlePositionInfo.style.display = 'block';
            } else {
                // Hide if no FEN available
                puzzlePositionInfo.style.display = 'none';
            }
        }
        
        // Get piece name from image filename
        function getPieceNameFromImage(imageName) {
            const pieceMap = {
                'Chess_klt45.svg.png': 'White King', 'Chess_qlt45.svg.png': 'White Queen', 'Chess_rlt45.svg.png': 'White Rook',
                'Chess_blt45.svg.png': 'White Bishop', 'Chess_nlt45.svg.png': 'White Knight', 'Chess_plt45.svg.png': 'White Pawn',
                'Chess_kdt45.svg.png': 'Black King', 'Chess_qdt45.svg.png': 'Black Queen', 'Chess_rdt45.svg.png': 'Black Rook',
                'Chess_bdt45.svg.png': 'Black Bishop', 'Chess_ndt45.svg.png': 'Black Knight', 'Chess_pdt45.svg.png': 'Black Pawn'
            };
            return pieceMap[imageName] || 'Unknown Piece';
        }

        // Parse FEN notation to position object
        function parseFENToPosition(fen) {
            const position = {};
            const parts = fen.split(' ');
            const boardPart = parts[0];
            const rows = boardPart.split('/');
            
            // Map FEN piece letters to image filenames
            const pieceMap = {
                'K': 'Chess_klt45.svg.png', 'Q': 'Chess_qlt45.svg.png', 'R': 'Chess_rlt45.svg.png',
                'B': 'Chess_blt45.svg.png', 'N': 'Chess_nlt45.svg.png', 'P': 'Chess_plt45.svg.png',
                'k': 'Chess_kdt45.svg.png', 'q': 'Chess_qdt45.svg.png', 'r': 'Chess_rdt45.svg.png',
                'b': 'Chess_bdt45.svg.png', 'n': 'Chess_ndt45.svg.png', 'p': 'Chess_pdt45.svg.png'
            };
            
            // Process each row
            for (let row = 0; row < 8; row++) {
                const rowData = rows[row];
                let col = 0;
                
                for (let i = 0; i < rowData.length; i++) {
                    const char = rowData[i];
                    
                    if (char >= '1' && char <= '8') {
                        // Empty squares - skip
                        col += parseInt(char);
                    } else if (pieceMap[char]) {
                        // Piece found
                        const square = String.fromCharCode(97 + col) + (8 - row);
                        position[square] = pieceMap[char];
                        col++;
                    }
                }
            }
            
            return position;
        }

        // Helper function to get square notation from index
        function getSquareNotation(index) {
            const row = Math.floor(index / 8);
            const col = index % 8;
            
            // When flipped, we need to calculate notation differently
            if (boardFlipped) {
                const file = String.fromCharCode(97 + (7 - col));
                const rank = row + 1;
                return file + rank;
            } else {
                return String.fromCharCode(97 + col) + (8 - row);
            }
        }

        // Create a draggable piece element
        function createDraggablePiece(pieceImage, squareNotation) {
            const pieceElement = document.createElement('div');
            pieceElement.className = 'chess-piece';
            pieceElement.style.backgroundImage = `url('pieces/${pieceImage}')`;
            pieceElement.draggable = true;
            pieceElement.dataset.piece = pieceImage;
            pieceElement.dataset.square = squareNotation;
            
            // Add drag event listeners
            pieceElement.addEventListener('dragstart', handleDragStart);
            pieceElement.addEventListener('dragend', handleDragEnd);
            
            // Add click event listener
            pieceElement.addEventListener('click', handlePieceClick);
            
            // Apply current visual mode to the new piece
            applyVisualModeToPiece(pieceElement, currentVisualMode);
            
            // Make invisible if in challenge mode
            if (isChallengeMode) {
                pieceElement.style.opacity = '0';
            }
            
            return pieceElement;
        }

        // Update piece square notation when moved
        function updatePieceSquare(pieceElement, newSquare) {
            pieceElement.dataset.square = newSquare;
        }

        // Re-initialize drag and drop for all pieces on the board
        function reinitializeDragAndDrop() {
            const pieces = document.querySelectorAll('.chess-piece');
            pieces.forEach((piece, index) => {
                // Remove existing event listeners
                piece.removeEventListener('dragstart', handleDragStart);
                piece.removeEventListener('dragend', handleDragEnd);
                piece.removeEventListener('click', handlePieceClick);
                
                // Re-add event listeners
                piece.addEventListener('dragstart', handleDragStart);
                piece.addEventListener('dragend', handleDragEnd);
                piece.addEventListener('click', handlePieceClick);
                
                // Ensure piece is draggable
                piece.draggable = true;
                
                // Apply current visual mode to ensure consistency
                applyVisualModeToPiece(piece, currentVisualMode);
            });
            
            // Also re-setup drop event listeners for squares
            const squares = document.querySelectorAll('.chess-square');
            squares.forEach(square => {
                // Remove existing event listeners
                square.removeEventListener('dragover', handleDragOver);
                square.removeEventListener('drop', handleDrop);
                square.removeEventListener('click', handleSquareClick);
                
                // Re-add event listeners
                square.addEventListener('dragover', handleDragOver);
                square.addEventListener('drop', handleDrop);
                square.addEventListener('click', handleSquareClick);
            });
        }

        // Handle drag start
        function handleDragStart(e) {
            console.log('Target:', e.target);
            console.log('Custom game mode:', typeof customGameMode !== 'undefined' ? customGameMode : 'undefined');
            console.log('Window custom game mode:', typeof window.customGameMode !== 'undefined' ? window.customGameMode : 'undefined');
            
            draggedPiece = e.target;
            draggedFromSquare = e.target.dataset.square;
            
            // Add dragging class to disable transitions on piece and board
            e.target.classList.add('dragging');
            const board = document.getElementById('chess-board');
            board.classList.add('dragging');
            console.log('Added dragging class to piece, classes now:', e.target.classList.toString());
            console.log('Added dragging class to board, classes now:', board.classList.toString());
            
            // Highlight valid moves
            highlightValidMoves();
            
            // Create a custom drag image with consistent size
            const dragImage = e.target.cloneNode(true);
            dragImage.style.width = '60px';
            dragImage.style.height = '60px';
            dragImage.style.position = 'absolute';
            dragImage.style.top = '-1000px';
            dragImage.style.left = '-1000px';
            
            // Apply current visual mode to drag image
            if (currentVisualMode === 'empty' || isChallengeMode) {
                dragImage.style.opacity = '0'; // Keep invisible in empty mode or challenge mode
            } else {
                dragImage.style.opacity = '1';
            }
            
            document.body.appendChild(dragImage);
            
            e.dataTransfer.setDragImage(dragImage, 30, 30);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
            
            // Clean up the drag image after a short delay
            setTimeout(() => {
                if (dragImage.parentNode) {
                    dragImage.parentNode.removeChild(dragImage);
                }
            }, 0);
            
            // Keep original piece invisible in empty mode or challenge mode, otherwise semi-transparent
            if (currentVisualMode === 'empty' || isChallengeMode) {
                e.target.style.opacity = '0';
            } else {
                e.target.style.opacity = '0.5';
            }
        }

        // Handle drag end
        function handleDragEnd(e) {
            console.log('Target:', e.target);
            console.log('Target current square:', e.target.dataset.square);
            console.log('Dragged from square:', draggedFromSquare);
            console.log('Custom game mode:', typeof customGameMode !== 'undefined' ? customGameMode : 'undefined');
            console.log('Window custom game mode:', typeof window.customGameMode !== 'undefined' ? window.customGameMode : 'undefined');
            console.log('Valid moves at drag end:', validMoves);
            
            // Check if the piece is still in the same position (hasn't been moved)
            const isStillInOriginalPosition = e.target.dataset.square === draggedFromSquare;
            console.log('Piece still in original position:', isStillInOriginalPosition);
            
            // Check if a move was actually completed by looking for a piece at the destination
            let moveWasCompleted = false;
            if (draggedFromSquare && validMoves.length > 0) {
                // Check if any of the valid move squares now have a piece
                validMoves.forEach(squareNotation => {
                    const square = getSquareByNotation(squareNotation);
                    if (square && square.querySelector('.chess-piece')) {
                        moveWasCompleted = true;
                        console.log('Move was completed - found piece at', squareNotation);
                    }
                });
            }
            console.log('Move was completed:', moveWasCompleted);
            
            // Remove dragging class to re-enable transitions
            e.target.classList.remove('dragging');
            const board = document.getElementById('chess-board');
            board.classList.remove('dragging');
            console.log('Removed dragging class from piece, classes now:', e.target.classList.toString());
            console.log('Removed dragging class from board, classes now:', board.classList.toString());
            
            // Clear highlights
            clearHighlights();
            
            // Only restore opacity if the piece is still in its original position AND no move was completed
            // If it was moved, the new piece already has the correct opacity
            if (isStillInOriginalPosition && !moveWasCompleted) {
                console.log('Restoring opacity for unmoved piece');
                // Restore piece opacity based on current visual mode or challenge mode
                if (currentVisualMode === 'empty' || isChallengeMode) {
                    e.target.style.opacity = '0';
                } else {
                    e.target.style.opacity = '1';
                }
            } else if (moveWasCompleted) {
                console.log('Move was completed - not restoring opacity for original piece');
                // Hide the original piece since it was moved
                e.target.style.opacity = '0';
                
            } else {
                console.log('Piece was moved, skipping opacity restoration');
            }
            
            // Reset drag variables
            draggedPiece = null;
            draggedFromSquare = null;
        }

        // Handle piece click (for click-to-select)
        function handlePieceClick(e) {
            e.stopPropagation(); // Prevent square click from firing
            
            const piece = e.target;
            const square = piece.parentElement;
            const squareNotation = getSquareNotationFromElement(square);
            
            console.log('Piece clicked on square:', squareNotation);
            
            // Clear previous selection
            clearSelection();
            
            // Select this piece
            selectedPiece = piece;
            selectedSquare = squareNotation;
            
            // Calculate valid moves for this piece
            draggedPiece = piece; // Temporarily set for move calculation
            draggedFromSquare = squareNotation;
            calculateValidMoves();
            
            // Show selection highlight (only in normal mode)
            if (!isChallengeMode) {
                console.log('Adding selected class to square:', square);
                square.classList.add('selected');
                console.log('Square classes after adding selected:', square.className);
                
                // Show valid move highlights too
                validMoves.forEach(moveSquare => {
                    const validSquare = getSquareByNotation(moveSquare);
                    if (validSquare) {
                        validSquare.classList.add('valid-move');
                    }
                });
            }
            
            console.log('Piece selected. Valid moves:', validMoves);
        }

        // Handle square click (for click-to-move)
        function handleSquareClick(e) {
            const clickedSquare = e.target;
            const clickedSquareNotation = getSquareNotationFromElement(clickedSquare);
            
            console.log('Square clicked:', clickedSquareNotation);
            const pieceOnSquare = clickedSquare.querySelector('.chess-piece');
            console.log('Square has piece:', pieceOnSquare !== null);
            
            // If there's a piece on this square and no piece is currently selected, select this piece
            if (pieceOnSquare && (!selectedPiece || !selectedSquare)) {
                console.log('Selecting piece on clicked square');
                handlePieceClick({ target: pieceOnSquare, stopPropagation: () => {} });
                return;
            }
            
            // If no piece is selected, do nothing
            if (!selectedPiece || !selectedSquare) {
                console.log('No piece selected');
                return;
            }
            
            // Check if this is a valid move
            if (validMoves.includes(clickedSquareNotation)) {
                console.log('Valid move! Moving from', selectedSquare, 'to', clickedSquareNotation);
                
                // Execute the move
                movePieceDirectly(selectedSquare, clickedSquareNotation, selectedPiece.dataset.piece);
                
                // Reset idle timer after move
                progressTracker.resetIdleTimer();
                
                // Update game state
                if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                    currentMoveIndex++;
                    updateMoveButtons();
                    highlightCurrentMove();
                    
                    // Call showLastMoveCheck to ensure check indicator is properly displayed
                    // Use longer delay (400ms) to ensure animation completes before showing check indicator
                    if (currentMoveIndex >= currentGame.moves_detailed.length) {
                        setTimeout(() => {
                            removeLastMoveCheck();
                            showLastMoveCheck();
                        }, 400);
                    }
                    
                    // Check if this is the final move and trigger completion indicator (only in test mode)
                    console.log('Checking completion after click - isChallengeMode:', isChallengeMode, 'currentMoveIndex:', currentMoveIndex, 'moves_detailed.length:', currentGame.moves_detailed.length);
                    if (isChallengeMode && currentMoveIndex >= currentGame.moves_detailed.length) {
                        console.log('*** PUZZLE COMPLETED VIA CLICK! Showing completion badge ***');
                        showCompletionBadge();
                        setTimeout(() => {
                            showCompletionIndicator();
                        }, 200);
                    } else {
                        console.log('Puzzle not completed yet via click - isChallengeMode:', isChallengeMode, 'currentMoveIndex:', currentMoveIndex, 'moves_detailed.length:', currentGame.moves_detailed.length);
                    }
                    
                    // Update comment section with current move info
                    // Note: showMoveCommentary function doesn't exist in puzzles
                    
                    checkChallengeProgress();
                }
                
                // Clear selection
                clearSelection();
                
                // Reinitialize drag and drop
                setTimeout(() => {
                    reinitializeDragAndDrop();
                }, 100);
            } else {
                console.log('Invalid move to', clickedSquareNotation);
                // Clear selection on invalid move
                clearSelection();
            }
        }

        // Clear piece selection and highlights
        function clearSelection() {
            // Clear visual highlights
            const selectedSquares = document.querySelectorAll('.chess-square.selected');
            selectedSquares.forEach(square => square.classList.remove('selected'));
            
            clearHighlights();
            
            // Clear selection variables
            selectedPiece = null;
            selectedSquare = null;
            draggedPiece = null;
            draggedFromSquare = null;
            validMoves = [];
        }

        // Calculate valid moves for current piece
        function calculateValidMoves() {
            if (!currentGame || currentMoveIndex >= currentGame.moves_detailed.length) {
                validMoves = [];
                return;
            }
            
            const currentMove = currentGame.moves_detailed[currentMoveIndex];
            const isWhiteMove = !!currentMove.white;
            
            // Debug: Log all properties of the move object
            console.log('Move object keys:', Object.keys(currentMove));
            console.log('Move object values:', Object.values(currentMove));
            console.log('white_to field:', currentMove.white_to);
            console.log('black_to field:', currentMove.black_to);
            
            // Check if the dragged piece is the correct piece for this move
            const expectedFrom = isWhiteMove ? currentMove.white_from : currentMove.black_from;
            const expectedTo = isWhiteMove ? currentMove.white_to : currentMove.black_to;
            
            console.log('Move validation:', {
                gameId: currentGame.id,
                gameName: currentGame.name,
                totalMoves: currentGame.moves_detailed.length,
                moveIndex: currentMoveIndex,
                move: currentMove.white || currentMove.black,
                isWhiteMove,
                expectedFrom,
                expectedTo,
                draggedFrom: draggedFromSquare,
                rawMove: currentMove
            });
            
            if (draggedFromSquare !== expectedFrom) {
                console.log('Wrong piece! Expected on', expectedFrom, 'but dragged from', draggedFromSquare);
                validMoves = [];
                return;
            }
            
            // Set valid destination square
            validMoves = [expectedTo];
            console.log('Valid moves set to:', validMoves);
        }

        // Highlight valid moves for current piece (only in normal mode)
        function highlightValidMoves() {
            // Calculate valid moves first
            calculateValidMoves();
            
            // Don't highlight moves in challenge mode - pure memory test
            if (isChallengeMode) {
                console.log('Challenge mode active - no move highlighting');
                return;
            }
            
            // Highlight valid squares
            validMoves.forEach(squareNotation => {
                const square = getSquareByNotation(squareNotation);
                if (square) {
                    square.classList.add('valid-move');
                    console.log('Highlighted square:', squareNotation);
                }
            });
        }


        // Clear move highlights
        function clearHighlights() {
            const squares = document.querySelectorAll('.chess-square');
            squares.forEach(square => {
                square.classList.remove('valid-move');
            });
        }

        // Handle drag over
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation(); // Prevent event bubbling to avoid infinite loops
            e.dataTransfer.dropEffect = 'move';
            
            // Only process if we're dragging over a square, not a piece
            if (e.target.classList.contains('chess-piece')) {
                return; // Don't process dragover events on pieces
            }
            
            
            if (e.target.classList.contains('chess-square')) {
                const squareNotation = getSquareNotationFromElement(e.target);
            }
        }

        // Handle drop
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation(); // Prevent event bubbling
            
            
            if (!draggedPiece || !draggedFromSquare) {
                console.log('No dragged piece or from square');
                return;
            }
            
            // Find the square element (not the piece)
            let toSquare = e.target;
            console.log('Initial toSquare:', toSquare);
            
            // If we dropped on a piece, get its parent square
            if (toSquare.classList.contains('chess-piece')) {
                console.log('Dropped on piece, getting parent square');
                toSquare = toSquare.parentElement;
                console.log('Parent square:', toSquare);
            }
            
            // Make sure we have a square element
            if (!toSquare.classList.contains('chess-square')) {
                console.log('Not a valid square element:', toSquare);
                return;
            }
            
            const toSquareNotation = getSquareNotationFromElement(toSquare);
            console.log('Destination square notation:', toSquareNotation);
            console.log('Is valid move?', validMoves.includes(toSquareNotation));
            
            // Check if trying to drop on the same square
            if (toSquareNotation === draggedFromSquare) {
                console.log('Cannot drop on the same square!');
                return;
            }
            
            // Check if this is a valid move
            if (validMoves.includes(toSquareNotation)) {
                console.log('Valid move! Executing move from', draggedFromSquare, 'to', toSquareNotation);
                
                // Move the piece directly without animation since it's already being dragged
                movePieceDirectly(draggedFromSquare, toSquareNotation, draggedPiece.dataset.piece);
                
                // Reset idle timer after move
                progressTracker.resetIdleTimer();
                
                 // Advance to next move
                 if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                     currentMoveIndex++;
                     
                     // Use the same update system as move buttons
                     updateBoardPosition();
                     updateMoveButtons();
                     highlightCurrentMove();
                     
                     // Check challenge progress
                     checkChallengeProgress();
                     
                     // Call showLastMoveCheck to ensure check indicator is properly displayed
                     // Use longer delay (500ms) to ensure updateBoardPosition completes first
                     if (currentMoveIndex >= currentGame.moves_detailed.length) {
                         setTimeout(() => {
                             removeLastMoveCheck();
                             showLastMoveCheck();
                         }, 500);
                     }
                     
                     // Update comment section with current move info
                     // Note: showMoveCommentary function doesn't exist in puzzles
                 }
                 
                 // Check if this is the final move and trigger completion indicator (only in test mode)
                 // This needs to be outside the above condition to work properly
                 console.log('Checking completion after drag and drop - isChallengeMode:', isChallengeMode, 'currentGame:', !!currentGame, 'currentMoveIndex:', currentMoveIndex, 'moves_detailed.length:', currentGame ? currentGame.moves_detailed.length : 'no game');
                 if (isChallengeMode && currentGame && currentMoveIndex >= currentGame.moves_detailed.length) {
                     console.log('*** PUZZLE COMPLETED VIA DRAG AND DROP! Showing completion badge ***');
                     showCompletionBadge();
                     setTimeout(() => {
                         showCompletionIndicator();
                     }, 200);
                 } else {
                     console.log('Puzzle not completed yet - isChallengeMode:', isChallengeMode, 'currentGame:', !!currentGame, 'currentMoveIndex:', currentMoveIndex, 'moves_detailed.length:', currentGame ? currentGame.moves_detailed.length : 'no game');
                 }
                 
                 // Small delay to ensure the move is processed, then re-initialize
                 setTimeout(() => {
                     reinitializeDragAndDrop();
                 }, 100);
            } else {
                console.log('Invalid move! Cannot drop on', toSquareNotation);
            }
        }

        // Get square notation from element
        function getSquareNotationFromElement(squareElement) {
            // Get the notation directly from the data-square attribute
            return squareElement.dataset.square;
        }

        // Execute a move (either by drag or button)
        function executeMove(from, to, piece) {
            // Move the piece with animation
            movePiece(from, to, piece, true);
            
            // Advance to next move
            if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                currentMoveIndex++;
                updateMoveButtons();
            }
        }

        // Move piece directly without animation (for drag and drop)
        function movePieceDirectly(from, to, piece) {
            // Start training timer on piece movement
            progressTracker.startTrainingTimer();
            
            console.log('=== MOVE PIECE DIRECTLY DEBUG ===');
            console.log('Moving piece from', from, 'to', to);
            const fromSquare = getSquareByNotation(from);
            const toSquare = getSquareByNotation(to);
            
            if (fromSquare && toSquare) {
                // Debug square dimensions BEFORE any changes
                const fromRectBefore = fromSquare.getBoundingClientRect();
                const toRectBefore = toSquare.getBoundingClientRect();
                console.log('BEFORE CHANGES:');
                console.log('From square dimensions:', {
                    width: fromRectBefore.width,
                    height: fromRectBefore.height,
                    classes: fromSquare.classList.toString()
                });
                console.log('To square dimensions:', {
                    width: toRectBefore.width,
                    height: toRectBefore.height,
                    classes: toSquare.classList.toString()
                });
                
                // Ensure board is in dragging state to disable transitions
                const board = document.getElementById('chess-board');
                board.classList.add('dragging');
                console.log('Added dragging class to board');
                console.log('Board classes after adding dragging:', board.classList.toString());
                
                // Check if transitions are actually disabled
                const computedStyle = window.getComputedStyle(toSquare);
                const transition = computedStyle.transition;
                console.log('To square transition property:', transition);
                
                // Clear valid-move class from ALL squares BEFORE making changes
                // This prevents size changes during the move operation
                clearHighlights();
                console.log('Cleared all highlights');
                
                // Debug square dimensions AFTER clearing highlights
                const fromRectAfterHighlights = fromSquare.getBoundingClientRect();
                const toRectAfterHighlights = toSquare.getBoundingClientRect();
                console.log('AFTER CLEARING HIGHLIGHTS:');
                console.log('From square dimensions:', {
                    width: fromRectAfterHighlights.width,
                    height: fromRectAfterHighlights.height,
                    classes: fromSquare.classList.toString()
                });
                console.log('To square dimensions:', {
                    width: toRectAfterHighlights.width,
                    height: toRectAfterHighlights.height,
                    classes: toSquare.classList.toString()
                });
                
                // Clear source square completely
                fromSquare.innerHTML = '';
                console.log('Cleared source square');
                
                // Debug square dimensions AFTER clearing source
                const fromRectAfterClear = fromSquare.getBoundingClientRect();
                console.log('AFTER CLEARING SOURCE:');
                console.log('From square dimensions:', {
                    width: fromRectAfterClear.width,
                    height: fromRectAfterClear.height,
                    classes: fromSquare.classList.toString()
                });
                
                // Clear destination square (in case there's a piece to capture)
                toSquare.innerHTML = '';
                console.log('Cleared destination square');
                
                // Debug square dimensions AFTER clearing destination
                const toRectAfterClear = toSquare.getBoundingClientRect();
                console.log('AFTER CLEARING DESTINATION:');
                console.log('To square dimensions:', {
                    width: toRectAfterClear.width,
                    height: toRectAfterClear.height,
                    classes: toSquare.classList.toString()
                });
                
                // Create new piece at destination
                const pieceElement = createDraggablePiece(piece, to);
                toSquare.appendChild(pieceElement);
                console.log('Added piece to destination');
                
                // Debug square dimensions AFTER adding piece
                const toRectAfterPiece = toSquare.getBoundingClientRect();
                console.log('AFTER ADDING PIECE:');
                console.log('To square dimensions:', {
                    width: toRectAfterPiece.width,
                    height: toRectAfterPiece.height,
                    classes: toSquare.classList.toString()
                });
                
                // Remove dragging class after a short delay to re-enable transitions
                setTimeout(() => {
                    board.classList.remove('dragging');
                    console.log('Removed dragging class from board');
                    
                    // Final debug after removing dragging class
                    const toRectFinal = toSquare.getBoundingClientRect();
                    console.log('FINAL DIMENSIONS:');
                    console.log('To square dimensions:', {
                        width: toRectFinal.width,
                        height: toRectFinal.height,
                        classes: toSquare.classList.toString()
                    });
                }, 50);
                
                console.log('Move completed');
                
                // Play move sound effect
                playSound(false);
            } else {
                console.log('Invalid squares - from:', fromSquare, 'to:', toSquare);
            }
            console.log('=== END MOVE PIECE DIRECTLY ===');
        }



        // Animate existing piece from source to destination
        function animateExistingPiece(sourceSquare, destinationSquare, pieceImage) {
            // Get the existing piece from source square
            const existingPiece = sourceSquare.querySelector('.chess-piece');
            if (!existingPiece) return;

            // Get the chess board container
            const board = document.getElementById('chess-board');
            
            // Create a temporary piece for animation
            const tempPiece = existingPiece.cloneNode(true);
            tempPiece.style.position = 'absolute';
            tempPiece.style.zIndex = '1000';
            tempPiece.style.pointerEvents = 'none';
            tempPiece.style.width = '60px';
            tempPiece.style.height = '60px';
            tempPiece.style.transition = 'all 0.3s ease-in-out';

            // Get positions
            const sourceRect = sourceSquare.getBoundingClientRect();
            const destRect = destinationSquare.getBoundingClientRect();
            const boardRect = board.getBoundingClientRect();

            // Calculate positions relative to the board
            const sourceLeft = sourceRect.left - boardRect.left;
            const sourceTop = sourceRect.top - boardRect.top;
            const destLeft = destRect.left - boardRect.left;
            const destTop = destRect.top - boardRect.top;

            // Position the temp piece at source
            tempPiece.style.left = sourceLeft + 'px';
            tempPiece.style.top = sourceTop + 'px';

            // Add to board
            board.appendChild(tempPiece);

            // Remove the original piece immediately to prevent double pieces
            sourceSquare.innerHTML = '';

            // Animate to destination
            requestAnimationFrame(() => {
                tempPiece.style.left = destLeft + 'px';
                tempPiece.style.top = destTop + 'px';
            });

            // After animation, place piece in destination square and clean up
            setTimeout(() => {
                // Remove temp piece
                if (tempPiece.parentNode) {
                    tempPiece.parentNode.removeChild(tempPiece);
                }

                // Clear destination square completely before placing new piece
                destinationSquare.innerHTML = '';
                
                // Create a new draggable piece at destination
                const newPiece = createDraggablePiece(pieceImage, getSquareNotationFromElement(destinationSquare));
                destinationSquare.appendChild(newPiece);
                
                // Play sound after animation completes
                playSound(false);
                
                // Re-initialize drag and drop for all pieces
                reinitializeDragAndDrop();
            }, 300);
        }

        // Show move commentary

        // Display game moves
        function displayGameMoves(game) {
            const movesList = document.getElementById('moves-list');
            movesList.innerHTML = '';
            

            // Group moves by move number (white and black moves together)
            const moveGroups = {};
            game.moves_detailed.forEach(move => {
                if (!moveGroups[move.move_number]) {
                    moveGroups[move.move_number] = { white: null, black: null };
                }
                if (move.white) {
                    moveGroups[move.move_number].white = move.white;
                }
                if (move.black) {
                    moveGroups[move.move_number].black = move.black;
                }
            });

            // Display all moves in a structured layout
            const moveItem = document.createElement('div');
            moveItem.className = 'move-item';
            
            // Create move numbers and moves
            Object.keys(moveGroups).forEach((moveNumber, moveIndex) => {
                const group = moveGroups[moveNumber];
                
                // Create move row
                const moveRow = document.createElement('div');
                moveRow.className = 'move-row';
                
                // Add move number to the row
                const moveNumberSpan = document.createElement('span');
                moveNumberSpan.textContent = moveNumber + '.';
                moveNumberSpan.className = 'move-number';
                moveRow.appendChild(moveNumberSpan);
                
                // Create white moves container
                const whiteMoves = document.createElement('div');
                whiteMoves.className = 'white-moves';
                
                // Create black moves container
                const blackMoves = document.createElement('div');
                blackMoves.className = 'black-moves';
                
                // Add white move if it exists
                if (group.white) {
                    const whiteMoveSpan = document.createElement('span');
                    whiteMoveSpan.textContent = convertToChessSymbols(group.white);
                    whiteMoveSpan.className = 'clickable-move';
                    whiteMoveSpan.dataset.moveIndex = moveIndex * 2;
                    
                    // Find the move data for annotations
                    const whiteMoveData = game.moves_detailed.find(m => m.white === group.white && m.move_number == moveNumber);
                    if (whiteMoveData) {
                        // Add annotation if it exists
                        if (whiteMoveData.annotation) {
                            const annotationSpan = document.createElement('span');
                            annotationSpan.textContent = whiteMoveData.annotation;
                            annotationSpan.className = 'move-annotation';
                            annotationSpan.style.marginLeft = '4px';
                            annotationSpan.style.color = '#000000';
                            whiteMoveSpan.appendChild(annotationSpan);
                        }
                        
                    }
                    
                    whiteMoves.appendChild(whiteMoveSpan);
                }
                
                // Add click listener to entire white-moves div
                whiteMoves.addEventListener('click', function() {
                    console.log('White move clicked:', group.white, 'moveIndex:', moveIndex);
                    if (group.white) {
                        // For puzzles, we want to show the position AFTER the move
                        // The move is at index (initial_move_index + moveIndex)
                        const targetIndex = (game.initial_move_index || 0) + moveIndex + 1;
                        currentMoveIndex = Math.min(targetIndex, game.moves_detailed.length);
                        console.log('Setting currentMoveIndex to:', currentMoveIndex, 'initial_move_index:', game.initial_move_index);
                        updateBoardPosition();
                        updateMoveButtons();
                        
                        // Show green check indicator if on final position
                        if (currentMoveIndex >= game.moves_detailed.length) {
                            setTimeout(() => {
                                removeLastMoveCheck();
                                showLastMoveCheck();
                            }, 500);
                        }
                        
                        // Note: showLastMoveCheck is already called above, no need for showCompletionIndicator in non-test mode
                        
                        // Remove highlight from all moves and sections
                        moveItem.querySelectorAll('.clickable-move').forEach(span => {
                            span.classList.remove('active-move');
                        });
                        moveItem.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                            section.classList.remove('clicked');
                        });
                        // Highlight current move and section
                        if (group.white) {
                            whiteMoves.querySelector('.clickable-move').classList.add('active-move');
                        }
                        whiteMoves.classList.add('clicked');
                        
                        // Show commentary if available
                        const whiteMoveData = game.moves_detailed.find(m => m.white === group.white && m.move_number == moveNumber);
                        if (whiteMoveData) {
                            showMoveCommentary(whiteMoveData.description, group.white, whiteMoveData);
                        }
                        
                    }
                });
                
                // Add black move if it exists
                if (group.black) {
                    const blackMoveSpan = document.createElement('span');
                    blackMoveSpan.textContent = convertToChessSymbols(group.black);
                    blackMoveSpan.className = 'clickable-move';
                    blackMoveSpan.dataset.moveIndex = moveIndex * 2 + 1;
                    
                    // Find the move data for annotations
                    const blackMoveData = game.moves_detailed.find(m => m.black === group.black && m.move_number == moveNumber);
                    if (blackMoveData) {
                        // Add annotation if it exists
                        if (blackMoveData.annotation) {
                            const annotationSpan = document.createElement('span');
                            annotationSpan.textContent = blackMoveData.annotation;
                            annotationSpan.className = 'move-annotation';
                            annotationSpan.style.marginLeft = '4px';
                            annotationSpan.style.color = '#000000';
                            blackMoveSpan.appendChild(annotationSpan);
                        }
                        
                    }
                    
                    blackMoves.appendChild(blackMoveSpan);
                }
                
                // Add click listener to entire black-moves div
                blackMoves.addEventListener('click', function() {
                    console.log('Black move clicked:', group.black, 'moveIndex:', moveIndex);
                    if (group.black) {
                        // For puzzles, we want to show the position AFTER the move
                        // Since puzzles start at initial_move_index (usually 0), we need to add 1 to show after the move
                        const targetIndex = (game.initial_move_index || 0) + moveIndex + 1;
                        currentMoveIndex = Math.min(targetIndex, game.moves_detailed.length);
                        console.log('Setting currentMoveIndex to:', currentMoveIndex, 'initial_move_index:', game.initial_move_index);
                        updateBoardPosition();
                        updateMoveButtons();
                        
                        // Show green check indicator if on final position
                        if (currentMoveIndex >= game.moves_detailed.length) {
                            setTimeout(() => {
                                removeLastMoveCheck();
                                showLastMoveCheck();
                            }, 500);
                        }
                        
                        // Note: showLastMoveCheck is already called above, no need for showCompletionIndicator in non-test mode
                        
                        // Remove highlight from all moves and sections
                        moveItem.querySelectorAll('.clickable-move').forEach(span => {
                            span.classList.remove('active-move');
                        });
                        moveItem.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                            section.classList.remove('clicked');
                        });
                        // Highlight current move and section
                        if (group.black) {
                            blackMoves.querySelector('.clickable-move').classList.add('active-move');
                        }
                        blackMoves.classList.add('clicked');
                        
                        // Show commentary if available
                        const blackMoveData = game.moves_detailed.find(m => m.black === group.black && m.move_number == moveNumber);
                        if (blackMoveData) {
                            showMoveCommentary(blackMoveData.description, group.black, blackMoveData);
                        }
                        
                    }
                });
                
                // Add moves to row
                moveRow.appendChild(whiteMoves);
                moveRow.appendChild(blackMoves);
                moveItem.appendChild(moveRow);
            });
            
            movesList.appendChild(moveItem);
            
            // Add result notation if the game ends in checkmate
            if (game.result && (game.result.includes('wins') || game.result.includes('White wins') || game.result.includes('Black wins'))) {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'game-result';
                resultDiv.style.cssText = 'text-align: center; font-weight: bold; font-size: 16px; margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px; border: 2px solid #dee2e6;';
                
                // Determine the result notation
                let resultNotation = '';
                if (game.result.includes('White wins')) {
                    resultNotation = '1-0';
                } else if (game.result.includes('Black wins')) {
                    resultNotation = '0-1';
                }
                
                if (resultNotation) {
                    resultDiv.textContent = resultNotation;
                    movesList.appendChild(resultDiv);
                }
            }

        }


        // Function to restore main game event listeners
        function restoreMainGameEventListeners() {
            console.log('=== RESTORING MAIN GAME EVENT LISTENERS ===');
            const pieces = document.querySelectorAll('.piece');
            console.log('Found pieces:', pieces.length);
            pieces.forEach((piece, index) => {
                console.log(`Piece ${index}:`, piece);
                // Remove custom game event listeners
                piece.removeEventListener('click', handleCustomPieceClick);
                piece.removeEventListener('dragstart', handleCustomDragStart);
                piece.removeEventListener('dragend', handleCustomDragEnd);
                
                // Restore main game event listeners
                piece.addEventListener('dragstart', handleDragStart);
                piece.addEventListener('dragend', handleDragEnd);
                piece.addEventListener('click', handlePieceClick);
                console.log(`Restored event listeners for piece ${index}`);
            });
        }

        // Function to completely exit custom game mode
        function exitCustomGameMode() {
            // Reset custom game variables
            if (typeof customGameMode !== 'undefined') {
                customGameMode = false;
                window.customGameMode = false;
            }
            
            // Clear custom game elements
            clearCustomGameElements();
            
            // Hide custom game info section
            if (typeof hideCustomGameInfo === 'function') {
                hideCustomGameInfo();
            }
            
            // Hide custom save button
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            
            // Hide custom commentary section
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            
            // Hide custom save message
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }
            
            // Restore main game event listeners
            restoreMainGameEventListeners();
        }

        // Display selected puzzle
        function displayGame(puzzleId) {
            console.log('=== DISPLAYGAME CALLED ===');
            console.log('Displaying puzzle:', puzzleId);
            console.log('Puzzles data:', puzzlesData);
            console.log('Puzzles data exists:', !!puzzlesData);
            console.log('Puzzles array length:', puzzlesData ? puzzlesData.puzzles.length : 'N/A');
            
            // Always exit custom game mode when displaying any puzzle
            exitCustomGameMode();
            
            // Exit test mode if switching to a different puzzle
            if (isChallengeMode && currentGame && currentGame.id !== puzzleId) {
                toggleChallengeMode();
            }
            
            if (!puzzlesData) {
                console.error('No puzzles data available');
                return;
            }
            
            const puzzle = puzzlesData.puzzles.find(p => p.id === puzzleId);
            console.log('Found puzzle:', puzzle);
            
            if (!puzzle) {
                console.error('Puzzle not found:', puzzleId);
                return;
            }

            // Set current game and reset move index
            currentGame = puzzle;
            // Check if puzzle has a custom initial move index, otherwise start at 0
            currentMoveIndex = puzzle.initial_move_index || 0;
            
            // Start training session tracking based on type
            const sessionType = 'puzzle';
            progressTracker.startSession(sessionType);
            
            // Update selected state for game buttons
            document.querySelectorAll('.submenu-button').forEach(btn => {
                btn.classList.remove('selected');
            });
            const selectedButton = document.querySelector(`[data-game-id="${puzzleId}"]`);
            if (selectedButton) {
                selectedButton.classList.add('selected');
            }
            
            // Reset the board to starting position
            resetBoard();
            
            // Clear any piece selection
            clearSelection();
            
            // Reset to empty visual mode when switching puzzles
            currentVisualMode = 'empty';
            switchVisualMode('empty');

            // Show game display
            const gameDisplay = document.getElementById('game-display');
            gameDisplay.classList.add('show');

            // Show moves toggle and hide moves by default
            const movesToggle = document.getElementById('moves-toggle');
            const movesList = document.getElementById('moves-list');
            const toggleImg = document.getElementById('moves-toggle-img');
            
            movesToggle.style.display = 'block';
            
            // Hide moves by default and set button to "view" state
            movesList.style.display = 'none';
            toggleImg.src = 'images/view.png';
            toggleImg.title = 'Show moves';
            
            // Event listeners are handled via delegation, no need to reattach



            
            // Handle custom puzzle elements visibility
            if (puzzle.id.startsWith('custom-puzzle-')) {
                // Show custom puzzle elements for custom puzzles
                // Ensure moves list is visible for saved custom puzzles
                const movesList = document.getElementById('moves-list');
                if (movesList) {
                    movesList.style.display = 'block';
                }
            } else {
                // Hide custom game elements for preprogrammed games
                if (typeof hideCustomGameInfo === 'function') {
                    hideCustomGameInfo();
                }
                if (typeof hideCustomSaveButton === 'function') {
                    hideCustomSaveButton();
                }
                if (typeof hideCustomCommentarySection === 'function') {
                    hideCustomCommentarySection();
                }
                if (typeof hideCustomSaveMessage === 'function') {
                    hideCustomSaveMessage();
                }
            }

            // Populate puzzle details
            populateGameDetails(puzzle);

            // Setup board and display moves
            setupInitialPosition();
            
            // Handle board orientation efficiently
            const shouldBeFlipped = puzzle.turn === 'black';
            const orientationChanged = shouldBeFlipped !== boardFlipped;
            
            if (orientationChanged) {
                // Update the flipped state
                boardFlipped = shouldBeFlipped;
                
                // Update button appearance
                const flipBtn = document.getElementById('flip-board-btn');
                if (boardFlipped) {
                    flipBtn.classList.add('flipped');
                } else {
                    flipBtn.classList.remove('flipped');
                }
                
                // Update notation
                flipNotation();
                
                // Rebuild the board with new orientation
                initializeChessBoard();
                setupInitialPosition();
                reinitializeDragAndDrop();
            }
            
            reinitializeDragAndDrop(); // Ensure click handlers are attached
            displayGameMoves(puzzle);
            updateMoveButtons();
            
            // Display puzzle position information
            displayPuzzlePositionInfo(puzzle);
            
            
            // If puzzle has a custom initial move index, update board to that position
            if (puzzle.initial_move_index && puzzle.initial_move_index > 0) {
                updateBoardPosition();
            }
             highlightCurrentMove();
             
            // Show/hide delete button for custom puzzles (only when viewing saved custom puzzles, not in Add Puzzle mode)
            const deleteGameSection = document.getElementById('delete-game-section');
            const deleteGameBtn = document.getElementById('delete-game-btn');
            if (puzzle.id.startsWith('custom-puzzle-') && !window.customGameMode) {
                deleteGameSection.style.display = 'block';
                deleteGameBtn.onclick = (e) => deleteCustomGame(e, puzzle.id);
                 
                 // Hide custom commentary section and save button when viewing saved custom games
                 if (typeof hideCustomCommentarySection === 'function') {
                     hideCustomCommentarySection();
                 }
                 if (typeof hideCustomSaveButton === 'function') {
                     hideCustomSaveButton();
                 }
             } else {
                 deleteGameSection.style.display = 'none';
             }
             
             // Visual mode placeholder - no effects applied yet
        }

        // Populate game details
        function populateGameDetails(game) {
            document.getElementById('detail-description').textContent = game.description;
            document.getElementById('detail-moves').textContent = `${game.moves} moves`;
            document.getElementById('detail-white').textContent = game.white_player;
            document.getElementById('detail-black').textContent = game.black_player;
            document.getElementById('detail-opening').textContent = game.opening;
            document.getElementById('detail-difficulty').textContent = game.difficulty;
            
            // Use facts from JSON data (single source of truth)
            const facts = game.facts || 'No interesting facts available for this game.';
            document.getElementById('detail-facts').textContent = facts;
        }


        // Create confetti effect
        function createConfetti() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.position = 'fixed';
                confetti.style.width = '10px';
                confetti.style.height = '10px';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.top = '-10px';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.zIndex = '9999';
                confetti.style.pointerEvents = 'none';
                confetti.style.animation = 'confetti-fall 3s linear forwards';
                confetti.style.animationDelay = Math.random() * 2 + 's';
                
                document.body.appendChild(confetti);
                
                // Remove confetti after animation
                setTimeout(() => {
                    if (confetti.parentNode) {
                        confetti.parentNode.removeChild(confetti);
                    }
                }, 5000);
            }
        }

        // Show completion indicator on the piece that made the final move
        function showCompletionIndicator() {
            if (!currentGame || currentMoveIndex < currentGame.moves_detailed.length) return;
            
            // Get the last move to find which piece moved
            const lastMove = currentGame.moves_detailed[currentGame.moves_detailed.length - 1];
            const moveNotation = lastMove.white || lastMove.black;
            const isWhiteMove = !!lastMove.white;
            
            // Parse the move to get the destination square
            const parsedMove = currentGame.type === 'puzzle' ? 
                parsePuzzleMove(lastMove, moveNotation, isWhiteMove) : 
                moveParser.parseMove(moveNotation, isWhiteMove);
            if (parsedMove) {
                const destinationSquare = document.querySelector(`[data-square="${parsedMove.target}"]`);
                if (destinationSquare) {
                    // Remove any existing completion indicator
                    const existingIndicator = document.querySelector('.completion-indicator');
                    if (existingIndicator) {
                        existingIndicator.remove();
                    }
                    
                    // Create new completion indicator
                    const indicator = document.createElement('div');
                    indicator.className = 'completion-indicator';
                    indicator.innerHTML = '✓';
                    indicator.title = 'Game completed!';
                    
                    // Make sure the square has relative positioning
                    destinationSquare.style.position = 'relative';
                    
                    // Add the indicator to the destination square
                    destinationSquare.appendChild(indicator);
                }
            }
        }

        // Remove completion indicator
        function removeCompletionIndicator() {
            const existingIndicator = document.querySelector('.completion-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
        }

        // Show green check indicator when the last move is completed (for all modes except test mode)
        function showLastMoveCheck() {
            console.log('*** showLastMoveCheck called in puzzles ***');
            console.log('isChallengeMode:', isChallengeMode);
            console.log('currentGame:', !!currentGame);
            console.log('currentMoveIndex:', currentMoveIndex);
            console.log('moves_detailed.length:', currentGame ? currentGame.moves_detailed.length : 'no game');
            
            // Don't show check in test mode
            if (isChallengeMode) {
                console.log('Not showing check in test mode');
                return;
            }
            
            // Only show when on the last move
            if (!currentGame || currentMoveIndex < currentGame.moves_detailed.length) {
                console.log('Not showing check - not on last move, currentMoveIndex:', currentMoveIndex, 'length:', currentGame ? currentGame.moves_detailed.length : 'no game');
                return;
            }
            
            console.log('✅ Showing green check for final move!');
            
            // Get the last move to find which piece moved
            const lastMove = currentGame.moves_detailed[currentGame.moves_detailed.length - 1];
            const moveNotation = lastMove.white || lastMove.black;
            const isWhiteMove = !!lastMove.white;
            
            console.log('Last move:', lastMove);
            console.log('moveNotation:', moveNotation);
            
            // Parse the puzzle move - pass moveNotation as second argument, isWhiteMove as third
            const parsedMove = parsePuzzleMove(lastMove, moveNotation, isWhiteMove);
            console.log('parsedMove:', parsedMove);
            
            if (parsedMove && parsedMove.target) {
                console.log('Looking for square:', parsedMove.target);
                const destinationSquare = document.querySelector(`[data-square="${parsedMove.target}"]`);
                console.log('destinationSquare found:', !!destinationSquare);
                if (destinationSquare) {
                    console.log('destinationSquare element:', destinationSquare);
                    
                    // Remove any existing check indicator
                    const existingCheck = document.querySelector('.last-move-check');
                    if (existingCheck) {
                        existingCheck.remove();
                        console.log('Removed existing check indicator');
                    }
                    
                    // Create new check indicator with the green check image
                    const checkIndicator = document.createElement('div');
                    checkIndicator.className = 'last-move-check';
                    checkIndicator.style.position = 'absolute';
                    checkIndicator.style.top = '2px';
                    checkIndicator.style.right = '2px';
                    checkIndicator.style.width = '20px';
                    checkIndicator.style.height = '20px';
                    checkIndicator.style.backgroundImage = 'url(images/checked.png)';
                    checkIndicator.style.backgroundSize = 'contain';
                    checkIndicator.style.backgroundRepeat = 'no-repeat';
                    checkIndicator.style.backgroundPosition = 'center';
                    checkIndicator.style.pointerEvents = 'none';
                    checkIndicator.style.zIndex = '9999';
                    checkIndicator.title = 'Final move completed!';
                    
                    console.log('Check indicator styles:', {
                        position: checkIndicator.style.position,
                        top: checkIndicator.style.top,
                        right: checkIndicator.style.right,
                        width: checkIndicator.style.width,
                        height: checkIndicator.style.height,
                        backgroundImage: checkIndicator.style.backgroundImage,
                        zIndex: checkIndicator.style.zIndex
                    });
                    
                    // Make sure the square has relative positioning
                    if (window.getComputedStyle(destinationSquare).position === 'static') {
                        destinationSquare.style.position = 'relative';
                        console.log('Set destination square position to relative');
                    }
                    
                    // Add the indicator to the destination square
                    destinationSquare.appendChild(checkIndicator);
                    console.log('✅ Green check indicator added to puzzle! Square now has', destinationSquare.children.length, 'children');
                    
                    // Debug: Check if the indicator is actually visible
                    setTimeout(() => {
                        const computedStyle = window.getComputedStyle(checkIndicator);
                        console.log('Check indicator computed styles after 100ms:', {
                            display: computedStyle.display,
                            visibility: computedStyle.visibility,
                            opacity: computedStyle.opacity,
                            zIndex: computedStyle.zIndex,
                            top: computedStyle.top,
                            right: computedStyle.right,
                            width: computedStyle.width,
                            height: computedStyle.height
                        });
                        const rect = checkIndicator.getBoundingClientRect();
                        console.log('Check indicator bounding rect:', rect);
                        console.log('Is indicator visible?', rect.width > 0 && rect.height > 0);
                    }, 100);
                } else {
                    console.log('❌ Could not find destination square:', parsedMove.target);
                }
            } else {
                console.log('❌ Could not parse puzzle move or no target:', parsedMove);
            }
        }

        // Remove last move check indicator
        function removeLastMoveCheck() {
            const existingCheck = document.querySelector('.last-move-check');
            if (existingCheck) {
                existingCheck.remove();
            }
        }

        // Convert chess piece letters to symbols
        function convertToChessSymbols(notation) {
            if (!notation) return notation;
            
            return notation
                .replace(/K/g, '♔')  // King
                .replace(/Q/g, '♕')  // Queen
                .replace(/R/g, '♖')  // Rook
                .replace(/B/g, '♗')  // Bishop
                .replace(/N/g, '♘')  // Knight
                .replace(/P/g, '♙')  // Pawn
                .replace(/k/g, '♚')  // Black King
                .replace(/q/g, '♛')  // Black Queen
                .replace(/r/g, '♜')  // Black Rook
                .replace(/b/g, '♝')  // Black Bishop
                .replace(/n/g, '♞')  // Black Knight
                .replace(/p/g, '♟')  // Black Pawn
                .replace(/x/g, '×')  // Capture symbol
                .replace(/\+/g, '+')  // Check symbol
                .replace(/#/g, '#');  // Checkmate symbol
        }


        // Function to highlight the current move in the moves list
        function highlightCurrentMove() {
            if (!currentGame) return;
            
            // Use setTimeout to ensure this runs after DOM updates
            setTimeout(() => {
                // Remove all existing highlights
                document.querySelectorAll('.clickable-move').forEach(span => {
                    span.classList.remove('active-move');
                });
                document.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                    section.classList.remove('clicked');
                });
                
                // If at initial position, don't highlight anything
                if (currentMoveIndex === 0) return;
                
                // Calculate which move to highlight
                const moveNumber = Math.ceil(currentMoveIndex / 2);
                const isWhiteMove = currentMoveIndex % 2 === 1;
                
                // Find all move rows
                const moveRows = document.querySelectorAll('.move-row');
                
                // Find the target move row (0-based indexing)
                const targetMoveRow = moveRows[moveNumber - 1];
                if (!targetMoveRow) return;
                
                let highlightedElement = null;
                
                // Highlight the appropriate move
                if (isWhiteMove) {
                    const whiteMoves = targetMoveRow.querySelector('.white-moves');
                    if (whiteMoves) {
                        const clickableMove = whiteMoves.querySelector('.clickable-move');
                        if (clickableMove) {
                            clickableMove.classList.add('active-move');
                        }
                        whiteMoves.classList.add('clicked');
                        highlightedElement = whiteMoves;
                    }
                } else {
                    const blackMoves = targetMoveRow.querySelector('.black-moves');
                    if (blackMoves) {
                        const clickableMove = blackMoves.querySelector('.clickable-move');
                        if (clickableMove) {
                            clickableMove.classList.add('active-move');
                        }
                        blackMoves.classList.add('clicked');
                        highlightedElement = blackMoves;
                    }
                }
                
                // Auto-scroll the highlighted move into view
                if (highlightedElement) {
                    // Use a slight delay to ensure highlighting is complete
                    setTimeout(() => {
                        highlightedElement.scrollIntoView({
                            behavior: 'smooth',
                            block: 'nearest',
                            inline: 'nearest'
                        });
                    }, 50);
                }
            }, 10);
        }

        // Move navigation functions
        function goToInitialPosition() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToFirstCustomMove();
                return;
            }
            
            clearSelection();
            currentMoveIndex = 0;
            
            // Reset the move parser's position tracking
            moveParser.resetBoard();
            
            setupInitialPosition();
            updateMoveButtons();
            highlightCurrentMove();
            
            // Remove completion and check indicators when going to initial position
            removeCompletionIndicator();
            removeLastMoveCheck();
            
            
            // Play sound for user feedback
            playSound(false);
        }

        function goToPreviousMove() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToPreviousCustomMove();
                return;
            }
            
            if (currentMoveIndex > 0) {
                clearSelection();
                currentMoveIndex--;
                updateBoardPosition();
                updateMoveButtons();
                highlightCurrentMove();
                
                // Remove completion and check indicators when moving away from final position
                removeCompletionIndicator();
                removeLastMoveCheck();
                
            }
        }

        function goToNextMove() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToNextCustomMove();
                return;
            }
            
            console.log('goToNextMove called - currentMoveIndex:', currentMoveIndex, 'total moves:', currentGame ? currentGame.moves_detailed.length : 'no game');
            
            if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                // Execute the move
                executeMove();
            }
        }
        
        function executeMove() {
            if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                clearSelection();
                const move = currentGame.moves_detailed[currentMoveIndex];
                const moveNotation = move.white || move.black;
                const isWhiteMove = !!move.white;
                
                console.log('Move data:', move);
                console.log('Move notation:', moveNotation);
                console.log('Is white move:', isWhiteMove);
                
                // Use JSON coordinates if available, otherwise parse the move notation
                let sourceSquare, destinationSquare, pieceImage;
                
                if (move.white_from && move.white_to) {
                    // Use coordinates from JSON for white moves
                    sourceSquare = getSquareByNotation(move.white_from);
                    destinationSquare = getSquareByNotation(move.white_to);
                    
                    // Extract piece type from notation - handle different formats
                    let piece = 'P'; // Default to pawn
                    if (moveNotation.length > 0) {
                        const firstChar = moveNotation.charAt(0).toUpperCase();
                        if (['K', 'Q', 'R', 'B', 'N'].includes(firstChar)) {
                            piece = firstChar;
                        }
                    }
                    console.log('White move - piece from notation:', piece, 'notation:', moveNotation);
                    pieceImage = moveParser.getPieceImage(piece, isWhiteMove);
                } else if (move.black_from && move.black_to) {
                    // Use coordinates from JSON for black moves
                    sourceSquare = getSquareByNotation(move.black_from);
                    destinationSquare = getSquareByNotation(move.black_to);
                    
                    // Extract piece type from notation - handle different formats
                    let piece = 'P'; // Default to pawn
                    if (moveNotation.length > 0) {
                        const firstChar = moveNotation.charAt(0).toUpperCase();
                        if (['K', 'Q', 'R', 'B', 'N'].includes(firstChar)) {
                            piece = firstChar;
                        }
                    }
                    console.log('Black move - piece from notation:', piece, 'notation:', moveNotation);
                    pieceImage = moveParser.getPieceImage(piece, isWhiteMove);
                } else {
                    // Fallback to parsing move notation
                    const parsedMove = currentGame.type === 'puzzle' ? 
                        parsePuzzleMove(move, moveNotation, isWhiteMove) : 
                        moveParser.parseMove(moveNotation, isWhiteMove);
                    console.log('Parsed move:', parsedMove);
                    pieceImage = moveParser.getPieceImage(parsedMove.piece, isWhiteMove);
                    sourceSquare = getSquareByNotation(parsedMove.source);
                    destinationSquare = getSquareByNotation(parsedMove.target);
                }
                
                console.log('Using coordinates:', { source: move.white_from || move.black_from, target: move.white_to || move.black_to });
                
                if (moveNotation.includes('O-O')) {
                    // Handle castling
                    const parsedMove = currentGame.type === 'puzzle' ? 
                        parsePuzzleMove(move, moveNotation, isWhiteMove) : 
                        moveParser.parseMove(moveNotation, isWhiteMove);
                    applyCastling(parsedMove, true, true);
                } else if (sourceSquare && destinationSquare && pieceImage) {
                    // Use the proper animation for existing pieces
                    animateExistingPiece(sourceSquare, destinationSquare, pieceImage);
                    
                    // Update piece positions in the parser - use the piece from notation
                    const piece = moveNotation.charAt(0).toUpperCase();
                    const sourceNotation = move.white_from || move.black_from;
                    const targetNotation = move.white_to || move.black_to;
                    moveParser.updatePiecePosition(piece, sourceNotation, targetNotation, isWhiteMove);
                }
                    
                    currentMoveIndex++;
                    updateMoveButtons();
                    highlightCurrentMove();
                    
                    // Show green check indicator if on final position (for all modes except test mode)
                    if (currentMoveIndex >= currentGame.moves_detailed.length) {
                        setTimeout(() => {
                            removeLastMoveCheck();
                            showLastMoveCheck();
                        }, 500);
                    }
                    
                    // Check if this is the final move and trigger completion indicator after animation (only in test mode)
                    console.log('Checking completion - isChallengeMode:', isChallengeMode, 'currentMoveIndex:', currentMoveIndex, 'totalMoves:', currentGame.moves_detailed.length);
                    if (isChallengeMode && currentMoveIndex >= currentGame.moves_detailed.length) {
                        console.log('Puzzle completed! Showing completion badge');
                        showCompletionBadge();
                        // Wait for animation to complete (300ms + buffer)
                        setTimeout(() => {
                            showCompletionIndicator();
                        }, 400);
                    }
                    
                    // Update challenge progress in test mode
                    if (isChallengeMode) {
                        checkChallengeProgress();
                    }
                    
                    // Update comment section with current move info only if moves are visible
                    const movesList = document.getElementById('moves-list');
                    if (move && movesList.style.display !== 'none') {
                }
            }
        }

        function goToFinalPosition() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToLastCustomMove();
                return;
            }
            
            if (currentGame) {
                clearSelection();
                currentMoveIndex = currentGame.moves_detailed.length;
                updateBoardPosition();
                updateMoveButtons();
                highlightCurrentMove();
                
                // Call showLastMoveCheck to ensure check indicator is properly displayed
                // Use longer delay (400ms) to ensure animation completes before showing check indicator
                setTimeout(() => {
                    removeLastMoveCheck();
                    showLastMoveCheck();
                }, 400);
                
                // Trigger completion indicator for reaching final position (only in test mode)
                if (isChallengeMode) {
                    setTimeout(() => {
                        showCompletionIndicator();
                    }, 200);
                }
                
                // Update comment section with the last move info only if moves are visible
                const movesList = document.getElementById('moves-list');
                if (movesList.style.display !== 'none' && currentGame.moves_detailed.length > 0) {
                    const lastMove = currentGame.moves_detailed[currentGame.moves_detailed.length - 1];
                    const moveNotation = lastMove.white || lastMove.black;
                    showMoveCommentary(lastMove.commentary, moveNotation, lastMove);
                }
            }
        }

        function updateBoardPosition() {
            if (!currentGame) {
                console.log('updateBoardPosition: No currentGame available');
                return;
            }
            
            console.log('Updating board position to move index:', currentMoveIndex, 'Total moves:', currentGame.moves_detailed.length);
            
            // Store completion indicator state before clearing
            const wasAtFinalPosition = currentMoveIndex >= currentGame.moves_detailed.length;
            
            // Clear the board completely
            const board = document.getElementById('chess-board');
            const squares = board.querySelectorAll('.chess-square');
            squares.forEach(square => {
                square.innerHTML = '';
            });

            // Reset the move parser's position tracking
            moveParser.resetBoard();

            // Set up initial position
            setupInitialPosition();

            // Apply moves up to current position
            // For puzzles, start from initial_move_index, for games start from 0
            const startIndex = currentGame.initial_move_index || 0;
            console.log('DEBUG: startIndex:', startIndex, 'currentMoveIndex:', currentMoveIndex, 'total moves:', currentGame.moves_detailed.length);
            for (let i = startIndex; i < currentMoveIndex && i < currentGame.moves_detailed.length; i++) {
                const move = currentGame.moves_detailed[i];
                console.log(`DEBUG: Applying move ${i + 1}:`, move.white || move.black, 'from', move.white_from, 'to', move.white_to);
                applyMove(move, false, false);
            }
            
            // Play sound only for the current (last applied) move
            if (currentMoveIndex > 0 && currentMoveIndex <= currentGame.moves_detailed.length) {
                const lastMove = currentGame.moves_detailed[currentMoveIndex - 1];
                if (lastMove) {
                    // Check if it's a capture by looking for 'x' in the move notation
                    const moveNotation = lastMove.white || lastMove.black;
                    const isCapture = moveNotation && moveNotation.includes('x');
                    playSound(isCapture);
                }
            }

            // Re-initialize drag and drop for all pieces
            reinitializeDragAndDrop();
            
            // Make pieces invisible if in test mode
            if (isChallengeMode) {
                const pieces = document.querySelectorAll('.chess-piece');
                pieces.forEach(piece => {
                    piece.style.opacity = '0';
                });
            }
            
            
            // Update move highlighting
            highlightCurrentMove();
            
            // Don't manage the green check indicator here - let the calling function handle it
            // The check indicator is added by the calling function (executeMove, handleDrop, etc.)
            // This prevents it from being removed and re-added, causing flicker
        }

        // Animate piece movement
        function animateMove(fromSquare, toSquare, pieceImage) {
            // Create a temporary piece for animation with exact same styling
            const tempPiece = document.createElement('div');
            tempPiece.className = 'chess-piece';
            tempPiece.style.backgroundImage = `url('pieces/${pieceImage}')`;
            tempPiece.style.backgroundSize = 'contain';
            tempPiece.style.backgroundRepeat = 'no-repeat';
            tempPiece.style.backgroundPosition = 'center';
            tempPiece.style.position = 'absolute';
            tempPiece.style.zIndex = '1000';
            tempPiece.style.pointerEvents = 'none';
            tempPiece.style.width = '60px';
            tempPiece.style.height = '60px';
            tempPiece.style.transition = 'all 0.3s ease-in-out';
            
            // Get the chess board container
            const board = document.getElementById('chess-board');
            const boardRect = board.getBoundingClientRect();
            
            // Get positions relative to the board
            const fromRect = fromSquare.getBoundingClientRect();
            const toRect = toSquare.getBoundingClientRect();
            
            // Position the temp piece at the source (relative to board)
            tempPiece.style.left = (fromRect.left - boardRect.left) + 'px';
            tempPiece.style.top = (fromRect.top - boardRect.top) + 'px';
            
            // Add to board with relative positioning
            board.style.position = 'relative';
            board.appendChild(tempPiece);
            
            // Animate to destination
            requestAnimationFrame(() => {
                tempPiece.style.left = (toRect.left - boardRect.left) + 'px';
                tempPiece.style.top = (toRect.top - boardRect.top) + 'px';
            });
            
            // Clean up after animation
            setTimeout(() => {
                if (tempPiece.parentNode) {
                    tempPiece.parentNode.removeChild(tempPiece);
                }
            }, 350);
        }

        function applyMove(move, animate = false, enableSound = true) {
            if (!move.white && !move.black) return;

            const moveNotation = move.white || move.black;
            const isWhiteMove = !!move.white;
            
            console.log('Applying move:', moveNotation, 'isWhite:', isWhiteMove);
            
            // Parse the move - use puzzle-specific parsing if it's a puzzle
            let parsedMove;
            if (currentGame.type === 'puzzle') {
                parsedMove = parsePuzzleMove(move, moveNotation, isWhiteMove);
            } else {
                // Parse the move using the universal parser for games
                parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
                console.log('Parsed game move:', parsedMove);
            }
            
            if (parsedMove.isCastling) {
                applyCastling(parsedMove, animate, enableSound);
                } else {
                const pieceImage = moveParser.getPieceImage(parsedMove.piece, isWhiteMove);
                movePiece(parsedMove.source, parsedMove.target, pieceImage, animate, enableSound);
                
                // Update piece positions in the parser
                moveParser.updatePiecePosition(parsedMove.piece, parsedMove.source, parsedMove.target, isWhiteMove);
            }
        }
        
        function applyCastling(parsedMove, animate = false, enableSound = true) {
            const { source, target, isWhite, isLong } = parsedMove;
            
            // Move the king
            const kingImage = moveParser.getPieceImage('K', isWhite);
            movePiece(source, target, kingImage, animate, enableSound);
            
            // Move the rook
            const rookSource = isLong ? (isWhite ? 'a1' : 'a8') : (isWhite ? 'h1' : 'h8');
            const rookTarget = isLong ? (isWhite ? 'd1' : 'd8') : (isWhite ? 'f1' : 'f8');
            const rookImage = moveParser.getPieceImage('R', isWhite);
            movePiece(rookSource, rookTarget, rookImage, animate, enableSound);
            
            // Update piece positions
            moveParser.updatePiecePosition('K', source, target, isWhite);
            moveParser.updatePiecePosition('R', rookSource, rookTarget, isWhite);
        }

        function movePiece(from, to, piece, animate = false, enableSound = true) {
            // Start training timer on piece movement
            progressTracker.startTrainingTimer();
            
            const fromSquare = getSquareByNotation(from);
            const toSquare = getSquareByNotation(to);
            
            if (fromSquare && toSquare) {
                // Check if there's a piece being captured
                const isCapture = toSquare.innerHTML.trim() !== '';
                
                if (animate) {
                    // Animate the move
                    animateMove(fromSquare, toSquare, piece);
                    // Update the board after animation
                    setTimeout(() => {
                        // Ensure board is in dragging state to disable transitions
                        const board = document.getElementById('chess-board');
                        board.classList.add('dragging');
                        
                        fromSquare.innerHTML = '';
                        toSquare.innerHTML = ''; // Clear destination square
                        const pieceElement = createDraggablePiece(piece, to);
                        toSquare.appendChild(pieceElement);
                        
                        // Remove dragging class after a short delay to re-enable transitions
                        setTimeout(() => {
                            board.classList.remove('dragging');
                        }, 50);
                        
                        // Play sound after animation completes
                        if (enableSound) playSound(isCapture);
                    }, 300);
                } else {
                    // Ensure board is in dragging state to disable transitions
                    const board = document.getElementById('chess-board');
                    board.classList.add('dragging');
                    
                    // Direct move without animation
                    fromSquare.innerHTML = '';
                    toSquare.innerHTML = ''; // Clear destination square
                    const pieceElement = createDraggablePiece(piece, to);
                    toSquare.appendChild(pieceElement);
                    
                    // Remove dragging class after a short delay to re-enable transitions
                    setTimeout(() => {
                        board.classList.remove('dragging');
                    }, 50);
                    
                    // Play sound immediately
                    if (enableSound) playSound(isCapture);
                }
            }
        }

        function getSquareByNotation(notation) {
            const board = document.getElementById('chess-board');
            
            // Use data-square attribute to find the correct square
            // This works regardless of board orientation since squares are labeled correctly
            return board.querySelector(`[data-square="${notation}"]`);
        }

        function updateMoveButtons() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                updateCustomMoveButtons();
                return;
            }
            
            const btnInitial = document.getElementById('btn-initial');
            const btnBack = document.getElementById('btn-back');
            const btnForward = document.getElementById('btn-forward');
            const btnFinal = document.getElementById('btn-final');

            if (!currentGame) {
                btnInitial.classList.add('disabled');
                btnBack.classList.add('disabled');
                btnForward.classList.add('disabled');
                btnFinal.classList.add('disabled');
                return;
            }

            // Update disabled states
            if (currentMoveIndex === 0) {
                btnInitial.classList.add('disabled');
                btnBack.classList.add('disabled');
            } else {
                btnInitial.classList.remove('disabled');
                btnBack.classList.remove('disabled');
            }

            if (currentMoveIndex >= currentGame.moves_detailed.length) {
                btnForward.classList.add('disabled');
                btnFinal.classList.add('disabled');
            } else {
                btnForward.classList.remove('disabled');
                btnFinal.classList.remove('disabled');
            }
        }

        // Visual mode functions (placeholder - no functionality yet)
        function switchVisualMode(mode) {
            currentVisualMode = mode;
            
            // Update active option
            const options = document.querySelectorAll('.mode-option');
            options.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.mode === mode) {
                    option.classList.add('active');
                }
            });
            
            // Apply visual effects
            applyVisualMode(mode);
        }

        // Flip notation function
        function flipNotation() {
            // Flip the letters (a-h)
            const letters = document.querySelectorAll('.notation-letter');
            const letterTexts = Array.from(letters).map(letter => letter.textContent);
            const reversedLetters = letterTexts.reverse();
            
            letters.forEach((letter, index) => {
                letter.textContent = reversedLetters[index];
            });
            
            // Flip the numbers (1-8)
            const numbers = document.querySelectorAll('.notation-number');
            const numberTexts = Array.from(numbers).map(number => number.textContent);
            const reversedNumbers = numberTexts.reverse();
            
            numbers.forEach((number, index) => {
                number.textContent = reversedNumbers[index];
            });
        }

        // Reset board to standard orientation (white at bottom)
        function resetBoardOrientation() {
            if (boardFlipped) {
                boardFlipped = false;
                
                // Update button appearance
                const flipBtn = document.getElementById('flip-board-btn');
                flipBtn.classList.remove('flipped');
                
                // Reset the notation
                flipNotation();
                
                // Reinitialize the board with standard orientation
                initializeChessBoard();
            }
        }

        // Flip board function
        function flipBoard() {
            boardFlipped = !boardFlipped;
            
            // Update button appearance
            const flipBtn = document.getElementById('flip-board-btn');
            if (boardFlipped) {
                flipBtn.classList.add('flipped');
            } else {
                flipBtn.classList.remove('flipped');
            }
            
            // Flip the notation
            flipNotation();
            
            // Reinitialize the board with the new orientation
            initializeChessBoard();
            
            // If there's a current game, update the board position
            if (currentGame) {
                updateBoardPosition();
            } else {
                setupInitialPosition();
            }
            
            // Reinitialize drag and drop functionality
            reinitializeDragAndDrop();
        }

        function applyVisualMode(mode) {
            const pieces = document.querySelectorAll('.chess-piece');
            
            pieces.forEach(piece => {
                applyVisualModeToPiece(piece, mode);
            });
        }

        function applyVisualModeToPiece(piece, mode) {
            const currentPiece = piece.dataset.piece;
            
            // Store original piece type if not already stored
            if (!piece.dataset.originalPiece) {
                piece.dataset.originalPiece = currentPiece;
            }
            
            const originalPiece = piece.dataset.originalPiece;
            let newPiece = originalPiece; // Start with original piece
            
            switch(mode) {
                case 'grey':
                    // Switch all white pieces to black pieces
                    if (originalPiece.includes('lt45')) {
                        // White piece -> Black piece
                        newPiece = originalPiece.replace('lt45', 'dt45');
                    } else {
                        // Keep black pieces as black
                        newPiece = originalPiece;
                    }
                    piece.style.backgroundImage = `url('pieces/${newPiece}')`;
                    piece.style.opacity = '1';
                    // Reset background size to default
                    piece.style.backgroundSize = '';
                    piece.style.backgroundRepeat = '';
                    piece.style.backgroundPosition = '';
                    break;
                 case 'checkers':
                     // For checkers mode, use dot for all pieces
                     newPiece = 'images/dot.png';
                     piece.style.backgroundImage = `url('${newPiece}')`;
                     piece.style.opacity = '1';
                     piece.style.backgroundSize = '80%';
                     piece.style.backgroundRepeat = 'no-repeat';
                     piece.style.backgroundPosition = 'center';
                     break;
                case 'empty':
                    // Make pieces completely invisible
                    newPiece = originalPiece;
                    piece.style.backgroundImage = `url('pieces/${newPiece}')`;
                    piece.style.opacity = '0';
                    // Reset background size to default
                    piece.style.backgroundSize = '';
                    piece.style.backgroundRepeat = '';
                    piece.style.backgroundPosition = '';
                    break;
                case 'normal':
                default:
                    // Reset to original pieces with original colors
                    newPiece = originalPiece;
                    piece.style.backgroundImage = `url('pieces/${newPiece}')`;
                    piece.style.opacity = '1';
                    // Reset background size to default
                    piece.style.backgroundSize = '';
                    piece.style.backgroundRepeat = '';
                    piece.style.backgroundPosition = '';
                    break;
            }
            
            // Update the piece image if it changed
            if (newPiece !== currentPiece) {
                piece.dataset.piece = newPiece;
                // Handle both full paths and piece filenames
                if (newPiece.startsWith('images/') || newPiece.startsWith('pieces/')) {
                    piece.style.backgroundImage = `url('${newPiece}')`;
                } else {
                    piece.style.backgroundImage = `url('pieces/${newPiece}')`;
                }
            }
         }

         // Challenge mode functions
         function toggleChallengeMode() {
             const challengeBtn = document.getElementById('challenge-btn');
             const modeOptions = document.querySelectorAll('.mode-option');
             const moveControls = document.querySelector('.move-controls');
             const movesList = document.getElementById('moves-list');
             const commentSection = document.getElementById('comment-section');
             
             if (!isChallengeMode && !currentGame) {
                 return;
             }
             
             if (!isChallengeMode) {
                 // Start challenge mode
                 isChallengeMode = true;
                 challengeBtn.textContent = 'Exit';
                 challengeBtn.classList.add('active');
                 
                 // Hide visual mode options and navigation buttons
                 modeOptions.forEach(option => {
                     option.style.display = 'none';
                 });
                 if (moveControls) {
                 moveControls.style.display = 'none';
                 }
                 if (movesList) {
                     movesList.style.display = 'block';
                 }
                 if (commentSection) {
                     commentSection.style.display = 'none';
                 }
                 
                // Reset to initial position
                currentMoveIndex = 0;
                setupInitialPosition();
                updateMoveButtons();
                
                // Update moves display to show only completed moves (none initially)
                updateChallengeMovesDisplay();
                 
                // Make all pieces invisible
                const pieces = document.querySelectorAll('.chess-piece');
                pieces.forEach(piece => {
                    piece.style.opacity = '0';
                });
                 
                 console.log('Challenge mode started! Replay the game from memory.');
             } else {
                 // Exit challenge mode
                 isChallengeMode = false;
                 challengeBtn.textContent = 'Test';
                 challengeBtn.classList.remove('active');
                 
                 // Show visual mode options and navigation buttons
                 modeOptions.forEach(option => {
                     option.style.display = 'flex';
                 });
                 if (moveControls) {
                 moveControls.style.display = 'flex';
                 }
                 if (movesList) {
                     movesList.style.display = 'block';
                 }
                 if (commentSection) {
                     commentSection.style.display = 'block';
                 }
                 
                 // Reset to initial position
                 currentMoveIndex = 0;
                 setupInitialPosition();
                 updateMoveButtons();
                 highlightCurrentMove();
                 
                 // Reset visual mode to normal
                 currentVisualMode = 'normal';
                 applyVisualMode('normal');
                 
                 // Restore full moves display
                 displayGameMoves(currentGame);
                 
                 console.log('Challenge mode exited!');
             }
         }
         
         function updateChallengeMovesDisplay() {
             if (!isChallengeMode || !currentGame) return;
             
             const movesList = document.getElementById('moves-list');
             if (!movesList) return;
             
             // Clear existing moves
             movesList.innerHTML = '';
             
             // Group moves by move number, but only show completed moves
             const moveGroups = {};
             const completedMoves = Math.floor(currentMoveIndex / 2);
             const isWhiteMoveCompleted = currentMoveIndex % 2 === 1;
             
             for (let i = 0; i < currentMoveIndex; i++) {
                 const move = currentGame.moves_detailed[i];
                 const moveNumber = Math.floor(i / 2) + 1;
                 
                 if (!moveGroups[moveNumber]) {
                     moveGroups[moveNumber] = {};
                 }
                 
                 if (i % 2 === 0) {
                     moveGroups[moveNumber].white = move.white || move.black;
                 } else {
                     moveGroups[moveNumber].black = move.white || move.black;
                 }
             }
             
             // Create the moves display (only completed moves)
             if (Object.keys(moveGroups).length > 0) {
                 const moveItem = document.createElement('div');
                 moveItem.className = 'move-item';
                 
                 Object.keys(moveGroups).forEach((moveNumber, moveIndex) => {
                     const group = moveGroups[moveNumber];
                     
                     const moveRow = document.createElement('div');
                     moveRow.className = 'move-row';
                     
                     const moveNumberSpan = document.createElement('span');
                     moveNumberSpan.textContent = moveNumber + '.';
                     moveNumberSpan.className = 'move-number';
                     moveRow.appendChild(moveNumberSpan);
                     
                     const whiteMoves = document.createElement('div');
                     whiteMoves.className = 'white-moves';
                     
                     const blackMoves = document.createElement('div');
                     blackMoves.className = 'black-moves';
                     
                     if (group.white) {
                         const whiteMoveSpan = document.createElement('span');
                         whiteMoveSpan.textContent = convertToChessSymbols(group.white);
                         whiteMoveSpan.className = 'clickable-move';
                         whiteMoves.appendChild(whiteMoveSpan);
                     }
                     
                     if (group.black) {
                         const blackMoveSpan = document.createElement('span');
                         blackMoveSpan.textContent = convertToChessSymbols(group.black);
                         blackMoveSpan.className = 'clickable-move';
                         blackMoves.appendChild(blackMoveSpan);
                     }
                     
                     moveRow.appendChild(whiteMoves);
                     moveRow.appendChild(blackMoves);
                     moveItem.appendChild(moveRow);
                 });
                 
                 movesList.appendChild(moveItem);
             } else {
                 // Hide the moves list when no moves have been played yet
                 movesList.style.display = 'none';
             }
         }
         
        function checkChallengeProgress() {
            console.log('checkChallengeProgress called - isChallengeMode:', isChallengeMode, 'currentGame:', !!currentGame, 'currentMoveIndex:', currentMoveIndex, 'totalMoves:', currentGame ? currentGame.moves_detailed.length : 0);
            if (!isChallengeMode || !currentGame) {
                console.log('checkChallengeProgress: Not in challenge mode or no current game');
                return;
            }
            
            // Update the moves display to show progress
            updateChallengeMovesDisplay();
            
            // Check if user completed the entire puzzle
            // Use the same logic as games: completion when all moves are completed
            console.log('checkChallengeProgress - Checking completion - currentMoveIndex:', currentMoveIndex, 'totalMoves:', currentGame.moves_detailed.length);
            if (currentMoveIndex >= currentGame.moves_detailed.length) {
                console.log('*** PUZZLE COMPLETED IN checkChallengeProgress! Calling showCompletionBadge ***');
                showCompletionBadge();
            } else {
                console.log('Puzzle not completed yet in checkChallengeProgress - currentMoveIndex:', currentMoveIndex, 'totalMoves:', currentGame.moves_detailed.length);
            }
        }

         function showCompletionBadge() {
             console.log('*** showCompletionBadge called ***');
             const badge = document.getElementById('completion-badge');
             const overlay = document.getElementById('badge-overlay');
             
             console.log('Badge element:', badge);
             console.log('Overlay element:', overlay);
             
             if (!badge) {
                 console.error('Completion badge element not found!');
                 return;
             }
             if (!overlay) {
                 console.error('Badge overlay element not found!');
                 return;
             }
             
             // Mark this game as completed
             if (currentGame) {
                 console.log('Adding puzzle to completedChallenges:', currentGame.id);
                 completedChallenges.add(currentGame.id);
                 console.log('completedChallenges after adding:', completedChallenges);
                 
                 // Record completion in progress tracker
                 // Use recordGameCompletion for both games and puzzles since it's the only completion recording function
                 const difficulty = currentGame.difficulty || 'intermediate';
                 progressTracker.recordGameCompletion(difficulty, currentGame.id);
                 
                 // End the current training session
                 progressTracker.endSession();
                 
                 console.log('Game completed! Progress updated:', progressTracker.getProgressSummary());
             }
             
             // Update badges in games list
             console.log('About to call updateGameListBadges()');
             updateGameListBadges();
            
            // Trigger confetti celebration
            createConfetti();
             
             // Show overlay and badge with animation
             overlay.classList.add('show');
             setTimeout(() => {
                 badge.classList.add('show');
             }, 100);
         }

         function hideBadge() {
             const badge = document.getElementById('completion-badge');
             const overlay = document.getElementById('badge-overlay');
             
             // Switch to normal mode to reveal all pieces
             currentVisualMode = 'normal';
             switchVisualMode('normal');
             
             // Hide badge and overlay
             badge.classList.remove('show');
             setTimeout(() => {
                 overlay.classList.remove('show');
                 // Exit challenge mode after hiding badge
                 toggleChallengeMode();
             }, 300);
         }


         function updateGameListBadges() {
             // Refresh completed challenges from progress tracker
             completedChallenges = loadCompletedChallenges();
             console.log('*** updateGameListBadges called ***');
             console.log('Completed challenges:', completedChallenges);
             
             // Update badges in the games list sidebar
             const badges = document.querySelectorAll('.game-completion-badge');
             console.log('Found badges:', badges.length);
             console.log('Badges found:', badges);
             console.log('Current game ID:', currentGame ? currentGame.id : 'no current game');
             console.log('Completed challenges set:', Array.from(completedChallenges));
             badges.forEach((badge, index) => {
                 const gameId = badge.dataset.game;
                 const isCompleted = completedChallenges.has(gameId);
                 console.log(`Badge ${index} for game ${gameId}: completed = ${isCompleted}`);
                 console.log(`Badge element:`, badge);
                 console.log(`Badge dataset:`, badge.dataset);
                 if (isCompleted) {
                     console.log(`Adding 'show' class to badge for ${gameId}`);
                     badge.classList.add('show');
                     console.log(`Badge classes after adding 'show':`, badge.classList.toString());
                     console.log(`Badge style after adding 'show':`, badge.style.cssText);
                 } else {
                     console.log(`Removing 'show' class from badge for ${gameId}`);
                     badge.classList.remove('show');
                 }
             });
         }

         // Toggle moves visibility
         function toggleMovesVisibility() {
             const movesList = document.getElementById('moves-list');
             const toggleImg = document.getElementById('moves-toggle-img');
             
             if (movesList.style.display === 'none') {
                 movesList.style.display = 'block';
                 toggleImg.src = 'images/hide.png';
                 toggleImg.title = 'Hide moves';
             } else {
                 movesList.style.display = 'none';
                 toggleImg.src = 'images/view.png';
                 toggleImg.title = 'Show moves';
             }
         }

         document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing...');

            // Initialize chess board
            initializeChessBoard();
            setupInitialPosition();
            reinitializeDragAndDrop(); // Ensure click handlers are attached to initial pieces
            
            // Add event listener for moves toggle
            const toggleImg = document.getElementById('moves-toggle-img');
            if (toggleImg) {
                toggleImg.addEventListener('click', toggleMovesVisibility);
            }
            
            // Hide custom game elements on initial load
            if (typeof hideCustomGameInfo === 'function') {
                hideCustomGameInfo();
            }
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }

            // Set up submenu toggles for all tabs
            const gameButtonIds = [
                'short-games-btn', 'gm-games-short-games-btn',
                'medium-games-btn', 'gm-games-medium-games-btn',
                'long-games-btn', 'gm-games-long-games-btn',
                'epic-games-btn', 'gm-games-epic-games-btn'
            ];
            
            const submenuIds = [
                'short-games-submenu', 'gm-games-short-games-submenu',
                'medium-games-submenu', 'gm-games-medium-games-submenu',
                'long-games-submenu', 'gm-games-long-games-submenu',
                'epic-games-submenu', 'gm-games-epic-games-submenu'
            ];
            
            gameButtonIds.forEach((buttonId, index) => {
                const button = document.getElementById(buttonId);
                const submenu = document.getElementById(submenuIds[index]);
                
                if (button && submenu) {
                    button.addEventListener('click', function(e) {
                e.preventDefault();
                        console.log('Game button clicked:', buttonId);
                        
                        // Close all other submenus first
                        submenuIds.forEach((submenuId, submenuIndex) => {
                            if (submenuIndex !== index) {
                                const otherSubmenu = document.getElementById(submenuId);
                                const otherButton = document.getElementById(gameButtonIds[submenuIndex]);
                                if (otherSubmenu && otherButton) {
                                    otherSubmenu.classList.remove('show');
                                    otherButton.classList.remove('active');
                                }
                            }
                        });
                        
                        // Toggle the current submenu
                        if (submenu.classList.contains('show')) {
                            submenu.classList.remove('show');
                            button.classList.remove('active');
                } else {
                            submenu.classList.add('show');
                            button.classList.add('active');
                        }
                    });
                }
            });

            // Game submenu button clicks
            const submenuButtons = document.querySelectorAll('.submenu-button');
            console.log('Found submenu buttons:', submenuButtons.length);
            
            submenuButtons.forEach(button => {
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    const gameId = this.getAttribute('href').substring(1);
                    console.log('Button clicked, gameId:', gameId);
                    displayGame(gameId);
                });
            });


            // Move navigation button event listeners
            document.getElementById('btn-initial').addEventListener('click', goToInitialPosition);
            document.getElementById('btn-back').addEventListener('click', goToPreviousMove);
            document.getElementById('btn-forward').addEventListener('click', goToNextMove);
            document.getElementById('btn-final').addEventListener('click', goToFinalPosition);

            // Visual mode option event listeners
            const modeOptions = document.querySelectorAll('.mode-option');
            modeOptions.forEach(option => {
                option.addEventListener('click', function() {
                    const mode = this.dataset.mode;
                    switchVisualMode(mode);
                });
            });

            // Flip board button event listener
            document.getElementById('flip-board-btn').addEventListener('click', flipBoard);

            // Challenge button event listener
            const challengeBtn = document.getElementById('challenge-btn');
            challengeBtn.addEventListener('click', function() {
                toggleChallengeMode();
            });


            // Initialize move buttons as disabled
            updateMoveButtons();
            
            // Initialize game list badges
            updateGameListBadges();
        });
    </script>

    <!-- Sign In Modal -->
    <div id="signInModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Sign In</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <form id="signInForm" onsubmit="handleSignIn(event)">
                <div class="form-group">
                    <label class="form-label" for="signInEmail">Email</label>
                    <input type="email" id="signInEmail" class="form-input" placeholder="Enter your email" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="signInPassword">Password</label>
                    <input type="password" id="signInPassword" class="form-input" placeholder="Enter your password" required>
                </div>
            <div class="modal-buttons">
                <button type="submit" class="btn-modal btn-primary">Sign In</button>
                <button type="button" class="btn-modal btn-secondary" onclick="closeModal()">Cancel</button>
            </div>
        </form>
        <div class="google-signup">
            <button type="button" class="btn-modal btn-google" onclick="signInWithGoogle()">
                <div class="google-icon"></div>
                Sign in with Google
            </button>
        </div>
        <div class="register-link">
            <p>Don't have an account yet? <a href="#" onclick="showRegisterModal()">Register here</a></p>
        </div>
        </div>
    </div>

    <!-- Register Modal -->
    <div id="registerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Create Account</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <form id="registerForm" onsubmit="handleRegister(event)">
                <div class="form-group">
                    <label class="form-label" for="registerEmail">Email</label>
                    <input type="email" id="registerEmail" class="form-input" placeholder="Enter your email" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="registerPassword">Password</label>
                    <input type="password" id="registerPassword" class="form-input" placeholder="Create a password" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="registerName">Full Name</label>
                    <input type="text" id="registerName" class="form-input" placeholder="Enter your full name" required>
                </div>
                <div class="modal-buttons">
                    <button type="submit" class="btn-modal btn-primary">Create Account</button>
                    <button type="button" class="btn-modal btn-secondary" onclick="closeModal()">Cancel</button>
                </div>
            </form>
            <div class="google-signup">
                <button type="button" class="btn-modal btn-google" onclick="registerWithGoogle()">
                    <div class="google-icon"></div>
                    Register with Google
                </button>
            </div>
        </div>
    </div>

    <!-- Logout Confirmation Modal -->
    <div id="logoutConfirmModal" class="logout-confirm-modal">
        <div class="logout-confirm-content">
            <div class="logout-confirm-header">
                <h2>Confirm Logout</h2>
            </div>
            <div class="logout-confirm-message">
                Are you sure you want to log out? You'll need to sign in again to access your account.
            </div>
            <div class="logout-confirm-buttons">
                <button class="btn-logout-confirm btn-logout-yes" onclick="confirmLogout()">Yes, Logout</button>
                <button class="btn-logout-confirm btn-logout-no" onclick="cancelLogout()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Subscription Required Modal -->
    <div id="subscriptionRequiredModal" class="subscription-required-modal">
        <div class="subscription-required-content">
            <div class="subscription-required-header">
                <h2>🔒 Subscription Required</h2>
            </div>
            <div class="subscription-required-message">
                This content is locked and requires a premium subscription to access. Upgrade your account to unlock all games.
            </div>
            <div class="subscription-required-buttons">
                <button class="btn-subscription-required btn-subscription-yes" onclick="goToSubscription()">Get Subscription</button>
                <button class="btn-subscription-required btn-subscription-no" onclick="closeSubscriptionModal()">Cancel</button>
            </div>
        </div>
    </div>
</body>
</html>
