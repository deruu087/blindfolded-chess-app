<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blind Chess</title>
    <script>
        // Check subscription status immediately to prevent flashing
        (function() {
            const hasActiveSubscription = localStorage.getItem('hasActiveSubscription') === 'true';
            if (hasActiveSubscription) {
                // Add CSS to hide subscription tab for subscribers
                const style = document.createElement('style');
                style.textContent = '.subscription-tab-li { display: none !important; }';
                document.head.appendChild(style);
            }
        })();
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
        }

        .navbar {
            background-color: #2c3e50;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .logo {
            display: flex;
            align-items: center;
            color: #ecf0f1;
            font-size: 1.5rem;
            font-weight: bold;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        .logo:hover {
            color: #3498db;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            margin-right: 10px;
            background-color: #ecf0f1;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .nav-links {
            display: flex;
            list-style: none;
            gap: 2rem;
            align-items: center;
        }

        .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            font-weight: 500;
            font-size: 1.1rem;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
        }

        .nav-links a:hover {
            background-color: #34495e;
        }

        /* Profile Dropdown Styles */
        .profile-dropdown {
            position: relative;
        }

        .profile-icon {
            display: flex;
            align-items: center;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-size: 1rem;
            font-weight: 500;
        }

        .profile-icon:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .profile-avatar {
            font-size: 1.2rem;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
        }

        .profile-avatar img {
            border-radius: 50%;
            background: white;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 180px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 1000;
            border: 1px solid #e9ecef;
        }

        .profile-dropdown:hover .dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            color: #1a1a1a;
            text-decoration: none;
            transition: all 0.2s ease;
            border-bottom: 1px solid #f8f9fa;
            width: 100%;
            box-sizing: border-box;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background-color: transparent !important;
            color: #1a1a1a !important;
            transform: translateX(2px);
        }
        
        /* Initially hide subscription tab only for users with active subscription */
        .subscription-tab-li {
            display: block; /* Show by default for free users */
        }
        
        /* Hide only if user has active subscription (set by JavaScript) */
        .subscription-tab-li.hidden-for-subscriber {
            display: none;
        }

        .dropdown-icon {
            font-size: 1rem;
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }

        .dropdown-text {
            font-size: 0.9rem;
            font-weight: 500;
            color: #1a1a1a;
        }

        .nav-links a.active {
            background-color: #3498db;
            color: #ffffff;
        }

        .main-layout {
            display: flex;
            min-height: calc(100vh - 60px);
            justify-content: center;
            align-items: flex-start;
            padding: 0.5rem 0 2rem 0;
        }

        .game-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 1.5rem 1rem;
            width: 280px;
            background-color: #f8f9fa;
            border-right: 1px solid #dee2e6;
        }

        .game-button {
            background-color: #ffffff;
            border: 2px solid #bdc3c7;
            border-radius: 12px;
            padding: 1rem;
            text-decoration: none;
            color: #2c3e50;
            text-align: center;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            width: 100%;
        }

        .game-button:hover {
            border-color: #3498db;
            background-color: #f8f9fa;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .submenu-button.locked {
            position: relative;
            cursor: not-allowed;
        }

        .submenu-button.locked:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            background-color: #ffffff;
            margin: 5% auto;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            position: relative;
            animation: slideIn 0.3s ease;
        }

        .modal-header {
            margin-bottom: 1.5rem;
            position: relative;
        }

        .modal-header h2 {
            margin: 0;
            color: #2c3e50;
            font-size: 1.25rem;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            color: #2c3e50;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1rem;
            box-sizing: border-box;
        }

        .form-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .btn-modal {
            flex: 1;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background-color: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background-color: #2980b9;
        }

        .btn-secondary {
            background-color: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #7f8c8d;
        }

        .account-info {
            padding: 1rem 0;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid #f8f9fa;
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .info-item label {
            font-weight: 600;
            color: #2c3e50 !important;
            min-width: 100px;
        }

        .info-item span {
            color: #7f8c8d !important;
            text-align: right;
        }

        .register-link {
            text-align: center;
            margin-top: 1rem;
        }

        .register-link a {
            color: #3498db;
            text-decoration: none;
        }

        .register-link a:hover {
            text-decoration: underline;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
        }

        .close:hover {
            color: #000;
        }

        /* Logout Confirmation Modal */
        .logout-confirm-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s ease;
        }

        .logout-confirm-content {
            background-color: #ffffff;
            margin: 15% auto;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            position: relative;
            animation: slideIn 0.3s ease;
            text-align: center;
        }

        .logout-confirm-header {
            margin-bottom: 1.5rem;
        }

        .logout-confirm-header h2 {
            margin: 0;
            color: #2c3e50;
            font-size: 1.25rem;
            font-weight: 600;
        }

        .logout-confirm-message {
            color: #7f8c8d;
            margin-bottom: 2rem;
            line-height: 1.5;
        }

        .logout-confirm-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .btn-logout-confirm {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .btn-logout-yes {
            background-color: #e74c3c;
            color: white;
        }

        .btn-logout-yes:hover {
            background-color: #c0392b;
        }

        .btn-logout-no {
            background-color: #95a5a6;
            color: white;
        }

        .btn-logout-no:hover {
            background-color: #7f8c8d;
        }

        /* Subscription Required Modal */
        .subscription-required-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s ease;
        }

        .subscription-required-content {
            background-color: #ffffff;
            margin: 15% auto;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 450px;
            position: relative;
            animation: slideIn 0.3s ease;
        }

        .subscription-required-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .subscription-required-header h2 {
            color: #2c3e50;
            margin: 0;
            font-size: 1.5rem;
        }

        .subscription-required-message {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .subscription-required-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .btn-subscription-required {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .btn-subscription-yes {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .btn-subscription-yes:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        .btn-subscription-no {
            background: #95a5a6;
            color: white;
        }

        .btn-subscription-no:hover {
            background: #7f8c8d;
        }

        .google-signup {
            margin-top: 1rem;
            text-align: center;
        }

        .btn-google {
            background-color: #ffffff;
            color: #333;
            border: 1px solid #dadce0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: box-shadow 0.2s;
            width: 100%;
        }

        .btn-google:hover {
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .google-icon {
            width: 20px;
            height: 20px;
            background: url('images/google.png') no-repeat center;
            background-size: contain;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .lock-overlay {
            position: absolute;
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #7f8c8d;
            font-weight: bold;
            z-index: 10;
        }

        .lock-icon {
            font-size: 1.5rem;
            margin-bottom: 0.25rem;
        }

        .lock-text {
            font-size: 0.7rem;
            text-align: center;
        }

        .game-button.active {
            border-color: #3498db;
            background-color: #e3f2fd;
            color: #2980b9;
        }

        .game-button .description {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-top: 0.5rem;
            font-weight: 400;
        }

        .game-button-container {
            display: flex;
            flex-direction: column;
        }

        .game-button-container .game-button {
            background-color: #ffffff;
            border: 2px solid #bdc3c7;
            border-radius: 12px;
            padding: 1rem;
            text-decoration: none;
            color: #2c3e50;
            text-align: center;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            width: 100%;
        }

        .game-button-container .game-button:hover {
            border-color: #3498db;
            background-color: #f8f9fa;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .game-button-container .game-button.active {
            border-color: #3498db;
            background-color: #e3f2fd;
            color: #2980b9;
        }

        .submenu {
            display: none;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
            padding-left: 1rem;
            animation: slideDown 0.3s ease-out;
        }

        .submenu.show {
            display: flex;
        }

        .submenu-button {
            background-color: #e9ecef;
            border: 1px solid #ced4da;
            border-radius: 8px;
            padding: 0.75rem;
            text-decoration: none;
            color: #495057;
            text-align: center;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .submenu-button:hover {
            background-color: #dee2e6;
            border-color: #adb5bd;
            transform: translateX(5px);
        }

        .submenu-button.selected {
            transform: translateX(6px) !important;
            background-color: #e3f2fd !important;
            border: 1px solid #2196f3 !important;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2) !important;
            font-weight: normal !important;
            color: #1976d2 !important;
        }

        .submenu-button.selected:hover {
            background-color: #e3f2fd !important;
            border-color: #2196f3 !important;
            transform: translateX(6px) !important;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2) !important;
        }

        .game-completion-badge {
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%) scale(0);
            opacity: 0;
            transition: all 0.15s ease;
            z-index: 10;
        }

        .game-completion-badge.show {
            opacity: 1;
            transform: translateY(-50%) scale(1);
        }

        .game-completion-badge:hover::after {
            content: "Memory challenge completed";
            position: absolute;
            bottom: 100%;
            right: 0;
            background-color: #333;
            color: white;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            margin-bottom: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .game-completion-badge:hover::before {
            content: "";
            position: absolute;
            bottom: 100%;
            right: 8px;
            border: 4px solid transparent;
            border-top-color: #333;
            z-index: 1000;
            margin-bottom: -4px;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .game-display {
            display: block;
            padding: 1rem 2rem;
        }

        .game-display.show {
            display: block;
        }

        .game-content {
            display: flex;
            gap: 3.5rem;
            align-items: flex-start;
            justify-content: center;
            width: 100%;
            max-width: 1000px;
        }

        .board-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
        }

         .visual-modes {
             display: flex;
             flex-direction: row;
             gap: 1rem;
             justify-content: center;
             align-items: center;
             padding: 1rem;
             background-color: #f8f9fa;
             border-radius: 12px;
             border: 2px solid #dee2e6;
             box-shadow: 0 4px 12px rgba(0,0,0,0.1);
             width: 520px;
         }


        .mode-option {
            background-color: #ffffff;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            color: #495057;
            transition: all 0.2s ease;
            text-align: center;
            min-height: 40px;
            min-width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mode-option:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-1px);
        }

        .mode-option.active {
            background-color: #3498db;
            border-color: #2980b9;
            color: white;
        }

        .mode-option.active:hover {
            background-color: #2980b9;
            transform: translateY(-1px);
        }


        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 520px;
            height: 520px;
            border: 3px solid #2c3e50;
            border-radius: 10px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.25);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 6px;
            position: relative;
        }

        .chess-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            border-radius: 4px;
            width: 100%;
            height: 100%;
            min-width: 0;
            min-height: 0;
        }

        
        .chess-board.dragging .chess-piece {
            transition: none !important;
            animation: none !important;
            transform: none !important;
        }
        
        .board-notation {
            display: flex;
            width: 502px;
            margin: 5px auto 0 auto;
            justify-content: space-between;
        }
        
        .notation-letter {
            width: 62.75px;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            color: #000000;
            padding: 5px 0;
            box-sizing: border-box;
        }
        
        .rank-notation {
            display: flex;
            flex-direction: column;
            width: 47.5px;
            height: 502px;
            position: absolute;
            right: -40.5px;
            top: 7px;
            justify-content: space-between;
        }
        
        .notation-number {
            height: 62.75px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: #000000;
            box-sizing: border-box;
        }
        
        .chess-board.dragging .chess-square {
            transition: none !important;
            width: 100% !important;
            height: 100% !important;
            min-width: 0 !important;
            min-height: 0 !important;
        }

        /* Board coordinates styles */
        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .board-coordinates {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .chess-square.light {
            background: linear-gradient(135deg, #f0d9b5 0%, #e8d5b7 100%);
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
        }

        .chess-square.dark {
            background: linear-gradient(135deg, #b58863 0%, #a67c52 100%);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .chess-square:hover {
            background: linear-gradient(135deg, #ffeb3b 0%, #ffc107 100%);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(255,235,59,0.4);
            z-index: 10;
        }

        .chess-piece {
            width: 60px;
            height: 60px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transition: all 0.2s ease;
            cursor: grab;
        }
        
        .chess-piece.dragging {
            transition: none !important;
            transform: none !important;
            width: 60px !important;
            height: 60px !important;
        }
        
        .chess-piece.dragging:hover {
            transform: none !important;
            width: 60px !important;
            height: 60px !important;
        }

        .chess-piece:hover {
            transform: scale(1.1);
        }

        .chess-piece:active {
            cursor: grabbing;
        }

        .chess-square.valid-move {
            background-color: rgba(144, 238, 144, 0.3) !important;
            outline: 3px solid #32CD32;
            outline-offset: -3px;
        }
        
        .chess-board.dragging .chess-square.valid-move {
            background-color: rgba(144, 238, 144, 0.3) !important;
        }

        .chess-square.selected {
            background: #FFD700 !important;
            box-shadow: inset 0 2px 4px rgba(255, 215, 0, 0.5) !important;
        }

        .chess-square.selected.light {
            background: #FFD700 !important;
            box-shadow: inset 0 2px 4px rgba(255, 215, 0, 0.5) !important;
        }

        .chess-square.selected.dark {
            background: #FFD700 !important;
            box-shadow: inset 0 2px 4px rgba(255, 215, 0, 0.5) !important;
        }

        .moves-panel {
            width: 420px;
            background-color: #ffffff;
            margin-left: 30px;
            border: none;
            border-radius: 12px;
            padding: 1.25rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            max-height: 630px;
            overflow-y: auto;
            align-self: flex-start;
        }

        .game-header {
            background: #ffffff;
            color: #333333;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            border: 1px solid #e0e0e0;
            box-shadow: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .game-header:hover {
            background: #f5f5f5;
            border-color: #cccccc;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .game-header::after {
            content: '▼';
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.2s ease;
            font-size: 0.8rem;
            color: #666666;
        }

        .game-header.expanded::after {
            transform: translateY(-50%) rotate(180deg);
        }


        .game-title-line {
            font-size: 1rem;
            font-weight: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333333;
            text-align: center;
        }

        .move-count {
            font-size: 0.85rem;
            color: #666666;
            background: #e9ecef;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-weight: 400;
        }

        .move-count-left {
            font-size: 0.8rem;
            color: #7f8c8d;
            font-weight: 400;
            font-style: italic;
        }

        .game-title {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .game-info {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .game-details {
            background-color: #f8f9fa;
            border: none;
            border-radius: 0 0 6px 6px;
            margin-top: 0;
            max-height: 0;
            overflow: hidden;
            padding: 0 1rem;
            transition: max-height 0.4s ease, padding 0.4s ease, margin 0.4s ease;
        }

        .game-details.show {
            max-height: 600px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e9ecef;
        }

        .detail-item:last-child {
            border-bottom: none;
        }

        .detail-label {
            font-weight: bold;
            color: #2c3e50;
            font-size: 0.9rem;
            flex-shrink: 0;
            margin-right: 1rem;
        }

        .detail-value {
            color: #495057;
            font-size: 0.9rem;
            text-align: right;
            line-height: 1.4;
            flex: 1;
        }

        .detail-facts {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #dee2e6;
        }

        .facts-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .facts-text {
            color: #495057;
            font-size: 0.85rem;
            line-height: 1.4;
        }


        .move-controls {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .move-btn {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            color: #495057;
            transition: all 0.2s ease;
            min-width: 40px;
            text-align: center;
        }

        .move-btn:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-1px);
        }

        .move-btn:active {
            transform: translateY(0);
        }

        .move-btn:disabled {
            background-color: #f8f9fa;
            color: #adb5bd;
            cursor: not-allowed;
            transform: none;
        }

        .move-btn:disabled:hover {
            background-color: #f8f9fa;
            border-color: #dee2e6;
            transform: none;
        }

        .move-icon {
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #495057;
            user-select: none;
            width: 40px;
            height: 40px;
            flex-shrink: 0;
        }

        .move-icon:hover {
            background-color: #e9ecef;
            transform: translateY(-1px);
        }

        .move-icon:active {
            transform: translateY(0);
        }

        .move-icon.disabled {
            color: #adb5bd;
            cursor: not-allowed;
            transform: none;
        }

        .move-icon.disabled:hover {
            background-color: transparent;
            transform: none;
        }

          .visual-modes {
              display: flex;
              align-items: center;
              margin-top: 5px;
          }

          .mode-title {
              margin-right: 10px;
              margin-top: 4px;
          }


          .challenge-title {
              font-weight: bold;
              color: #2c3e50;
              font-size: 0.9rem;
              margin-right: 10px;
          }

          .challenge-btn {
              background-color: #ffffff;
              border: 2px solid #dee2e6;
              border-radius: 8px;
              padding: 0.75rem 1.5rem;
              cursor: pointer;
              font-size: 0.85rem;
              font-weight: 500;
              color: #495057;
              transition: all 0.2s ease;
              min-width: 120px;
              text-align: center;
              display: flex;
              align-items: center;
              justify-content: center;
          }

          .challenge-btn:hover {
              background-color: #e9ecef;
              border-color: #adb5bd;
              transform: translateY(-1px);
          }

          .challenge-btn.active {
              background-color: #dc3545;
              border-color: #c82333;
              color: white;
          }

          .test-btn {
              background: linear-gradient(135deg, #ff6b6b, #ee5a24);
              border: 2px solid #ee5a24;
              border-radius: 8px;
              padding: 0.75rem 1.5rem;
              cursor: pointer;
              font-size: 0.85rem;
              font-weight: 600;
              color: white;
              transition: all 0.2s ease;
              min-width: 80px;
              text-align: center;
              display: flex;
              align-items: center;
              justify-content: center;
              box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
          }

          .test-btn:hover {
              background: linear-gradient(135deg, #ee5a24, #d63031);
              border-color: #d63031;
              transform: translateY(-1px);
              box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
          }

          .test-btn.active {
              background: linear-gradient(135deg, #d63031, #a71e2e);
              border-color: #a71e2e;
              box-shadow: 0 2px 8px rgba(214, 48, 49, 0.4);
          }

          .test-btn.active:hover {
              background: linear-gradient(135deg, #a71e2e, #8b1538);
              border-color: #8b1538;
              transform: translateY(-1px);
          }

          .flip-board-icon {
              display: flex;
              align-items: center;
              justify-content: center;
              transition: all 0.2s ease;
          }

          .flip-board-icon:hover {
              transform: scale(1.1);
          }

          .flip-board-icon.flipped {
              transform: rotate(180deg);
          }

          .flip-board-icon.flipped:hover {
              transform: rotate(180deg) scale(1.1);
          }


          .completion-badge {
              position: fixed;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%) scale(0);
              background: #ffffff;
              color: #2c3e50;
              padding: 2.5rem 3rem;
              border-radius: 12px;
              box-shadow: 0 12px 24px rgba(0,0,0,0.15), 0 0 0 1px rgba(0,0,0,0.05);
              text-align: center;
              z-index: 9999;
              font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
              border: 2px solid #e8f5e8;
              transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
              max-width: 400px;
              backdrop-filter: blur(20px);
          }

          .completion-badge.show {
              transform: translate(-50%, -50%) scale(1);
          }

          .completion-badge .badge-icon {
              margin-bottom: 1.5rem;
              text-align: center;
              animation: bounce 1s infinite;
              filter: drop-shadow(0 2px 4px rgba(40, 167, 69, 0.2));
          }

          .completion-badge .badge-title {
              font-size: 1.75rem;
              font-weight: 700;
              margin-bottom: 0.75rem;
              color: #2c3e50;
              letter-spacing: -0.5px;
          }

          .completion-badge .badge-subtitle {
              font-size: 1rem;
              color: #7f8c8d;
              margin-bottom: 2rem;
              line-height: 1.5;
              font-weight: 400;
          }

          .completion-badge .badge-close {
              background: linear-gradient(135deg, #3498db, #2980b9);
              border: 2px solid #3498db;
              color: white;
              padding: 0.75rem 2rem;
              border-radius: 8px;
              cursor: pointer;
              font-size: 0.95rem;
              font-weight: 600;
              transition: all 0.2s ease;
              font-family: inherit;
              box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
          }

          .completion-badge .badge-close:hover {
              background: linear-gradient(135deg, #2980b9, #21618c);
              border-color: #2980b9;
              transform: translateY(-1px);
              box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
          }

          .badge-overlay {
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: rgba(44, 62, 80, 0.85);
              backdrop-filter: blur(4px);
              z-index: 9998;
              opacity: 0;
              transition: all 0.3s ease;
              pointer-events: none;
          }

          .badge-overlay.show {
              opacity: 1;
              pointer-events: all;
          }

          @keyframes bounce {
              0%, 20%, 50%, 80%, 100% {
                  transform: translateY(0);
              }
              40% {
                  transform: translateY(-10px);
              }
              60% {
                  transform: translateY(-5px);
              }
          }

          .moves-title {
            font-size: 1.2rem;
            color: #2c3e50;
            margin-bottom: 1rem;
            text-align: center;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 0.5rem;
        }

        .move-item {
            padding: 0.25rem 0.5rem;
            background-color: #fff;
            border: none;
            margin-bottom: 0.1rem;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            color: #495057;
            transition: background-color 0.2s ease;
            user-select: none;
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
        }


        .move-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-height: 1rem;
            padding: 0.1rem 0;
        }

        .move-number {
            font-weight: bold;
            color: #6c757d;
            font-size: 0.9rem;
            min-width: 1.5rem;
            text-align: center;
        }

        .white-moves {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
            padding: 0.3rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .black-moves {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
            justify-content: flex-start;
            padding: 0.3rem 0.3rem 0.3rem 1.3rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .clickable-move {
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: background-color 0.2s ease;
            display: inline-block;
            font-size: 1rem;
            font-weight: normal;
        }

        .white-moves:hover .clickable-move {
            background-color: #f8f9fa;
        }

        .black-moves:hover .clickable-move {
            background-color: #f8f9fa;
        }

        .white-moves.clicked .clickable-move {
            background-color: #e3f2fd;
            color: #1976d2;
        }

        .black-moves.clicked .clickable-move {
            background-color: #e3f2fd;
            color: #1976d2;
        }

        .clickable-move.active-move {
            font-weight: bold;
        }


        .moves-container {
            padding: 0.5rem;
            background-color: #fff;
            border-radius: 4px;
            border: 1px solid #e9ecef;
            margin-top: 0.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.125rem;
        }


        .main-content {
            flex: 1;
            padding: 1rem 2rem;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 1200px;
            width: 100%;
        }

        .main-content h1 {
            color: #2c3e50;
            margin-bottom: 1rem;
        }

        .main-content p {
            color: #7f8c8d;
            font-size: 1.1rem;
        }

        @media (max-width: 768px) {
            .navbar {
                padding: 0.5rem 1rem;
                flex-direction: column;
                gap: 0.5rem;
            }

            .nav-links {
                gap: 1rem;
            }

            .nav-links a {
                padding: 0.4rem 0.8rem;
                font-size: 0.9rem;
            }

            .main-content {
                padding: 0.5rem 1rem;
            }

            .game-display {
                padding: 0.5rem 1rem;
            }

            .main-layout {
                flex-direction: column;
                align-items: center;
                padding: 0.25rem 0 1rem 0;
            }

            .game-buttons {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
                padding: 1rem;
                gap: 0.5rem;
            }

            .game-button {
                flex: 1;
                min-width: 120px;
                padding: 0.8rem 0.5rem;
                font-size: 0.9rem;
            }
        }
        
        /* Responsive styles for smaller laptops */
        @media (max-width: 1200px) {
            .game-buttons {
                width: 240px;
                padding: 1.25rem 0.75rem;
            }
            
            .game-content {
                gap: 2rem;
            }
            
            .chess-board {
                width: 440px;
                height: 440px;
            }
            
            .board-coordinates {
                display: flex;
                justify-content: center;
                align-items: center;
            }
            
            .visual-modes {
                width: 440px;
            }
            
            .moves-panel {
                width: 360px;
                max-height: 550px;
            }
            
            .chess-piece {
                width: 50px;
                height: 50px;
            }
        }

        /* Toggle Switch Styles */
        .toggle-switch {
            position: relative;
            display: inline-block;
        }

        .toggle-switch input[type="checkbox"] {
            display: none;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 2px 4px;
            background: transparent;
            border: none;
            border-radius: 6px;
            transition: all 0.3s ease;
            font-size: 12px;
            font-weight: 500;
            color: #495057;
        }

        .toggle-label::before {
            content: '';
            width: 24px;
            height: 12px;
            background: #dee2e6;
            border-radius: 12px;
            margin-right: 6px;
            position: relative;
            transition: all 0.3s ease;
        }

        .toggle-label::after {
            content: '';
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            position: absolute;
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
            transition: all 0.3s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .toggle-switch input:checked + .toggle-label {
            background: transparent;
            border: none;
            color: #495057;
        }

        .toggle-switch input:checked + .toggle-label::before {
            background: #28a745;
        }

        .toggle-switch input:checked + .toggle-label::after {
            left: 20px;
        }

        .toggle-label:hover {
            background: transparent;
        }

        .toggle-switch input:checked + .toggle-label:hover {
            background: transparent;
        }

        .moves-toggle-icon {
            padding: 0;
            background: transparent;
            border: none;
        }

        .toggle-icon {
            width: 36px;
            height: 36px;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s ease;
            background: transparent;
        }

        .toggle-icon:hover {
            background: #f0f0f0;
        }

        .moves-toggle-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            flex-shrink: 0;
        }

        /* Confetti styles */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #ff6b6b;
            animation: confetti-fall 3s linear infinite;
            z-index: 9999;
        }

        .confetti:nth-child(2n) {
            background: #4ecdc4;
            animation-delay: 0.1s;
        }

        .confetti:nth-child(3n) {
            background: #45b7d1;
            animation-delay: 0.2s;
        }

        .confetti:nth-child(4n) {
            background: #96ceb4;
            animation-delay: 0.3s;
        }

        .confetti:nth-child(5n) {
            background: #feca57;
            animation-delay: 0.4s;
        }

        .confetti:nth-child(6n) {
            background: #ff9ff3;
            animation-delay: 0.5s;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Game completion indicator */
        .completion-indicator {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #4CAF50;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            font-weight: bold;
            z-index: 10;
            animation: completionPulse 2s ease-in-out infinite;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
            opacity: 1;
        }

        @keyframes completionPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 4px 12px rgba(76, 175, 80, 0.6);
            }
        }

        /* Custom Game Valid Move Highlighting */
        .valid-move {
            background-color: rgba(0, 255, 0, 0.3) !important;
            outline: 2px solid #00ff00;
            outline-offset: -2px;
        }

        .valid-move:hover {
            background-color: rgba(0, 255, 0, 0.5) !important;
        }

        /* Delete Game Button - Subtle Version */
        .delete-game-btn-subtle {
            background: #f8f9fa;
            color: #6c757d;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .delete-game-btn-subtle:hover {
            background: #e9ecef;
            color: #495057;
            border-color: #adb5bd;
        }

        .delete-game-btn-subtle:active {
            transform: scale(0.98);
        }


        /* Custom Game Info Section Styles */
        .custom-game-info-section {
            margin-bottom: 15px;
        }

        .custom-game-info-section .game-header {
            background: #ffffff;
            color: #333333;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            border: 1px solid #e0e0e0;
            box-shadow: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .custom-game-info-section .game-header:hover {
            background: #f5f5f5;
            border-color: #cccccc;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .custom-game-info-section .game-header::after {
            content: '▼';
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.2s ease;
            font-size: 0.8rem;
            color: #666666;
        }

        .custom-game-info-section .game-header.expanded::after {
            transform: translateY(-50%) rotate(180deg);
        }

        .custom-game-info-section .game-details {
            background-color: #f8f9fa;
            border: none;
            border-radius: 0 0 6px 6px;
            margin-top: 0;
            max-height: 0;
            overflow: hidden;
            padding: 0 1rem;
            transition: max-height 0.4s ease, padding 0.4s ease, margin 0.4s ease;
        }

        .custom-game-info-section .game-details.show {
            max-height: 600px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .custom-game-info-section #custom-game-title-input {
            background: none;
            border: none;
            text-align: center;
            font-size: inherit;
            font-weight: inherit;
            color: inherit;
            width: 100%;
            outline: none;
            font-family: inherit;
            padding: 0;
            margin: 0;
        }

        .custom-game-info-section #custom-game-title-input:focus {
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #3498db;
            border-radius: 4px;
            padding: 2px 6px;
        }

        .custom-game-info-section #custom-game-title-input::placeholder {
            color: #999;
            font-style: italic;
        }

        .custom-game-info-section #custom-game-title-input:invalid {
            border: 1px solid #e74c3c;
        }

        /* Custom Detail Input Styles */
        .custom-detail-input {
            background: #ffffff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 13px;
            font-family: inherit;
            color: #333;
            width: 100%;
            max-width: 200px;
            transition: border-color 0.2s ease;
        }

        .custom-detail-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .custom-detail-input[readonly] {
            background: #f8f9fa;
            color: #6c757d;
            cursor: not-allowed;
        }

        .custom-detail-select {
            background: #ffffff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 13px;
            font-family: inherit;
            color: #333;
            width: 100%;
            max-width: 200px;
            transition: border-color 0.2s ease;
            cursor: pointer;
        }

        .custom-detail-select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e9ecef;
        }

        .detail-item:last-child {
            border-bottom: none;
        }

        @media (max-width: 900px) {
            .game-content {
                flex-direction: column;
                align-items: center;
                gap: 2rem;
            }
            
            .chess-board {
                width: 400px;
                height: 400px;
            }
            
            .board-coordinates {
                display: flex;
                justify-content: center;
                align-items: center;
            }
            
            .visual-modes {
                width: 400px;
            }
            
            .moves-panel {
                width: 360px;
                max-height: 470px;
            }
            
            .chess-piece {
                width: 46px;
                height: 46px;
            }
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <a href="index.html" class="logo">
            <div class="logo-icon">♟️</div>
            <span>Blind Chess</span>
        </a>
                <ul class="nav-links">
                    <li><a href="index.html">Home</a></li>
                <li><a href="games.html">Games</a></li>
                <li><a href="puzzles.html" class="active">Puzzles</a></li>
                <li class="subscription-tab-li"><a href="subscription.html" id="subscriptionTab">Subscription</a></li>
                    <li class="profile-dropdown">
                        <a href="#" id="profileLink" class="profile-icon">
                            <span class="profile-avatar">
                                <img src="images/user.png" alt="User" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">
                            </span>
                        </a>
            <div class="dropdown-menu" id="profileDropdown">
                <a href="profile.html" class="dropdown-item" id="profileMenuItem">
                    <span class="dropdown-text">My Profile</span>
                </a>
                <a href="#" class="dropdown-item" id="accountInfoMenuItem" style="display: none;">
                    <span class="dropdown-text">Account Information</span>
                </a>
                <a href="#" class="dropdown-item" id="signInMenuItem">
                    <span class="dropdown-text">Sign In</span>
                </a>
                <a href="#" class="dropdown-item" id="logoutMenuItem" style="display: none;">
                    <span class="dropdown-text">Logout</span>
                </a>
            </div>
                    </li>
                </ul>
    </nav>

    <div class="main-layout">
        <div class="game-buttons">
            <div class="game-button-container">
                <a href="#short-puzzles" class="game-button active" id="short-puzzles-btn">
                    <div>Short</div>
                    <div class="description">Quick tactical puzzles</div>
                </a>
                <div class="submenu" id="short-puzzles-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            <div class="game-button-container">
                <a href="#medium-puzzles" class="game-button" id="medium-puzzles-btn">
                    <div>Medium</div>
                    <div class="description">Intermediate puzzles</div>
                </a>
                <div class="submenu" id="medium-puzzles-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            <div class="game-button-container">
                <a href="#long-puzzles" class="game-button" id="long-puzzles-btn">
                    <div>Long</div>
                    <div class="description">Complex strategic puzzles</div>
                </a>
                <div class="submenu" id="long-puzzles-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
        </div>

        <main class="main-content">
            <div class="game-display" id="game-display">
                <div class="game-content">
                    <div class="board-section">
                        <div class="board-container">
                            <div class="board-coordinates">
                                <div class="chess-board" id="chess-board">
                                    <!-- Chess board will be generated by JavaScript -->
                                </div>
                                
                                <!-- Rank notation to the right of the board -->
                                <div class="rank-notation">
                                    <div class="notation-number">8</div>
                                    <div class="notation-number">7</div>
                                    <div class="notation-number">6</div>
                                    <div class="notation-number">5</div>
                                    <div class="notation-number">4</div>
                                    <div class="notation-number">3</div>
                                    <div class="notation-number">2</div>
                                    <div class="notation-number">1</div>
                                </div>
                            </div>
                            
                            <!-- Square notation below the board -->
                            <div class="board-notation">
                                <div class="notation-letter">a</div>
                                <div class="notation-letter">b</div>
                                <div class="notation-letter">c</div>
                                <div class="notation-letter">d</div>
                                <div class="notation-letter">e</div>
                                <div class="notation-letter">f</div>
                                <div class="notation-letter">g</div>
                                <div class="notation-letter">h</div>
                            </div>
                        </div>
                         <div class="visual-modes">
                             <div class="mode-option active" data-mode="normal">Normal</div>
                             <div class="mode-option" data-mode="grey">Grey</div>
                             <div class="mode-option" data-mode="checkers">Checkers</div>
                             <div class="mode-option" data-mode="empty">Empty</div>
                             <button class="test-btn" id="challenge-btn">Test</button>
                         </div>
                     </div>
                    <div class="moves-panel" id="moves-panel">
                        <div class="game-header" id="game-header" style="display: none;">
                            <div class="game-title-line" id="game-title-line">Select a Game</div>
                        </div>
                        <div class="game-details" id="game-details">
                            <div class="detail-item">
                                <span class="detail-label">Description:</span>
                                <span class="detail-value" id="detail-description">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Moves:</span>
                                <span class="detail-value" id="detail-moves">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">White Player:</span>
                                <span class="detail-value" id="detail-white">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Black Player:</span>
                                <span class="detail-value" id="detail-black">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Opening:</span>
                                <span class="detail-value" id="detail-opening">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Difficulty:</span>
                                <span class="detail-value" id="detail-difficulty">-</span>
                            </div>
                            <div class="detail-facts">
                                <div class="facts-title">Interesting Facts:</div>
                                <div class="facts-text" id="detail-facts">-</div>
                            </div>
                        </div>
                        
                        <!-- Custom Game Information Tab (shown in Add Game mode) -->
                        <div id="custom-game-info" class="custom-game-info-section" style="display: none;">
                            <div class="game-header" id="custom-game-header">
                                <div class="game-title-line" id="custom-game-title-line">
                                    <input type="text" id="custom-game-title-input" value="" placeholder="Enter title" maxlength="25" required style="background: none; border: none; text-align: center; font-size: inherit; font-weight: inherit; color: inherit; width: 100%; outline: none;">
                                </div>
                            </div>
                            <div class="game-details" id="custom-game-details">
                                <div class="detail-item">
                                    <span class="detail-label">Description:</span>
                                    <input type="text" id="custom-detail-description" class="custom-detail-input" placeholder="Enter description..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Moves:</span>
                                    <input type="text" id="custom-detail-moves" class="custom-detail-input" value="0" readonly>
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">White Player:</span>
                                    <input type="text" id="custom-detail-white" class="custom-detail-input" placeholder="Enter white player name..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Black Player:</span>
                                    <input type="text" id="custom-detail-black" class="custom-detail-input" placeholder="Enter black player name..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Opening:</span>
                                    <input type="text" id="custom-detail-opening" class="custom-detail-input" placeholder="Enter opening name..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Result:</span>
                                    <select id="custom-detail-result" class="custom-detail-select">
                                        <option value="In progress">In progress</option>
                                        <option value="1-0">1-0 (White wins)</option>
                                        <option value="0-1">0-1 (Black wins)</option>
                                        <option value="1/2-1/2">1/2-1/2 (Draw)</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        
                        <div class="move-controls">
                            <div class="move-icon flip-board-icon" id="flip-board-btn" title="Flip board perspective"><img src="images/switch-camera.png" alt="Flip Board" style="width: 20px; height: 20px;"></div>
                            <div class="move-icon" id="btn-initial" title="Go to initial position"><img src="images/fast-forward.png" alt="Initial" style="width: 20px; height: 20px; transform: scaleX(-1);"></div>
                            <div class="move-icon" id="btn-back" title="Previous move"><img src="images/next.png" alt="Back" style="width: 20px; height: 20px; transform: scaleX(-1);"></div>
                            <div class="move-icon" id="btn-forward" title="Next move"><img src="images/next.png" alt="Next" style="width: 20px; height: 20px;"></div>
                            <div class="move-icon" id="btn-final" title="Go to final position"><img src="images/fast-forward.png" alt="Last" style="width: 20px; height: 20px;"></div>
                            <div class="moves-toggle-icon" id="moves-toggle" style="display: none;">
                                <img src="images/hide.png" class="toggle-icon" id="moves-toggle-img" alt="Toggle moves visibility" title="Toggle moves visibility">
                        </div>
                        </div>
                        <div id="moves-list" style="max-height: 300px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 8px; padding: 10px; background: #fff;">
                            <p style="text-align: center; color: #7f8c8d;">Select a game to view moves</p>
                        </div>
                        
                        <!-- Comment Section -->
                        <div id="comment-section" style="display: none; margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #3498db;">
                            <div id="comment-content" style="color: #34495e; line-height: 1.4; font-size: 13px; text-align: left;">
                                Click on any move to see detailed commentary
                            </div>
                        </div>
                        
                    <!-- Delete Game Button (only for custom games) -->
                    <div id="delete-game-section" style="display: none; margin-top: 15px; text-align: center;">
                        <button id="delete-game-btn" class="delete-game-btn-subtle" title="Delete this custom game">
                            Delete Game
                        </button>
                    </div>


                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Completion Badge -->
    <div class="badge-overlay" id="badge-overlay"></div>
    <div class="completion-badge" id="completion-badge">
        <div class="badge-icon"><img src="images/check.png" alt="Complete" style="width: 56px; height: 56px;"></div>
        <div class="badge-title">Challenge Complete!</div>
        <div class="badge-subtitle">You successfully completed the memory challenge</div>
        <button class="badge-close" onclick="hideBadge()">Continue</button>
    </div>

    <script src="chess-move-parser.js?v=2"></script>
    <script src="custom-games.js"></script>
    <script src="progress-tracker.js"></script>
    <script>
        // Global variables for move navigation
        let currentGame = null;
         let currentMoveIndex = 0;
         let currentVisualMode = 'normal';
         let boardFlipped = false;
         let draggedPiece = null;
         let draggedFromSquare = null;
         let validMoves = [];
         let isChallengeMode = false;
         let completedChallenges = new Set(); // Track completed challenges
         let selectedPiece = null; // Track clicked/selected piece
         let selectedSquare = null; // Track selected square
         
         // Initialize progress tracker
         let progressTracker = new ProgressTracker();
         
         // Load completed challenges from progress tracker
         function loadCompletedChallenges() {
             return progressTracker.getAllCompletedChallengesSet();
         }
         
         // Initialize the move parser
         const moveParser = new ChessMoveParser();
        
        // Audio objects for sound effects - using your custom sound file
        const customSound = new Audio('sounds/click-21156.mp3');
        
        // Function to play sound effects - using your custom sound file
        function playSound(isCapture) {
            try {
                // Reset the sound to the beginning and play
                customSound.currentTime = 0;
                customSound.play().catch(error => {
                    console.log('Sound play failed:', error);
                });
            } catch (error) {
                console.log('Could not play sound:', error);
            }
        }

        // Load games data dynamically
        let gamesData = null;
        
        // Check login status and update navigation
        function updateNavigation() {
            const profileLink = document.getElementById('profileLink');
            const profileMenuItem = document.getElementById('profileMenuItem');
            const accountInfoMenuItem = document.getElementById('accountInfoMenuItem');
            const signInMenuItem = document.getElementById('signInMenuItem');
            const logoutMenuItem = document.getElementById('logoutMenuItem');
            const subscriptionTab = document.getElementById('subscriptionTab');
            const isLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
            const hasActiveSubscription = localStorage.getItem('hasActiveSubscription') === 'true';
            
            // Show/hide subscription tab based on subscription status
            const subscriptionLi = document.querySelector('.subscription-tab-li');
            if (hasActiveSubscription) {
                subscriptionLi.classList.add('hidden-for-subscriber');
            } else {
                subscriptionLi.classList.remove('hidden-for-subscriber');
            }
            
            if (isLoggedIn) {
                // User is logged in - show profile, account info, and logout options
                profileMenuItem.style.display = 'flex';
                accountInfoMenuItem.style.display = 'flex';
                logoutMenuItem.style.display = 'flex';
                signInMenuItem.style.display = 'none';
                profileMenuItem.onclick = function(e) {
                    e.preventDefault();
                    window.location.href = 'profile.html';
                };
                
                accountInfoMenuItem.onclick = function(e) {
                    e.preventDefault();
                    showAccountInfoModal();
                };
                
                logoutMenuItem.onclick = function(e) {
                    e.preventDefault();
                    logout();
                };
                
                profileLink.onclick = function(e) {
                    e.preventDefault();
                    window.location.href = 'profile.html';
                };
            } else {
                // User is not logged in - show sign in option
                profileMenuItem.style.display = 'none';
                accountInfoMenuItem.style.display = 'none';
                logoutMenuItem.style.display = 'none';
                signInMenuItem.style.display = 'flex';
                signInMenuItem.onclick = function(e) {
                    e.preventDefault();
                    showSignInModal();
                };
                profileLink.onclick = function(e) {
                    e.preventDefault();
                    showSignInModal();
                };
            }
        }

        // Show account information modal
        function showAccountInfoModal() {
            const userName = localStorage.getItem('userName') || 'User';
            const userEmail = localStorage.getItem('userEmail') || 'No email provided';
            const subscriptionPlan = localStorage.getItem('subscriptionPlan') || 'free';
            
            // Format subscription display
            let subscriptionDisplay = 'Free Account';
            if (subscriptionPlan === 'monthly') {
                subscriptionDisplay = 'Premium Monthly';
            } else if (subscriptionPlan === 'quarterly') {
                subscriptionDisplay = 'Premium Quarterly';
            } else if (subscriptionPlan === 'monthly_cancelled') {
                subscriptionDisplay = 'Premium Monthly (Cancelled)';
            } else if (subscriptionPlan === 'quarterly_cancelled') {
                subscriptionDisplay = 'Premium Quarterly (Cancelled)';
            }
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Account Information</h2>
                        <span class="close" onclick="closeModal()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="account-info">
                            <div class="info-item">
                                <label>Name:</label>
                                <span>${userName}</span>
                            </div>
                            <div class="info-item">
                                <label>Email:</label>
                                <span>${userEmail}</span>
                            </div>
                            <div class="info-item">
                                <label>Subscription:</label>
                                <span>${subscriptionDisplay}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.style.display = 'block';
        }

        // Logout function - shows confirmation modal
        function logout() {
            document.getElementById('logoutConfirmModal').style.display = 'block';
        }

        // Confirm logout function
        function confirmLogout() {
            localStorage.removeItem('isLoggedIn');
            localStorage.removeItem('userName');
            localStorage.removeItem('userEmail');
            localStorage.removeItem('subscriptionPlan');
            localStorage.removeItem('hasActiveSubscription');
            updateNavigation();
            
            // Hide modal
            document.getElementById('logoutConfirmModal').style.display = 'none';
            
            // Redirect to home page
            window.location.href = 'index.html';
        }

        // Cancel logout function
        function cancelLogout() {
            document.getElementById('logoutConfirmModal').style.display = 'none';
        }

        // Subscription Required Modal functions
        function showSubscriptionRequiredModal() {
            document.getElementById('subscriptionRequiredModal').style.display = 'block';
        }

        function closeSubscriptionModal() {
            document.getElementById('subscriptionRequiredModal').style.display = 'none';
        }

        function goToSubscription() {
            window.location.href = 'subscription.html';
        }

        // Modal functions
        function showSignInModal() {
            document.getElementById('signInModal').style.display = 'block';
            document.getElementById('registerModal').style.display = 'none';
        }

        function showRegisterModal() {
            document.getElementById('registerModal').style.display = 'block';
            document.getElementById('signInModal').style.display = 'none';
        }

        function closeModal() {
            // Close static modals
            const signInModal = document.getElementById('signInModal');
            const registerModal = document.getElementById('registerModal');
            const logoutConfirmModal = document.getElementById('logoutConfirmModal');
            const subscriptionRequiredModal = document.getElementById('subscriptionRequiredModal');
            if (signInModal) signInModal.style.display = 'none';
            if (registerModal) registerModal.style.display = 'none';
            if (logoutConfirmModal) logoutConfirmModal.style.display = 'none';
            if (subscriptionRequiredModal) subscriptionRequiredModal.style.display = 'none';
            
            // Close dynamically created modals
            const dynamicModals = document.querySelectorAll('.modal');
            dynamicModals.forEach(modal => {
                if (modal.id !== 'signInModal' && modal.id !== 'registerModal') {
                    modal.remove();
                }
            });
        }

        // Sign in form handler
        function handleSignIn(event) {
            event.preventDefault();
            const email = document.getElementById('signInEmail').value;
            const password = document.getElementById('signInPassword').value;
            
            // Check if user exists in localStorage
            const storedEmail = localStorage.getItem('userEmail');
            const storedPassword = localStorage.getItem('userPassword');
            
            if (email === storedEmail && password === storedPassword) {
                localStorage.setItem('isLoggedIn', 'true');
                updateNavigation();
                closeModal();
                window.location.href = 'profile.html';
            }
        }

        // Register form handler
        function handleRegister(event) {
            event.preventDefault();
            const email = document.getElementById('registerEmail').value;
            const password = document.getElementById('registerPassword').value;
            const name = document.getElementById('registerName').value;
            
            // Check if email already exists
            const existingEmail = localStorage.getItem('userEmail');
            if (existingEmail === email) {
                showSignInModal();
                return;
            }
            
            // Create new account
            localStorage.setItem('isLoggedIn', 'true');
            localStorage.setItem('userEmail', email);
            localStorage.setItem('userName', name);
            localStorage.setItem('userPassword', password);
            updateNavigation();
            closeModal();
            window.location.href = 'profile.html';
        }

        // Google sign-in handler
        function signInWithGoogle() {
            // Simulate Google OAuth flow (replace with actual Google OAuth implementation)
            const mockGoogleUser = {
                email: 'user@gmail.com',
                name: 'Google User',
                id: 'google_' + Math.random().toString(36).substr(2, 9)
            };
            
            // Check if user exists in localStorage
            const storedEmail = localStorage.getItem('userEmail');
            const storedPassword = localStorage.getItem('userPassword');
            
            if (storedEmail === mockGoogleUser.email && storedPassword === mockGoogleUser.id) {
                // User exists, sign them in
                localStorage.setItem('isLoggedIn', 'true');
                updateNavigation();
                closeModal();
                window.location.href = 'profile.html';
            } else {
                // User doesn't exist, create account
                localStorage.setItem('isLoggedIn', 'true');
                localStorage.setItem('userEmail', mockGoogleUser.email);
                localStorage.setItem('userName', mockGoogleUser.name);
                localStorage.setItem('userPassword', mockGoogleUser.id);
                localStorage.setItem('authProvider', 'google');
                updateNavigation();
                closeModal();
                window.location.href = 'profile.html';
            }
        }

        // Google registration handler
        function registerWithGoogle() {
            // Simulate Google OAuth flow (replace with actual Google OAuth implementation)
            const mockGoogleUser = {
                email: 'user@gmail.com',
                name: 'Google User',
                id: 'google_' + Math.random().toString(36).substr(2, 9)
            };
            
            // Check if user already exists
            const existingEmail = localStorage.getItem('userEmail');
            if (existingEmail === mockGoogleUser.email) {
                showSignInModal();
                return;
            }
            
            // Create account with Google data
            localStorage.setItem('isLoggedIn', 'true');
            localStorage.setItem('userEmail', mockGoogleUser.email);
            localStorage.setItem('userName', mockGoogleUser.name);
            localStorage.setItem('userPassword', mockGoogleUser.id); // Use Google ID as password
            localStorage.setItem('authProvider', 'google');
            updateNavigation();
            closeModal();
            window.location.href = 'profile.html';
        }
        
        // Initialize games data on page load
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('DOM loaded, loading games...');
            try {
                gamesData = await GameLoader.loadGamesFromFiles();
                console.log('Loaded games:', gamesData);
                console.log('Number of games loaded:', gamesData ? gamesData.games.length : 0);
                
                // Custom games are now loaded through GameLoader.loadGamesFromFiles()
                // No need for direct fallback loading
            } catch (error) {
                console.error('Error loading games:', error);
                gamesData = { games: [] };
            }
            
            // Load completed challenges from progress tracker
            completedChallenges = loadCompletedChallenges();
            console.log('Loaded completed challenges:', completedChallenges);
            
            // Update the game buttons display
            updateGameButtons();
            updateNavigation();
            
            // Set up modal event listeners
            document.querySelectorAll('.close').forEach(closeBtn => {
                closeBtn.addEventListener('click', closeModal);
            });
            
            // Close modal when clicking outside
            window.addEventListener('click', function(event) {
                const signInModal = document.getElementById('signInModal');
                const registerModal = document.getElementById('registerModal');
                const logoutConfirmModal = document.getElementById('logoutConfirmModal');
                const subscriptionRequiredModal = document.getElementById('subscriptionRequiredModal');
                if (event.target === signInModal) {
                    closeModal();
                }
                if (event.target === registerModal) {
                    closeModal();
                }
                if (event.target === logoutConfirmModal) {
                    closeModal();
                }
                if (event.target === subscriptionRequiredModal) {
                    closeModal();
                }
            });
            
            // Update completion badges after games are loaded
            updateGameListBadges();
            
            // Set up training timer click detection
            setupTrainingTimer();
        });
        
        // Set up training timer for piece movements
        function setupTrainingTimer() {
            // Training timer will be started when pieces are moved
            // (handled in movePiece and movePieceDirectly functions)
            
            // Reset idle timer on any user activity
            document.addEventListener('mousemove', function() {
                if (progressTracker.trainingTimer.isRunning) {
                    progressTracker.resetTrainingIdleTimer();
                }
            });
            
            document.addEventListener('keydown', function() {
                if (progressTracker.trainingTimer.isRunning) {
                    progressTracker.resetTrainingIdleTimer();
                }
            });
            
            // Stop training timer when leaving the page
            window.addEventListener('beforeunload', function() {
                progressTracker.stopTrainingTimer();
            });
        }

        // Function to reload games data
        async function reloadGamesData() {
            try {
                console.log('🔄 Reloading games data...');
                gamesData = await GameLoader.loadGamesFromFiles();
                console.log('📊 Reloaded games:', gamesData);
                console.log('📊 Total games loaded:', gamesData ? gamesData.games.length : 0);
                console.log('📊 Custom games:', gamesData ? gamesData.games.filter(g => g.id.startsWith('custom-game-')).length : 0);
                updateGameButtons();
                console.log('✅ Game buttons updated');
            } catch (error) {
                console.error('❌ Error reloading games:', error);
            }
        }
        
        // Function to clear the chess board - remove all pieces
        function clearChessBoard() {
            console.log('Clearing chess board...');
            
            // Clear all squares on the board but preserve square notation
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.querySelector(`[data-square="${String.fromCharCode(97 + j)}${8 - i}"]`);
                    if (square) {
                        const notation = square.querySelector('.square-index');
                        square.innerHTML = '';
                        if (notation) {
                            square.appendChild(notation);
                        }
                    }
                }
            }
            
            // Clear any selection or highlights on the board
            document.querySelectorAll('.selected').forEach(element => {
                element.classList.remove('selected');
            });
            document.querySelectorAll('.valid-move').forEach(element => {
                element.classList.remove('valid-move');
            });
            document.querySelectorAll('.last-move').forEach(element => {
                element.classList.remove('last-move');
            });
            
            console.log('Chess board cleared');
        }

        // Function to clear only custom game elements (not the entire right section)
        function clearCustomGameElements() {
            console.log('Clearing custom game elements...');
            
            // Hide custom game info section
            const customGameInfo = document.getElementById('custom-game-info');
            if (customGameInfo) {
                customGameInfo.style.display = 'none';
            }
            
            // Hide custom commentary section
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            
            // Hide custom save button and message
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }
            
            // Clear the chess board - remove all pieces
            clearChessBoard();
            
            console.log('Custom game elements cleared');
        }

        // Function to clear the right section (moves section)
        function clearRightSection() {
            console.log('Clearing right section...');
            
            // Clear the moves list
            const movesList = document.getElementById('moves-list');
            if (movesList) {
                movesList.innerHTML = '';
                movesList.style.display = 'none';
            }
            
            // Hide game info sections
            const gameHeader = document.getElementById('game-header');
            const gameDetails = document.getElementById('game-details');
            if (gameHeader) {
                gameHeader.style.display = 'none';
            }
            if (gameDetails) {
                gameDetails.style.display = 'none';
            }
            
            // Hide custom game info section
            const customGameInfo = document.getElementById('custom-game-info');
            if (customGameInfo) {
                customGameInfo.style.display = 'none';
            }
            
            // Hide comment section
            const commentSection = document.getElementById('comment-section');
            if (commentSection) {
                commentSection.style.display = 'none';
            }
            
            // Hide delete game section
            const deleteGameSection = document.getElementById('delete-game-section');
            if (deleteGameSection) {
                deleteGameSection.style.display = 'none';
            }
            
            // Hide custom commentary section
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            
            // Hide custom save button and message
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }
            
            // Reset move buttons
            const btnInitial = document.getElementById('btn-initial');
            const btnBack = document.getElementById('btn-back');
            const btnForward = document.getElementById('btn-forward');
            const btnFinal = document.getElementById('btn-final');
            
            if (btnInitial) btnInitial.classList.add('disabled');
            if (btnBack) btnBack.classList.add('disabled');
            if (btnForward) btnForward.classList.add('disabled');
            if (btnFinal) btnFinal.classList.add('disabled');
            
            // Clear any highlights
            document.querySelectorAll('.clickable-move').forEach(span => {
                span.classList.remove('active-move');
            });
            document.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                section.classList.remove('clicked');
            });
            
            // Clear the chess board - remove all pieces
            clearChessBoard();
            
            console.log('Right section cleared');
        }

        // Function to delete a custom game
        async function deleteCustomGame(event, gameId) {
            event.stopPropagation(); // Prevent the game from being selected
            
            try {
                console.log('🗑️ Deleting custom game:', gameId);
                const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
                const apiUrl = isProduction ? `/api/delete-game?id=${gameId}` : `http://localhost:3001/delete-game/${gameId}`;
                const response = await fetch(apiUrl, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const result = await response.json();
                console.log('📡 Delete response:', result);
                
                if (result.success) {
                    console.log('✅ Game deleted successfully from server');
                    
                    // Clear the right section (moves section) after successful deletion
                    clearRightSection();
                    
                    console.log('🔄 Reloading games data...');
                    // Reload the games data to update the display
                    await reloadGamesData();
                    console.log('✅ Games data reloaded');
                } else {
                    console.error('❌ Failed to delete game:', result.message);
                }
            } catch (error) {
                console.error('❌ Error deleting game:', error);
            }
        }


        // Make functions globally accessible
        window.reloadGamesData = reloadGamesData;
        window.updateGameButtons = updateGameButtons;
        window.deleteCustomGame = deleteCustomGame;

        // Function to update game buttons display
        function updateGameButtons() {
            console.log('Updating game buttons...');
            if (!gamesData || !gamesData.games) {
                console.log('No games data available');
                return;
            }
            
            // Manual categorization - assign games to categories regardless of move count
            const manualCategorization = {
                'short': [
                    'test'
                ],
                'medium': [
                ],
                'long': [
                ]
            };
            
            const allGames = gamesData.games.filter(g => !g.id.startsWith('custom-game-'));
            const customGames = gamesData.games.filter(g => g.id.startsWith('custom-game-'));
            
            // Categorize games based on manual assignment
            const shortPuzzles = allGames.filter(g => manualCategorization.short.includes(g.id));
            const mediumPuzzles = allGames.filter(g => manualCategorization.medium.includes(g.id));
            const longPuzzles = allGames.filter(g => manualCategorization.long.includes(g.id));
            
            console.log('=== MANUAL PUZZLE CATEGORIZATION ===');
            console.log('Total games loaded:', gamesData.games.length);
            console.log('Games with locked status:', gamesData.games.map(g => ({ name: g.name, locked: g.locked })));
            console.log('Short puzzles:', shortPuzzles.length, shortPuzzles.map(g => g.id));
            console.log('Medium puzzles:', mediumPuzzles.length, mediumPuzzles.map(g => g.id));
            console.log('Long puzzles:', longPuzzles.length, longPuzzles.map(g => g.id));
            console.log('Custom games:', customGames.length);
            
            // Update each category
            updateGameCategory('short-puzzles-submenu', shortPuzzles);
            updateGameCategory('medium-puzzles-submenu', mediumPuzzles);
            updateGameCategory('long-puzzles-submenu', longPuzzles);
        }
        
        function updateGameCategory(categoryId, games) {
            console.log(`Updating category ${categoryId} with ${games.length} games`);
            const categoryElement = document.getElementById(categoryId);
            if (!categoryElement) {
                console.error(`Category element not found: ${categoryId}`);
                return;
            }
            
            // Clear existing content
            categoryElement.innerHTML = '';
            
            games.forEach(game => {
                const gameButton = document.createElement('a');
                gameButton.href = '#';
                gameButton.className = 'submenu-button';
                gameButton.setAttribute('data-game-id', game.id);
                
                // Check if user has active subscription
                const hasActiveSubscription = localStorage.getItem('hasActiveSubscription') === 'true';
                const isGameLocked = game.locked && !hasActiveSubscription;
                
                // Add locked class if game is locked and user doesn't have subscription
                if (isGameLocked) {
                    gameButton.classList.add('locked');
                }
                
                gameButton.onclick = (e) => {
                    e.preventDefault();
                    if (isGameLocked) {
                        // Show subscription required modal
                        showSubscriptionRequiredModal();
                        return;
                    }
                    displayGame(game.id);
                };
                
                let buttonContent = `
                    <span>${game.name}</span>
                    <span class="game-completion-badge" data-game="${game.id}"><img src="images/check.png" alt="Complete" style="width: 20px; height: 20px;"></span>
                `;
                
                // Add lock overlay if game is locked and user doesn't have subscription
                if (isGameLocked) {
                    buttonContent += `
                        <div class="lock-overlay">
                            <div class="lock-icon">🔒</div>
                        </div>
                    `;
                }
                
                gameButton.innerHTML = buttonContent;
                
                categoryElement.appendChild(gameButton);
            });
            
            // Add "Add Game" button to short games submenu
        }
        
        // Function to reset the board to starting position
        function resetBoard() {
            // Clear all squares but preserve square notation
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.querySelector(`[data-square="${String.fromCharCode(97 + j)}${8 - i}"]`);
                    if (square) {
                        const notation = square.querySelector('.square-index');
                        square.innerHTML = '';
                        if (notation) {
                            square.appendChild(notation);
                        }
                    }
                }
            }
            
            // Reset piece positions in parser
            moveParser.resetBoard();
            
            // Set up starting position
            setupStartingPosition();
        }
        
        function setupStartingPosition() {
            // White pieces
            const whitePieces = {
                'a1': 'Chess_rlt45.svg.png', 'b1': 'Chess_nlt45.svg.png', 'c1': 'Chess_blt45.svg.png', 'd1': 'Chess_qlt45.svg.png',
                'e1': 'Chess_klt45.svg.png', 'f1': 'Chess_blt45.svg.png', 'g1': 'Chess_nlt45.svg.png', 'h1': 'Chess_rlt45.svg.png',
                'a2': 'Chess_plt45.svg.png', 'b2': 'Chess_plt45.svg.png', 'c2': 'Chess_plt45.svg.png', 'd2': 'Chess_plt45.svg.png',
                'e2': 'Chess_plt45.svg.png', 'f2': 'Chess_plt45.svg.png', 'g2': 'Chess_plt45.svg.png', 'h2': 'Chess_plt45.svg.png'
            };
            
            // Black pieces
            const blackPieces = {
                'a8': 'Chess_rdt45.svg.png', 'b8': 'Chess_ndt45.svg.png', 'c8': 'Chess_bdt45.svg.png', 'd8': 'Chess_qdt45.svg.png',
                'e8': 'Chess_kdt45.svg.png', 'f8': 'Chess_bdt45.svg.png', 'g8': 'Chess_ndt45.svg.png', 'h8': 'Chess_rdt45.svg.png',
                'a7': 'Chess_pdt45.svg.png', 'b7': 'Chess_pdt45.svg.png', 'c7': 'Chess_pdt45.svg.png', 'd7': 'Chess_pdt45.svg.png',
                'e7': 'Chess_pdt45.svg.png', 'f7': 'Chess_pdt45.svg.png', 'g7': 'Chess_pdt45.svg.png', 'h7': 'Chess_pdt45.svg.png'
            };
            
            // Place white pieces
            Object.entries(whitePieces).forEach(([square, piece]) => {
                const squareElement = document.querySelector(`[data-square="${square}"]`);
                if (squareElement) {
                    const pieceElement = createDraggablePiece(piece, square);
                    squareElement.appendChild(pieceElement);
                }
            });
            
            // Place black pieces
            Object.entries(blackPieces).forEach(([square, piece]) => {
                const squareElement = document.querySelector(`[data-square="${square}"]`);
                if (squareElement) {
                    const pieceElement = createDraggablePiece(piece, square);
                    squareElement.appendChild(pieceElement);
                }
            });
        }
        
        // Helper function to clear square content while preserving notation
        function clearSquarePreservingNotation(square) {
            const notation = square.querySelector('.square-index');
            square.innerHTML = '';
            if (notation) {
                square.appendChild(notation);
            }
        }

        // Initialize chess board

        function initializeChessBoard() {
            const board = document.getElementById('chess-board');
            board.innerHTML = '';
            
            // Create 64 squares (8x8)
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    
                    // Calculate square color based on actual chess position
                    let actualRow, actualCol;
                    if (boardFlipped) {
                        // When flipped, we want to show the board from black's perspective
                        actualRow = 7 - row;  // Flip rows
                        actualCol = 7 - col;  // Flip columns
                    } else {
                        actualRow = row;
                        actualCol = col;
                    }
                    
                    const isLight = (actualRow + actualCol) % 2 === 0;
                    square.className = `chess-square ${isLight ? 'light' : 'dark'}`;
                    
                    // Convert row/col to chess notation (a1, b1, etc.)
                    // When flipped, reverse the row and column order
                    let file, rank;
                    if (boardFlipped) {
                        file = String.fromCharCode(97 + (7 - col)); // h, g, f, etc. when flipped
                        rank = row + 1; // 1, 2, 3, etc. when flipped
                    } else {
                        file = String.fromCharCode(97 + col); // a, b, c, etc.
                        rank = 8 - row; // 8, 7, 6, etc.
                    }
                    square.dataset.square = file + rank;
                    
                    
                    // Add drop event listeners
                    square.addEventListener('dragover', handleDragOver);
                    square.addEventListener('drop', handleDrop);
                    
                    // Add click event listener
                    square.addEventListener('click', handleSquareClick);
                    
                    board.appendChild(square);
                }
            }
        }

        // Set up initial board position
        function setupInitialPosition() {
            const board = document.getElementById('chess-board');
            const squares = board.querySelectorAll('.chess-square');
            
            // Clear all pieces but preserve square notation
            squares.forEach(square => {
                const notation = square.querySelector('.square-index');
                square.innerHTML = '';
                if (notation) {
                    square.appendChild(notation);
                }
            });

            // Only set up pieces if a game is selected
            if (currentGame) {
                let initialPosition;
                
                // Check if the game has a custom initial position
                if (currentGame.initial_position) {
                    initialPosition = currentGame.initial_position;
                } else {
                    // Use standard starting position
                    initialPosition = {
                        // Black pieces
                        'a8': 'Chess_rdt45.svg.png', 'b8': 'Chess_ndt45.svg.png', 'c8': 'Chess_bdt45.svg.png', 'd8': 'Chess_qdt45.svg.png',
                        'e8': 'Chess_kdt45.svg.png', 'f8': 'Chess_bdt45.svg.png', 'g8': 'Chess_ndt45.svg.png', 'h8': 'Chess_rdt45.svg.png',
                        'a7': 'Chess_pdt45.svg.png', 'b7': 'Chess_pdt45.svg.png', 'c7': 'Chess_pdt45.svg.png', 'd7': 'Chess_pdt45.svg.png',
                        'e7': 'Chess_pdt45.svg.png', 'f7': 'Chess_pdt45.svg.png', 'g7': 'Chess_pdt45.svg.png', 'h7': 'Chess_pdt45.svg.png',
                        
                        // White pieces
                        'a1': 'Chess_rlt45.svg.png', 'b1': 'Chess_nlt45.svg.png', 'c1': 'Chess_blt45.svg.png', 'd1': 'Chess_qlt45.svg.png',
                        'e1': 'Chess_klt45.svg.png', 'f1': 'Chess_blt45.svg.png', 'g1': 'Chess_nlt45.svg.png', 'h1': 'Chess_rlt45.svg.png',
                        'a2': 'Chess_plt45.svg.png', 'b2': 'Chess_plt45.svg.png', 'c2': 'Chess_plt45.svg.png', 'd2': 'Chess_plt45.svg.png',
                        'e2': 'Chess_plt45.svg.png', 'f2': 'Chess_plt45.svg.png', 'g2': 'Chess_plt45.svg.png', 'h2': 'Chess_plt45.svg.png'
                    };
                }

                // Place pieces on their corresponding squares
                Object.entries(initialPosition).forEach(([squareNotation, pieceImage]) => {
                    if (pieceImage && pieceImage !== '') { // Only place pieces if there's an image and it's not empty
                        const square = board.querySelector(`[data-square="${squareNotation}"]`);
                        if (square) {
                            const pieceElement = createDraggablePiece(pieceImage, squareNotation);
                            square.appendChild(pieceElement);
                        }
                    }
                });
            }
        }

        // Helper function to get square notation from index
        function getSquareNotation(index) {
            const row = Math.floor(index / 8);
            const col = index % 8;
            
            // When flipped, we need to calculate notation differently
            if (boardFlipped) {
                const file = String.fromCharCode(97 + (7 - col));
                const rank = row + 1;
                return file + rank;
            } else {
                return String.fromCharCode(97 + col) + (8 - row);
            }
        }

        // Create a draggable piece element
        function createDraggablePiece(pieceImage, squareNotation) {
            const pieceElement = document.createElement('div');
            pieceElement.className = 'chess-piece';
            pieceElement.style.backgroundImage = `url('pieces/${pieceImage}')`;
            pieceElement.draggable = true;
            pieceElement.dataset.piece = pieceImage;
            pieceElement.dataset.square = squareNotation;
            
            // Add drag event listeners
            pieceElement.addEventListener('dragstart', handleDragStart);
            pieceElement.addEventListener('dragend', handleDragEnd);
            
            // Add click event listener
            pieceElement.addEventListener('click', handlePieceClick);
            
            // Apply current visual mode to the new piece
            applyVisualModeToPiece(pieceElement, currentVisualMode);
            
            // Make slightly visible if in challenge mode but keep clickable
            if (isChallengeMode) {
                pieceElement.style.opacity = '0.3'; // Slight opacity for visibility
                pieceElement.style.pointerEvents = 'auto'; // Ensure pieces remain clickable
            }
            
            return pieceElement;
        }

        // Update piece square notation when moved
        function updatePieceSquare(pieceElement, newSquare) {
            pieceElement.dataset.square = newSquare;
        }

        // Re-initialize drag and drop for all pieces on the board
        function reinitializeDragAndDrop() {
            const pieces = document.querySelectorAll('.chess-piece');
            pieces.forEach((piece, index) => {
                // Remove existing event listeners
                piece.removeEventListener('dragstart', handleDragStart);
                piece.removeEventListener('dragend', handleDragEnd);
                piece.removeEventListener('click', handlePieceClick);
                
                // Re-add event listeners
                piece.addEventListener('dragstart', handleDragStart);
                piece.addEventListener('dragend', handleDragEnd);
                piece.addEventListener('click', handlePieceClick);
                
                // Ensure piece is draggable
                piece.draggable = true;
            });
            
            // Also re-setup drop event listeners for squares
            const squares = document.querySelectorAll('.chess-square');
            squares.forEach(square => {
                // Remove existing event listeners
                square.removeEventListener('dragover', handleDragOver);
                square.removeEventListener('drop', handleDrop);
                square.removeEventListener('click', handleSquareClick);
                
                // Re-add event listeners
                square.addEventListener('dragover', handleDragOver);
                square.addEventListener('drop', handleDrop);
                square.addEventListener('click', handleSquareClick);
            });
        }

        // Handle drag start
        function handleDragStart(e) {
            console.log('=== MAIN DRAG START ===');
            console.log('Target:', e.target);
            console.log('Custom game mode:', typeof customGameMode !== 'undefined' ? customGameMode : 'undefined');
            console.log('Window custom game mode:', typeof window.customGameMode !== 'undefined' ? window.customGameMode : 'undefined');
            
            draggedPiece = e.target;
            draggedFromSquare = e.target.dataset.square;
            
            // Highlight valid moves before adding dragging class
            highlightValidMoves();
            
            // Add dragging class to disable transitions on piece and board
            e.target.classList.add('dragging');
            const board = document.getElementById('chess-board');
            board.classList.add('dragging');
            console.log('Added dragging class to piece, classes now:', e.target.classList.toString());
            console.log('Added dragging class to board, classes now:', board.classList.toString());
            
            // Use default drag image to prevent layout issues
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
            
            // Keep original piece slightly visible in challenge mode, invisible in empty mode, otherwise semi-transparent
            if (currentVisualMode === 'empty') {
                e.target.style.opacity = '0';
            } else if (isChallengeMode) {
                e.target.style.opacity = '0.3'; // Slight opacity for visibility
                e.target.style.pointerEvents = 'auto'; // Ensure pieces remain clickable
            } else {
                e.target.style.opacity = '0.5';
            }
        }

        // Handle drag end
        function handleDragEnd(e) {
            console.log('=== MAIN DRAG END ===');
            console.log('Target:', e.target);
            console.log('Target current square:', e.target.dataset.square);
            console.log('Dragged from square:', draggedFromSquare);
            console.log('Custom game mode:', typeof customGameMode !== 'undefined' ? customGameMode : 'undefined');
            console.log('Window custom game mode:', typeof window.customGameMode !== 'undefined' ? window.customGameMode : 'undefined');
            
            // Check if the piece is still in the same position (hasn't been moved)
            const isStillInOriginalPosition = e.target.dataset.square === draggedFromSquare;
            console.log('Piece still in original position:', isStillInOriginalPosition);
            
            // Remove dragging class to re-enable transitions
            e.target.classList.remove('dragging');
            const board = document.getElementById('chess-board');
            board.classList.remove('dragging');
            console.log('Removed dragging class from piece, classes now:', e.target.classList.toString());
            console.log('Removed dragging class from board, classes now:', board.classList.toString());
            
            // Clear highlights after removing dragging class
            clearHighlights();
            
            // Only restore opacity if the piece is still in its original position
            // If it was moved, the new piece already has the correct opacity
            if (isStillInOriginalPosition) {
                console.log('Restoring opacity for unmoved piece');
                // Restore piece opacity based on current visual mode or challenge mode
                if (currentVisualMode === 'empty') {
                    e.target.style.opacity = '0';
                } else if (isChallengeMode) {
                    e.target.style.opacity = '0.3'; // Slight opacity for visibility
                    e.target.style.pointerEvents = 'auto'; // Ensure pieces remain clickable
                } else {
                    e.target.style.opacity = '1';
                }
            } else {
                console.log('Piece was moved, skipping opacity restoration');
            }
            
            // Reset drag variables
            draggedPiece = null;
            draggedFromSquare = null;
        }

        // Handle piece click (for click-to-select)
        function handlePieceClick(e) {
            e.stopPropagation(); // Prevent square click from firing
            
            const piece = e.target;
            const square = piece.parentElement;
            const squareNotation = getSquareNotationFromElement(square);
            
            console.log('Piece clicked on square:', squareNotation);
            
            // Clear previous selection
            clearSelection();
            
            // Select this piece
            selectedPiece = piece;
            selectedSquare = squareNotation;
            
            // Calculate valid moves for this piece
            draggedPiece = piece; // Temporarily set for move calculation
            draggedFromSquare = squareNotation;
            calculateValidMoves();
            
            // Show selection highlight (only in normal mode)
            if (!isChallengeMode) {
                console.log('Adding selected class to square:', square);
                square.classList.add('selected');
                console.log('Square classes after adding selected:', square.className);
                
                // Show valid move highlights too
                validMoves.forEach(moveSquare => {
                    const validSquare = getSquareByNotation(moveSquare);
                    if (validSquare) {
                        validSquare.classList.add('valid-move');
                    }
                });
            }
            
            console.log('Piece selected. Valid moves:', validMoves);
        }

        // Handle square click (for click-to-move)
        function handleSquareClick(e) {
            const clickedSquare = e.target;
            const clickedSquareNotation = getSquareNotationFromElement(clickedSquare);
            
            console.log('Square clicked:', clickedSquareNotation);
            const pieceOnSquare = clickedSquare.querySelector('.chess-piece');
            console.log('Square has piece:', pieceOnSquare !== null);
            
            // If there's a piece on this square and no piece is currently selected, select this piece
            if (pieceOnSquare && (!selectedPiece || !selectedSquare)) {
                console.log('Selecting piece on clicked square');
                handlePieceClick({ target: pieceOnSquare, stopPropagation: () => {} });
                return;
            }
            
            // If no piece is selected, do nothing
            if (!selectedPiece || !selectedSquare) {
                console.log('No piece selected');
                return;
            }
            
            // Check if this is a valid move
            if (validMoves.includes(clickedSquareNotation)) {
                console.log('Valid move! Moving from', selectedSquare, 'to', clickedSquareNotation);
                
                // Execute the move
                movePieceDirectly(selectedSquare, clickedSquareNotation, selectedPiece.dataset.piece);
                
                // Reset idle timer after move
                progressTracker.resetIdleTimer();
                
                // Update game state
                if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                    currentMoveIndex++;
                    updateMoveButtons();
                    highlightCurrentMove();
                    
                    // Check if this is the final move and trigger completion indicator
                    if (currentMoveIndex >= currentGame.moves_detailed.length) {
                        setTimeout(() => {
                            showCompletionIndicator();
                        }, 200);
                    }
                    
                    // Update comment section with current move info
                    const move = currentGame.moves_detailed[currentMoveIndex - 1];
                    const moveNotation = move.white || move.black;
                    showMoveCommentary(move.commentary, moveNotation, move);
                    
                    checkChallengeProgress();
                    
                    // Auto-play the next move
                    if (currentMoveIndex < currentGame.moves_detailed.length) {
                        console.log('Scheduling auto-play in 0.2 seconds...');
                        setTimeout(() => {
                            autoPlayNextMove();
                        }, 200); // Wait 0.2 seconds before auto-playing
                    } else {
                        console.log('No more moves to auto-play');
                    }
                }
                
                // Clear selection
                clearSelection();
                
                // Reinitialize drag and drop
                setTimeout(() => {
                    reinitializeDragAndDrop();
                }, 100);
            } else {
                console.log('Invalid move to', clickedSquareNotation);
                // Clear selection on invalid move
                clearSelection();
            }
        }

        // Clear piece selection and highlights
        function clearSelection() {
            // Clear visual highlights
            const selectedSquares = document.querySelectorAll('.chess-square.selected');
            selectedSquares.forEach(square => square.classList.remove('selected'));
            
            clearHighlights();
            
            // Clear selection variables
            selectedPiece = null;
            selectedSquare = null;
            draggedPiece = null;
            draggedFromSquare = null;
            validMoves = [];
        }

        // Calculate valid moves for current piece
        function calculateValidMoves() {
            if (!currentGame || currentMoveIndex >= currentGame.moves_detailed.length) {
                validMoves = [];
                return;
            }
            
            const currentMove = currentGame.moves_detailed[currentMoveIndex];
            const isWhiteMove = !!currentMove.white;
            
            // Check if the dragged piece is the correct piece for this move
            const expectedFrom = isWhiteMove ? currentMove.white_from : currentMove.black_from;
            const expectedTo = isWhiteMove ? currentMove.white_to : currentMove.black_to;
            
            console.log('Calculating valid moves:');
            console.log('Dragged from square:', draggedFromSquare);
            console.log('Expected from square:', expectedFrom);
            console.log('Expected to square:', expectedTo);
            console.log('Is white move:', isWhiteMove);
            
            if (draggedFromSquare !== expectedFrom) {
                console.log('Wrong piece selected! Expected piece on', expectedFrom, 'but selected piece on', draggedFromSquare);
                validMoves = [];
                return;
            }
            
            // Set valid destination square
            validMoves = [expectedTo];
            console.log('Valid moves set to:', validMoves);
        }

        // Highlight valid moves for current piece (only in normal mode)
        function highlightValidMoves() {
            // Calculate valid moves first
            calculateValidMoves();
            
            // Don't highlight moves in challenge mode - pure memory test
            if (isChallengeMode) {
                console.log('Challenge mode active - no move highlighting');
                return;
            }
            
            // Highlight valid squares with green border
            validMoves.forEach(squareNotation => {
                const square = getSquareByNotation(squareNotation);
                if (square) {
                    square.classList.add('valid-move');
                    console.log('Highlighted square:', squareNotation);
                }
            });
        }


        // Clear move highlights
        function clearHighlights() {
            const squares = document.querySelectorAll('.chess-square');
            squares.forEach(square => {
                square.classList.remove('valid-move');
            });
        }

        // Handle drag over
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation(); // Prevent event bubbling to avoid infinite loops
            e.dataTransfer.dropEffect = 'move';
            
            // Only process if we're dragging over a square, not a piece
            if (e.target.classList.contains('chess-piece')) {
                return; // Don't process dragover events on pieces
            }
        }

        // Handle drop
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation(); // Prevent event bubbling
            
            console.log('Drop event triggered');
            console.log('Dragged piece:', draggedPiece);
            console.log('Dragged from square:', draggedFromSquare);
            
            if (!draggedPiece || !draggedFromSquare) {
                console.log('No dragged piece or from square');
                return;
            }
            
            // Find the square element (not the piece)
            let toSquare = e.target;
            
            // If we dropped on a piece, get its parent square
            if (toSquare.classList.contains('chess-piece')) {
                toSquare = toSquare.parentElement;
            }
            
            // Make sure we have a square element
            if (!toSquare.classList.contains('chess-square')) {
                return;
            }
            
            const toSquareNotation = getSquareNotationFromElement(toSquare);
            
            // Check if this is a valid move
            if (validMoves.includes(toSquareNotation)) {
                console.log('Valid move! Executing move from', draggedFromSquare, 'to', toSquareNotation);
                
                // Move the piece directly without animation since it's already being dragged
                movePieceDirectly(draggedFromSquare, toSquareNotation, draggedPiece.dataset.piece);
                
                // Reset idle timer after move
                progressTracker.resetIdleTimer();
                
                 // Advance to next move
                 if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                     currentMoveIndex++;
                     updateMoveButtons();
                     highlightCurrentMove();
                     
                     // Check if this is the final move and trigger completion indicator
                     if (currentMoveIndex >= currentGame.moves_detailed.length) {
                         setTimeout(() => {
                             showCompletionIndicator();
                         }, 200);
                     }
                     
                     // Update comment section with current move info
                     const move = currentGame.moves_detailed[currentMoveIndex - 1];
                     const moveNotation = move.white || move.black;
                     showMoveCommentary(move.commentary, moveNotation, move);
                     
                     // Check challenge progress
                     checkChallengeProgress();
                     
                     // Auto-play the next move
                     if (currentMoveIndex < currentGame.moves_detailed.length) {
                         console.log('Scheduling auto-play in 0.2 seconds...');
                         setTimeout(() => {
                             autoPlayNextMove();
                         }, 200); // Wait 0.2 seconds before auto-playing
                     } else {
                         console.log('No more moves to auto-play');
                     }
                 }
                 
                 // Small delay to ensure the move is processed, then re-initialize
                 setTimeout(() => {
                     reinitializeDragAndDrop();
                 }, 100);
            } else {
                console.log('Invalid move! Cannot drop on', toSquareNotation);
            }
        }

        // Get square notation from element
        function getSquareNotationFromElement(squareElement) {
            // Get the notation directly from the data-square attribute
            return squareElement.dataset.square;
        }

        // Execute a move (either by drag or button)
        function executeMove(from, to, piece) {
            // Move the piece with animation
            movePiece(from, to, piece, true);
            
            // Advance to next move
            if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                currentMoveIndex++;
                updateMoveButtons();
            }
        }

        // Move piece directly without animation (for drag and drop)
        function movePieceDirectly(from, to, piece) {
            // Start training timer on piece movement
            progressTracker.startTrainingTimer();
            
            console.log('=== MOVE PIECE DIRECTLY ===');
            console.log('Moving piece from', from, 'to', to);
            const fromSquare = getSquareByNotation(from);
            const toSquare = getSquareByNotation(to);
            
            if (fromSquare && toSquare) {
                // Ensure board is in dragging state to disable transitions
                const board = document.getElementById('chess-board');
                board.classList.add('dragging');
                
                // Clear valid-move class from ALL squares BEFORE making changes
                // This prevents size changes during the move operation
                clearHighlights();
                
                // Clear source square completely but preserve notation
                const sourceNotation = fromSquare.querySelector('.square-index');
                fromSquare.innerHTML = '';
                if (sourceNotation) {
                    fromSquare.appendChild(sourceNotation);
                }
                
                // Clear destination square (in case there's a piece to capture) but preserve notation
                const destNotation = toSquare.querySelector('.square-index');
                toSquare.innerHTML = '';
                if (destNotation) {
                    toSquare.appendChild(destNotation);
                }
                
                // Create new piece at destination
                const pieceElement = createDraggablePiece(piece, to);
                toSquare.appendChild(pieceElement);
                
                // Remove dragging class after a short delay to re-enable transitions
                setTimeout(() => {
                    board.classList.remove('dragging');
                }, 50);
                
                console.log('Move completed');
                
                // Play move sound effect
                playSound(false);
            } else {
                console.log('Invalid squares - from:', fromSquare, 'to:', toSquare);
            }
            console.log('=== END MOVE PIECE DIRECTLY ===');
        }



        // Animate existing piece from source to destination
        function animateExistingPiece(sourceSquare, destinationSquare, pieceImage) {
            // Get the existing piece from source square
            const existingPiece = sourceSquare.querySelector('.chess-piece');
            if (!existingPiece) return;

            // Get the chess board container
            const board = document.getElementById('chess-board');
            
            // Create a temporary piece for animation
            const tempPiece = existingPiece.cloneNode(true);
            tempPiece.style.position = 'absolute';
            tempPiece.style.zIndex = '1000';
            tempPiece.style.pointerEvents = 'none';
            tempPiece.style.width = '60px';
            tempPiece.style.height = '60px';
            tempPiece.style.transition = 'all 0.3s ease-in-out';

            // Get positions
            const sourceRect = sourceSquare.getBoundingClientRect();
            const destRect = destinationSquare.getBoundingClientRect();
            const boardRect = board.getBoundingClientRect();

            // Calculate positions relative to the board
            const sourceLeft = sourceRect.left - boardRect.left;
            const sourceTop = sourceRect.top - boardRect.top;
            const destLeft = destRect.left - boardRect.left;
            const destTop = destRect.top - boardRect.top;

            // Position the temp piece at source
            tempPiece.style.left = sourceLeft + 'px';
            tempPiece.style.top = sourceTop + 'px';

            // Add to board
            board.appendChild(tempPiece);

            // Remove the original piece immediately to prevent double pieces but preserve notation
            const sourceNotation = sourceSquare.querySelector('.square-index');
            sourceSquare.innerHTML = '';
            if (sourceNotation) {
                sourceSquare.appendChild(sourceNotation);
            }

            // Animate to destination
            requestAnimationFrame(() => {
                tempPiece.style.left = destLeft + 'px';
                tempPiece.style.top = destTop + 'px';
            });

            // After animation, place piece in destination square and clean up
            setTimeout(() => {
                // Remove temp piece
                if (tempPiece.parentNode) {
                    tempPiece.parentNode.removeChild(tempPiece);
                }

                // Clear destination square completely before placing new piece but preserve notation
                const destNotation = destinationSquare.querySelector('.square-index');
                destinationSquare.innerHTML = '';
                if (destNotation) {
                    destinationSquare.appendChild(destNotation);
                }
                
                // Create a new draggable piece at destination
                const newPiece = createDraggablePiece(pieceImage, getSquareNotationFromElement(destinationSquare));
                destinationSquare.appendChild(newPiece);
                
                // Play sound after animation completes
                playSound(false);
                
                // Re-initialize drag and drop for all pieces
                reinitializeDragAndDrop();
            }, 300);
        }

        // Show move commentary
        function showMoveCommentary(commentary, move, moveData) {
            // Update the comment content
            const commentContent = document.getElementById('comment-content');
            
            if (commentContent && moveData) {
                const moveNumber = moveData.move_number;
                const player = moveData.white ? 'White' : 'Black';
                const evaluation = moveData.evaluation || 'N/A';
                const annotation = moveData.annotation || '';
                const description = moveData.description || '';
                
                let content = `<strong>Move ${moveNumber} (${player}):</strong> ${convertToChessSymbols(move)} ${annotation}<br>`;
                content += `<strong>Evaluation:</strong> ${evaluation}`;
                if (commentary) {
                    content += `<br>${commentary}`;
                }
                
                commentContent.innerHTML = content;
            } else if (commentContent) {
                commentContent.innerHTML = `<strong>Move ${convertToChessSymbols(move)}:</strong><br>${commentary}`;
            }
        }

        // Display game moves
        function displayGameMoves(game) {
            const movesList = document.getElementById('moves-list');
            movesList.innerHTML = '';
            
            // Reset comment section when displaying new game
            const commentContent = document.getElementById('comment-content');
            if (commentContent) {
                commentContent.innerHTML = 'Click on any move to see detailed commentary';
            }


            // Group moves by move number (white and black moves together)
            const moveGroups = {};
            game.moves_detailed.forEach(move => {
                if (!moveGroups[move.move_number]) {
                    moveGroups[move.move_number] = { white: null, black: null };
                }
                if (move.white) {
                    moveGroups[move.move_number].white = move.white;
                }
                if (move.black) {
                    moveGroups[move.move_number].black = move.black;
                }
            });

            // Display all moves in a structured layout
            const moveItem = document.createElement('div');
            moveItem.className = 'move-item';
            
            // Create move numbers and moves
            Object.keys(moveGroups).forEach((moveNumber, moveIndex) => {
                const group = moveGroups[moveNumber];
                
                // Add HR line before the puzzle start move if this is the initial move index
                // Calculate the move number that corresponds to the initial_move_index
                const moveNumberForInitialIndex = Math.floor(game.initial_move_index / 2) + 1;
                if (game.initial_move_index && parseInt(moveNumber) === moveNumberForInitialIndex) {
                    const hr = document.createElement('hr');
                    hr.style.cssText = 'margin: 10px 0; border: none; border-top: 1px solid #ccc;';
                    moveItem.appendChild(hr);
                }
                
                // Create move row
                const moveRow = document.createElement('div');
                moveRow.className = 'move-row';
                
                // Add move number to the row
                const moveNumberSpan = document.createElement('span');
                moveNumberSpan.textContent = moveNumber + '.';
                moveNumberSpan.className = 'move-number';
                moveRow.appendChild(moveNumberSpan);
                
                // Create white moves container
                const whiteMoves = document.createElement('div');
                whiteMoves.className = 'white-moves';
                
                // Create black moves container
                const blackMoves = document.createElement('div');
                blackMoves.className = 'black-moves';
                
                // Add white move if it exists
                if (group.white) {
                    const whiteMoveSpan = document.createElement('span');
                    whiteMoveSpan.textContent = convertToChessSymbols(group.white);
                    whiteMoveSpan.className = 'clickable-move';
                    whiteMoveSpan.dataset.moveIndex = moveIndex * 2;
                    
                    // Find the move data for annotations and evaluation
                    const whiteMoveData = game.moves_detailed.find(m => m.white === group.white && m.move_number == moveNumber);
                    if (whiteMoveData) {
                        // Add annotation if it exists
                        if (whiteMoveData.annotation) {
                            const annotationSpan = document.createElement('span');
                            annotationSpan.textContent = whiteMoveData.annotation;
                            annotationSpan.className = 'move-annotation';
                            annotationSpan.style.marginLeft = '4px';
                            annotationSpan.style.color = '#000000';
                            whiteMoveSpan.appendChild(annotationSpan);
                        }
                        
                    }
                    
                    whiteMoves.appendChild(whiteMoveSpan);
                }
                
                // Add click listener to entire white-moves div
                whiteMoves.addEventListener('click', function() {
                    if (group.white) {
                        currentMoveIndex = moveIndex * 2 + 1;
                        updateBoardPosition();
                        updateMoveButtons();
                        
                        // Check if this is the final move and trigger completion indicator
                        if (currentMoveIndex >= game.moves_detailed.length) {
                            setTimeout(() => {
                                showCompletionIndicator();
                            }, 200);
                        }
                        
                        // Remove highlight from all moves and sections
                        moveItem.querySelectorAll('.clickable-move').forEach(span => {
                            span.classList.remove('active-move');
                        });
                        moveItem.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                            section.classList.remove('clicked');
                        });
                        // Highlight current move and section
                        if (group.white) {
                            whiteMoves.querySelector('.clickable-move').classList.add('active-move');
                        }
                        whiteMoves.classList.add('clicked');
                        
                        // Show commentary if available
                        const whiteMoveData = game.moves_detailed.find(m => m.white === group.white && m.move_number == moveNumber);
                        if (whiteMoveData) {
                            showMoveCommentary(whiteMoveData.commentary, group.white, whiteMoveData);
                        }
                    }
                });
                
                // Add black move if it exists
                if (group.black) {
                    const blackMoveSpan = document.createElement('span');
                    blackMoveSpan.textContent = convertToChessSymbols(group.black);
                    blackMoveSpan.className = 'clickable-move';
                    blackMoveSpan.dataset.moveIndex = moveIndex * 2 + 1;
                    
                    // Find the move data for annotations and evaluation
                    const blackMoveData = game.moves_detailed.find(m => m.black === group.black && m.move_number == moveNumber);
                    if (blackMoveData) {
                        // Add annotation if it exists
                        if (blackMoveData.annotation) {
                            const annotationSpan = document.createElement('span');
                            annotationSpan.textContent = blackMoveData.annotation;
                            annotationSpan.className = 'move-annotation';
                            annotationSpan.style.marginLeft = '4px';
                            annotationSpan.style.color = '#000000';
                            blackMoveSpan.appendChild(annotationSpan);
                        }
                        
                    }
                    
                    blackMoves.appendChild(blackMoveSpan);
                }
                
                // Add click listener to entire black-moves div
                blackMoves.addEventListener('click', function() {
                    if (group.black) {
                        currentMoveIndex = moveIndex * 2 + 2;
                        updateBoardPosition();
                        updateMoveButtons();
                        
                        // Check if this is the final move and trigger completion indicator
                        if (currentMoveIndex >= game.moves_detailed.length) {
                            setTimeout(() => {
                                showCompletionIndicator();
                            }, 200);
                        }
                        
                        // Remove highlight from all moves and sections
                        moveItem.querySelectorAll('.clickable-move').forEach(span => {
                            span.classList.remove('active-move');
                        });
                        moveItem.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                            section.classList.remove('clicked');
                        });
                        // Highlight current move and section
                        if (group.black) {
                            blackMoves.querySelector('.clickable-move').classList.add('active-move');
                        }
                        blackMoves.classList.add('clicked');
                        
                        // Show commentary if available
                        const blackMoveData = game.moves_detailed.find(m => m.black === group.black && m.move_number == moveNumber);
                        if (blackMoveData) {
                            showMoveCommentary(blackMoveData.commentary, group.black, blackMoveData);
                        }
                    }
                });
                
                // Add moves to row
                moveRow.appendChild(whiteMoves);
                moveRow.appendChild(blackMoves);
                moveItem.appendChild(moveRow);
            });
            
            movesList.appendChild(moveItem);
            
            // Add result notation if the game ends in checkmate
            if (game.result && (game.result.includes('wins') || game.result.includes('White wins') || game.result.includes('Black wins'))) {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'game-result';
                resultDiv.style.cssText = 'text-align: center; font-weight: bold; font-size: 16px; margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px; border: 2px solid #dee2e6;';
                
                // Determine the result notation
                let resultNotation = '';
                if (game.result.includes('White wins')) {
                    resultNotation = '1-0';
                } else if (game.result.includes('Black wins')) {
                    resultNotation = '0-1';
                }
                
                if (resultNotation) {
                    resultDiv.textContent = resultNotation;
                    movesList.appendChild(resultDiv);
                }
            }

        }

        // Function to attach event listeners for game header dropdown
        function attachGameHeaderEventListeners() {
            const gameHeader = document.getElementById('game-header');
            const gameDetails = document.getElementById('game-details');
            
            if (gameHeader && gameDetails) {
                // Remove any existing event listeners by cloning the element
                const newGameHeader = gameHeader.cloneNode(true);
                gameHeader.parentNode.replaceChild(newGameHeader, gameHeader);
                
                // Re-attach the event listener
                newGameHeader.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Game header clicked');
                    newGameHeader.classList.toggle('expanded');
                    gameDetails.classList.toggle('show');
                });
                
                console.log('Game header event listeners attached');
            } else {
                console.log('Game header or game details not found');
            }
        }

        // Function to restore main game event listeners
        function restoreMainGameEventListeners() {
            console.log('=== RESTORING MAIN GAME EVENT LISTENERS ===');
            const pieces = document.querySelectorAll('.piece');
            console.log('Found pieces:', pieces.length);
            pieces.forEach((piece, index) => {
                console.log(`Piece ${index}:`, piece);
                // Remove custom game event listeners
                piece.removeEventListener('click', handleCustomPieceClick);
                piece.removeEventListener('dragstart', handleCustomDragStart);
                piece.removeEventListener('dragend', handleCustomDragEnd);
                
                // Restore main game event listeners
                piece.addEventListener('dragstart', handleDragStart);
                piece.addEventListener('dragend', handleDragEnd);
                piece.addEventListener('click', handlePieceClick);
                console.log(`Restored event listeners for piece ${index}`);
            });
        }

        // Function to completely exit custom game mode
        function exitCustomGameMode() {
            // Reset custom game variables
            if (typeof customGameMode !== 'undefined') {
                customGameMode = false;
                window.customGameMode = false;
            }
            
            // Clear custom game elements
            clearCustomGameElements();
            
            // Hide custom game info section
            if (typeof hideCustomGameInfo === 'function') {
                hideCustomGameInfo();
            }
            
            // Hide custom save button
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            
            // Hide custom commentary section
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            
            // Hide custom save message
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }
            
            // Restore main game event listeners
            restoreMainGameEventListeners();
        }

        // Display selected game
        function displayGame(gameId) {
            console.log('Displaying game:', gameId);
            console.log('Games data:', gamesData);
            
            // Always exit custom game mode when displaying any game
            exitCustomGameMode();
            
            // Exit test mode if switching to a different game
            if (isChallengeMode && currentGame && currentGame.id !== gameId) {
                toggleChallengeMode();
            }
            
            if (!gamesData) {
                console.error('No games data available');
                return;
            }
            
            const game = gamesData.games.find(g => g.id === gameId);
            console.log('Found game:', game);
            
            if (!game) {
                console.error('Game not found:', gameId);
                return;
            }

            // Set current game and reset move index
            currentGame = game;
            // Check if game has a custom initial move index, otherwise start at 0
            currentMoveIndex = game.initial_move_index || 0;
            
            // Start training session tracking based on type
            const sessionType = currentGame.type === 'puzzle' ? 'puzzle' : 'game';
            progressTracker.startSession(sessionType);
            
            // Update selected state for game buttons
            document.querySelectorAll('.submenu-button').forEach(btn => {
                btn.classList.remove('selected');
            });
            const selectedButton = document.querySelector(`[data-game-id="${gameId}"]`);
            if (selectedButton) {
                selectedButton.classList.add('selected');
            }
            
            // Reset the board to starting position
            resetBoard();
            
            // Clear any piece selection
            clearSelection();
            
            // Reset to normal visual mode when switching games
            currentVisualMode = 'normal';
            switchVisualMode('normal');

            // Show game display
            const gameDisplay = document.getElementById('game-display');
            gameDisplay.classList.add('show');

            // Show and update game header in moves panel
            const gameHeader = document.getElementById('game-header');
            gameHeader.style.display = 'block';
            document.getElementById('game-title-line').innerHTML = `<span>${game.name}</span>`;
            
            // Event listeners are handled via delegation, no need to reattach

            // Show moves toggle
            const movesToggle = document.getElementById('moves-toggle');
            movesToggle.style.display = 'block';

            // Show comment section for games with commentary
            const commentSection = document.getElementById('comment-section');
            if (commentSection) {
                if (game.id.startsWith('custom-game-')) {
                    // For custom games, show comment section if they have commentary
                    const hasCommentary = game.moves_detailed && game.moves_detailed.some(move => move.commentary && move.commentary.trim() !== '');
                    commentSection.style.display = hasCommentary ? 'block' : 'none';
                } else {
                    commentSection.style.display = 'block';
                }
            }
            
            // Handle custom game elements visibility
            if (game.id.startsWith('custom-game-')) {
                // Show custom game elements for custom games
                // Ensure moves list is visible for saved custom games
                const movesList = document.getElementById('moves-list');
                if (movesList) {
                    movesList.style.display = 'block';
                }
            } else {
                // Hide custom game elements for preprogrammed games
                if (typeof hideCustomGameInfo === 'function') {
                    hideCustomGameInfo();
                }
                if (typeof hideCustomSaveButton === 'function') {
                    hideCustomSaveButton();
                }
                if (typeof hideCustomCommentarySection === 'function') {
                    hideCustomCommentarySection();
                }
                if (typeof hideCustomSaveMessage === 'function') {
                    hideCustomSaveMessage();
                }
            }

            // Populate game details
            populateGameDetails(game);

            // Setup board and display moves
            setupInitialPosition();
            reinitializeDragAndDrop(); // Ensure click handlers are attached
            displayGameMoves(game);
            updateMoveButtons();
            
            // If game has a custom initial move index, update board to that position
            if (game.initial_move_index && game.initial_move_index > 0) {
                updateBoardPosition();
            }
             highlightCurrentMove();
             
            // Show/hide delete button for custom games (only when viewing saved custom games, not in Add Game mode)
            const deleteGameSection = document.getElementById('delete-game-section');
            const deleteGameBtn = document.getElementById('delete-game-btn');
            if (game.id.startsWith('custom-game-') && !window.customGameMode) {
                deleteGameSection.style.display = 'block';
                deleteGameBtn.onclick = (e) => deleteCustomGame(e, game.id);
                 
                 // Hide custom commentary section and save button when viewing saved custom games
                 if (typeof hideCustomCommentarySection === 'function') {
                     hideCustomCommentarySection();
                 }
                 if (typeof hideCustomSaveButton === 'function') {
                     hideCustomSaveButton();
                 }
             } else {
                 deleteGameSection.style.display = 'none';
             }
             
             // Update game list badges
             updateGameListBadges();
             
             // Visual mode placeholder - no effects applied yet
        }

        // Populate game details
        function populateGameDetails(game) {
            document.getElementById('detail-description').textContent = game.description;
            document.getElementById('detail-moves').textContent = `${game.moves} moves`;
            document.getElementById('detail-white').textContent = game.white_player;
            document.getElementById('detail-black').textContent = game.black_player;
            document.getElementById('detail-opening').textContent = game.opening;
            document.getElementById('detail-difficulty').textContent = game.difficulty;
            
            // Generate interesting facts based on the game
            let facts = '';
            if (game.id === 'fools-mate') {
                facts = 'This is the fastest possible checkmate in chess, occurring in just 2 moves. It requires White to make two very weak moves (f3 and g4) that weaken the king\'s position. This pattern is rarely seen in actual games as it requires White to make such poor moves.';
            } else if (game.id === 'scholars-mate') {
                facts = 'Also known as the "Four-Move Checkmate", this is one of the most famous quick checkmate patterns. It targets the f7 square, which is only defended by the king in the starting position. This pattern is commonly attempted by beginners but is easily defended against by experienced players.';
            } else if (game.id === 'legals-mate') {
                facts = 'This famous trap was played by Legall de Kermeur in 1750. It demonstrates the power of tactical sacrifices - White sacrifices the queen to set up a devastating checkmate. The game shows how seemingly good moves (like capturing the queen) can lead to immediate defeat.';
            } else if (game.id === 'Kostic-nn-1910') {
                facts = 'This famous miniature from 1910 features Boris Kostic, a Serbian grandmaster known for his aggressive style. The game demonstrates brilliant counter-attacking play - Black turns the tables after White\'s tactical mistake. Kostic was one of the strongest players of his era and this game showcases his tactical prowess. The "NN" notation means "No Name" - the opponent\'s identity was not recorded. This game is studied as a perfect example of how to punish premature piece development.';
            } else if (game.id === 'legal-trap') {
                facts = 'The Légal Trap is one of the most famous tactical combinations in chess history, named after Legall de Kermeur who played it in 1750. This trap demonstrates the power of piece coordination and tactical vision. The key insight is that material advantage (having a queen) is less important than having a winning position. This game is studied by chess players of all levels as a perfect example of how to recognize and execute tactical combinations.';
            } else if (game.id === 'englund-gambit-trap') {
                facts = 'The Englund Gambit Trap is named after Swedish player Fritz Englund (1871-1933). This famous trap punishes White for playing the "natural" Bf4 move, which looks like good development but actually falls into Black\'s tactical web. The trap has defeated many strong players and teaches important lessons about the dangers of automatic play.';
            }
            document.getElementById('detail-facts').textContent = facts;
        }

        // Toggle moves visibility
        function toggleMovesVisibility() {
            const movesList = document.getElementById('moves-list');
            const commentSection = document.getElementById('comment-section');
            const toggleImg = document.getElementById('moves-toggle-img');
            
            if (movesList.style.display === 'none') {
                movesList.style.display = 'block';
                // Show comment section for games with commentary
                if (currentGame) {
                    if (currentGame.id.startsWith('custom-game-')) {
                        // For custom games, show comment section if they have commentary
                        const hasCommentary = currentGame.moves_detailed && currentGame.moves_detailed.some(move => move.commentary && move.commentary.trim() !== '');
                        commentSection.style.display = hasCommentary ? 'block' : 'none';
                    } else {
                        commentSection.style.display = 'block';
                    }
                }
                toggleImg.src = 'images/hide.png';
            } else {
                movesList.style.display = 'none';
                commentSection.style.display = 'none';
                toggleImg.src = 'images/view.png';
            }
        }

        // Create confetti effect
        function createConfetti() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.position = 'fixed';
                confetti.style.width = '10px';
                confetti.style.height = '10px';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.top = '-10px';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.zIndex = '9999';
                confetti.style.pointerEvents = 'none';
                confetti.style.animation = 'confetti-fall 3s linear forwards';
                confetti.style.animationDelay = Math.random() * 2 + 's';
                
                document.body.appendChild(confetti);
                
                // Remove confetti after animation
                setTimeout(() => {
                    if (confetti.parentNode) {
                        confetti.parentNode.removeChild(confetti);
                    }
                }, 5000);
            }
        }

        // Show completion indicator on the piece that made the final move
        function showCompletionIndicator() {
            if (!currentGame || currentMoveIndex < currentGame.moves_detailed.length) return;
            
            // Get the last move to find which piece moved
            const lastMove = currentGame.moves_detailed[currentGame.moves_detailed.length - 1];
            const moveNotation = lastMove.white || lastMove.black;
            const isWhiteMove = !!lastMove.white;
            
            // Parse the move to get the destination square
            const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
            if (parsedMove) {
                const destinationSquare = document.querySelector(`[data-square="${parsedMove.target}"]`);
                if (destinationSquare) {
                    // Remove any existing completion indicator
                    const existingIndicator = document.querySelector('.completion-indicator');
                    if (existingIndicator) {
                        existingIndicator.remove();
                    }
                    
                    // Create new completion indicator
                    const indicator = document.createElement('div');
                    indicator.className = 'completion-indicator';
                    indicator.innerHTML = '✓';
                    indicator.title = 'Game completed!';
                    
                    // Make sure the square has relative positioning
                    destinationSquare.style.position = 'relative';
                    
                    // Add the indicator to the destination square
                    destinationSquare.appendChild(indicator);
                }
            }
        }

        // Remove completion indicator
        function removeCompletionIndicator() {
            const existingIndicator = document.querySelector('.completion-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
        }

        // Convert chess piece letters to symbols
        function convertToChessSymbols(notation) {
            if (!notation) return notation;
            
            return notation
                .replace(/K/g, '♔')  // King
                .replace(/Q/g, '♕')  // Queen
                .replace(/R/g, '♖')  // Rook
                .replace(/B/g, '♗')  // Bishop
                .replace(/N/g, '♘')  // Knight
                .replace(/P/g, '♙')  // Pawn
                .replace(/k/g, '♚')  // Black King
                .replace(/q/g, '♛')  // Black Queen
                .replace(/r/g, '♜')  // Black Rook
                .replace(/b/g, '♝')  // Black Bishop
                .replace(/n/g, '♞')  // Black Knight
                .replace(/p/g, '♟')  // Black Pawn
                .replace(/x/g, '×')  // Capture symbol
                .replace(/\+/g, '+')  // Check symbol
                .replace(/#/g, '#');  // Checkmate symbol
        }

        // Add click event listener to moves toggle image
        document.addEventListener('DOMContentLoaded', function() {
            const toggleImg = document.getElementById('moves-toggle-img');
            if (toggleImg) {
                toggleImg.addEventListener('click', toggleMovesVisibility);
            }

        });

        // Function to highlight the current move in the moves list
        function highlightCurrentMove() {
            if (!currentGame) return;
            
            // Use setTimeout to ensure this runs after DOM updates
            setTimeout(() => {
                // Remove all existing highlights
                document.querySelectorAll('.clickable-move').forEach(span => {
                    span.classList.remove('active-move');
                });
                document.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                    section.classList.remove('clicked');
                });
                
                // If at initial position, don't highlight anything
                if (currentMoveIndex === 0) return;
                
                // Calculate which move to highlight
                const moveNumber = Math.ceil(currentMoveIndex / 2);
                const isWhiteMove = currentMoveIndex % 2 === 1;
                
                // Find all move rows
                const moveRows = document.querySelectorAll('.move-row');
                
                // Find the target move row (0-based indexing)
                const targetMoveRow = moveRows[moveNumber - 1];
                if (!targetMoveRow) return;
                
                let highlightedElement = null;
                
                // Highlight the appropriate move
                if (isWhiteMove) {
                    const whiteMoves = targetMoveRow.querySelector('.white-moves');
                    if (whiteMoves) {
                        const clickableMove = whiteMoves.querySelector('.clickable-move');
                        if (clickableMove) {
                            clickableMove.classList.add('active-move');
                        }
                        whiteMoves.classList.add('clicked');
                        highlightedElement = whiteMoves;
                    }
                } else {
                    const blackMoves = targetMoveRow.querySelector('.black-moves');
                    if (blackMoves) {
                        const clickableMove = blackMoves.querySelector('.clickable-move');
                        if (clickableMove) {
                            clickableMove.classList.add('active-move');
                        }
                        blackMoves.classList.add('clicked');
                        highlightedElement = blackMoves;
                    }
                }
                
                // Auto-scroll the highlighted move into view
                if (highlightedElement) {
                    // Use a slight delay to ensure highlighting is complete
                    setTimeout(() => {
                        highlightedElement.scrollIntoView({
                            behavior: 'smooth',
                            block: 'nearest',
                            inline: 'nearest'
                        });
                    }, 50);
                }
            }, 10);
        }

        // Move navigation functions
        function goToInitialPosition() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToFirstCustomMove();
                return;
            }
            
            clearSelection();
            currentMoveIndex = 0;
            
            // Reset the move parser's position tracking
            moveParser.resetBoard();
            
            setupInitialPosition();
            updateMoveButtons();
            highlightCurrentMove();
            
            // Remove completion indicator when going to initial position
            removeCompletionIndicator();
            
            // Clear comment section at initial position
            const commentContent = document.getElementById('comment-content');
            if (commentContent) {
                commentContent.innerHTML = 'Click on any move to see detailed commentary';
            }
            
            // Play sound for user feedback
            playSound(false);
        }

        function goToPreviousMove() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToPreviousCustomMove();
                return;
            }
            
            if (currentMoveIndex > 0) {
                clearSelection();
                currentMoveIndex--;
                updateBoardPosition();
                updateMoveButtons();
                highlightCurrentMove();
                
                // Remove completion indicator when moving away from final position
                removeCompletionIndicator();
                
                // Update comment section with current move info only if moves are visible
                const movesList = document.getElementById('moves-list');
                if (movesList.style.display !== 'none') {
                    if (currentMoveIndex === 0) {
                        // Clear comment section if at initial position
                        const commentContent = document.getElementById('comment-content');
                        if (commentContent) {
                            commentContent.innerHTML = 'Click on any move to see detailed commentary';
                        }
                    } else if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                        // Show commentary for the move we just went back to
                        const move = currentGame.moves_detailed[currentMoveIndex - 1];
                        const moveNotation = move.white || move.black;
                        showMoveCommentary(move.commentary, moveNotation, move);
                    }
                }
            }
        }

        function goToNextMove() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToNextCustomMove();
                return;
            }
            
            console.log('goToNextMove called - currentMoveIndex:', currentMoveIndex, 'total moves:', currentGame ? currentGame.moves_detailed.length : 'no game');
            
            if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                clearSelection();
                const move = currentGame.moves_detailed[currentMoveIndex];
                const moveNotation = move.white || move.black;
                const isWhiteMove = !!move.white;
                
                console.log('Move data:', move);
                console.log('Move notation:', moveNotation);
                console.log('Is white move:', isWhiteMove);
                
                // Use JSON coordinates if available, otherwise parse the move notation
                let sourceSquare, destinationSquare, pieceImage;
                
                if (move.white_from && move.white_to) {
                    // Use coordinates from JSON for white moves
                    sourceSquare = getSquareByNotation(move.white_from);
                    destinationSquare = getSquareByNotation(move.white_to);
                    
                    // Extract piece type from notation - handle different formats
                    let piece = 'P'; // Default to pawn
                    if (moveNotation.length > 0) {
                        const firstChar = moveNotation.charAt(0).toUpperCase();
                        if (['K', 'Q', 'R', 'B', 'N'].includes(firstChar)) {
                            piece = firstChar;
                        }
                    }
                    console.log('White move - piece from notation:', piece, 'notation:', moveNotation);
                    pieceImage = moveParser.getPieceImage(piece, isWhiteMove);
                } else if (move.black_from && move.black_to) {
                    // Use coordinates from JSON for black moves
                    sourceSquare = getSquareByNotation(move.black_from);
                    destinationSquare = getSquareByNotation(move.black_to);
                    
                    // Extract piece type from notation - handle different formats
                    let piece = 'P'; // Default to pawn
                    if (moveNotation.length > 0) {
                        const firstChar = moveNotation.charAt(0).toUpperCase();
                        if (['K', 'Q', 'R', 'B', 'N'].includes(firstChar)) {
                            piece = firstChar;
                        }
                    }
                    console.log('Black move - piece from notation:', piece, 'notation:', moveNotation);
                    pieceImage = moveParser.getPieceImage(piece, isWhiteMove);
                } else {
                    // Fallback to parsing move notation
                    const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
                    console.log('Parsed move:', parsedMove);
                    pieceImage = moveParser.getPieceImage(parsedMove.piece, isWhiteMove);
                    sourceSquare = getSquareByNotation(parsedMove.source);
                    destinationSquare = getSquareByNotation(parsedMove.target);
                }
                
                console.log('Using coordinates:', { source: move.white_from || move.black_from, target: move.white_to || move.black_to });
                
                if (moveNotation.includes('O-O')) {
                    // Handle castling
                    const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
                    applyCastling(parsedMove, true, true);
                } else if (sourceSquare && destinationSquare && pieceImage) {
                    // Use the proper animation for existing pieces
                    animateExistingPiece(sourceSquare, destinationSquare, pieceImage);
                    
                    // Update piece positions in the parser - use the piece from notation
                    const piece = moveNotation.charAt(0).toUpperCase();
                    const sourceNotation = move.white_from || move.black_from;
                    const targetNotation = move.white_to || move.black_to;
                    moveParser.updatePiecePosition(piece, sourceNotation, targetNotation, isWhiteMove);
                }
                    
                    currentMoveIndex++;
                    updateMoveButtons();
                    highlightCurrentMove();
                    
                    // Check if this is the final move and trigger completion indicator after animation
                    if (currentMoveIndex >= currentGame.moves_detailed.length) {
                        // Wait for animation to complete (300ms + buffer)
                        setTimeout(() => {
                            showCompletionIndicator();
                        }, 400);
                    }
                    
                    // Update comment section with current move info only if moves are visible
                    const movesList = document.getElementById('moves-list');
                    if (move && movesList.style.display !== 'none') {
                        showMoveCommentary(move.commentary, moveNotation, move);
                }
            }
        }

        function goToFinalPosition() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToLastCustomMove();
                return;
            }
            
            if (currentGame) {
                clearSelection();
                currentMoveIndex = currentGame.moves_detailed.length;
                updateBoardPosition();
                updateMoveButtons();
                highlightCurrentMove();
                
                // Trigger completion indicator for reaching final position
                setTimeout(() => {
                    showCompletionIndicator();
                }, 200);
                
                // Update comment section with the last move info only if moves are visible
                const movesList = document.getElementById('moves-list');
                if (movesList.style.display !== 'none' && currentGame.moves_detailed.length > 0) {
                    const lastMove = currentGame.moves_detailed[currentGame.moves_detailed.length - 1];
                    const moveNotation = lastMove.white || lastMove.black;
                    showMoveCommentary(lastMove.commentary, moveNotation, lastMove);
                }
            }
        }

        function updateBoardPosition() {
            if (!currentGame) return;
            
            console.log('Updating board position to move index:', currentMoveIndex);
            
            // Store completion indicator state before clearing
            const wasAtFinalPosition = currentMoveIndex >= currentGame.moves_detailed.length;
            
            // Clear the board completely but preserve square notation
            const board = document.getElementById('chess-board');
            const squares = board.querySelectorAll('.chess-square');
            squares.forEach(square => {
                const notation = square.querySelector('.square-index');
                square.innerHTML = '';
                if (notation) {
                    square.appendChild(notation);
                }
            });

            // Reset the move parser's position tracking
            moveParser.resetBoard();

            // Set up initial position
            setupInitialPosition();

            // Apply moves up to current position
            for (let i = 0; i < currentMoveIndex && i < currentGame.moves_detailed.length; i++) {
                const move = currentGame.moves_detailed[i];
                console.log(`Applying move ${i + 1}:`, move.white || move.black);
                applyMove(move, false, false);
            }
            
            // Play sound only for the current (last applied) move
            if (currentMoveIndex > 0 && currentMoveIndex <= currentGame.moves_detailed.length) {
                const lastMove = currentGame.moves_detailed[currentMoveIndex - 1];
                if (lastMove) {
                    // Check if it's a capture by looking for 'x' in the move notation
                    const moveNotation = lastMove.white || lastMove.black;
                    const isCapture = moveNotation && moveNotation.includes('x');
                    playSound(isCapture);
                }
            }

            // Re-initialize drag and drop for all pieces
            reinitializeDragAndDrop();
            
            // Update comment section with current move info
            if (currentMoveIndex > 0 && currentMoveIndex <= currentGame.moves_detailed.length) {
                const currentMove = currentGame.moves_detailed[currentMoveIndex - 1];
                const moveNotation = currentMove.white || currentMove.black;
                showMoveCommentary(currentMove.commentary, moveNotation, currentMove);
            } else if (currentMoveIndex === 0) {
                // Clear comment section at initial position
                const commentContent = document.getElementById('comment-content');
                if (commentContent) {
                    commentContent.innerHTML = 'Click on any move to see detailed commentary';
                }
            }
            
            // Update move highlighting
            highlightCurrentMove();
        }

        // Animate piece movement
        function animateMove(fromSquare, toSquare, pieceImage) {
            // Create a temporary piece for animation with exact same styling
            const tempPiece = document.createElement('div');
            tempPiece.className = 'chess-piece';
            tempPiece.style.backgroundImage = `url('pieces/${pieceImage}')`;
            tempPiece.style.backgroundSize = 'contain';
            tempPiece.style.backgroundRepeat = 'no-repeat';
            tempPiece.style.backgroundPosition = 'center';
            tempPiece.style.position = 'absolute';
            tempPiece.style.zIndex = '1000';
            tempPiece.style.pointerEvents = 'none';
            tempPiece.style.width = '60px';
            tempPiece.style.height = '60px';
            tempPiece.style.transition = 'all 0.3s ease-in-out';
            
            // Get the chess board container
            const board = document.getElementById('chess-board');
            const boardRect = board.getBoundingClientRect();
            
            // Get positions relative to the board
            const fromRect = fromSquare.getBoundingClientRect();
            const toRect = toSquare.getBoundingClientRect();
            
            // Position the temp piece at the source (relative to board)
            tempPiece.style.left = (fromRect.left - boardRect.left) + 'px';
            tempPiece.style.top = (fromRect.top - boardRect.top) + 'px';
            
            // Add to board with relative positioning
            board.style.position = 'relative';
            board.appendChild(tempPiece);
            
            // Animate to destination
            requestAnimationFrame(() => {
                tempPiece.style.left = (toRect.left - boardRect.left) + 'px';
                tempPiece.style.top = (toRect.top - boardRect.top) + 'px';
            });
            
            // Clean up after animation
            setTimeout(() => {
                if (tempPiece.parentNode) {
                    tempPiece.parentNode.removeChild(tempPiece);
                }
            }, 350);
        }

        function applyMove(move, animate = false, enableSound = true) {
            if (!move.white && !move.black) return;

            const moveNotation = move.white || move.black;
            const isWhiteMove = !!move.white;
            
            console.log('Applying move:', moveNotation, 'isWhite:', isWhiteMove);
            
            // Parse the move using the universal parser
            const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
            console.log('Parsed move:', parsedMove);
            
            if (parsedMove.isCastling) {
                applyCastling(parsedMove, animate, enableSound);
                } else {
                const pieceImage = moveParser.getPieceImage(parsedMove.piece, isWhiteMove);
                movePiece(parsedMove.source, parsedMove.target, pieceImage, animate, enableSound);
                
                // Update piece positions in the parser
                moveParser.updatePiecePosition(parsedMove.piece, parsedMove.source, parsedMove.target, isWhiteMove);
            }
        }
        
        function applyCastling(parsedMove, animate = false, enableSound = true) {
            const { source, target, isWhite, isLong } = parsedMove;
            
            // Move the king
            const kingImage = moveParser.getPieceImage('K', isWhite);
            movePiece(source, target, kingImage, animate, enableSound);
            
            // Move the rook
            const rookSource = isLong ? (isWhite ? 'a1' : 'a8') : (isWhite ? 'h1' : 'h8');
            const rookTarget = isLong ? (isWhite ? 'd1' : 'd8') : (isWhite ? 'f1' : 'f8');
            const rookImage = moveParser.getPieceImage('R', isWhite);
            movePiece(rookSource, rookTarget, rookImage, animate, enableSound);
            
            // Update piece positions
            moveParser.updatePiecePosition('K', source, target, isWhite);
            moveParser.updatePiecePosition('R', rookSource, rookTarget, isWhite);
        }

        function movePiece(from, to, piece, animate = false, enableSound = true) {
            // Start training timer on piece movement
            progressTracker.startTrainingTimer();
            
            const fromSquare = getSquareByNotation(from);
            const toSquare = getSquareByNotation(to);
            
            if (fromSquare && toSquare) {
                // Check if there's a piece being captured
                const isCapture = toSquare.innerHTML.trim() !== '';
                
                if (animate) {
                    // Clear destination square BEFORE animation to prevent overlay but preserve notation
                    const destNotation = toSquare.querySelector('.square-index');
                    toSquare.innerHTML = '';
                    if (destNotation) {
                        toSquare.appendChild(destNotation);
                    }
                    // Clear source square BEFORE animation to prevent duplicate pieces but preserve notation
                    const sourceNotation = fromSquare.querySelector('.square-index');
                    fromSquare.innerHTML = '';
                    if (sourceNotation) {
                        fromSquare.appendChild(sourceNotation);
                    }
                    // Animate the move
                    animateMove(fromSquare, toSquare, piece);
                    // Update the board after animation
                    setTimeout(() => {
                        // Ensure board is in dragging state to disable transitions
                        const board = document.getElementById('chess-board');
                        board.classList.add('dragging');
                        
                        const pieceElement = createDraggablePiece(piece, to);
                        toSquare.appendChild(pieceElement);
                        
                        // Remove dragging class after a short delay to re-enable transitions
                        setTimeout(() => {
                            board.classList.remove('dragging');
                        }, 50);
                        
                        // Play sound after animation completes
                        if (enableSound) playSound(isCapture);
                    }, 300);
                } else {
                    // Ensure board is in dragging state to disable transitions
                    const board = document.getElementById('chess-board');
                    board.classList.add('dragging');
                    
                    // Direct move without animation but preserve notation
                    const sourceNotation = fromSquare.querySelector('.square-index');
                    fromSquare.innerHTML = '';
                    if (sourceNotation) {
                        fromSquare.appendChild(sourceNotation);
                    }
                    const destNotation = toSquare.querySelector('.square-index');
                    toSquare.innerHTML = '';
                    if (destNotation) {
                        toSquare.appendChild(destNotation);
                    }
                    const pieceElement = createDraggablePiece(piece, to);
                    toSquare.appendChild(pieceElement);
                    
                    // Remove dragging class after a short delay to re-enable transitions
                    setTimeout(() => {
                        board.classList.remove('dragging');
                    }, 50);
                    
                    // Play sound immediately
                    if (enableSound) playSound(isCapture);
                }
            }
        }

        function getSquareByNotation(notation) {
            const board = document.getElementById('chess-board');
            
            // Use data-square attribute to find the correct square
            // This works regardless of board orientation since squares are labeled correctly
            return board.querySelector(`[data-square="${notation}"]`);
        }

        function updateMoveButtons() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                updateCustomMoveButtons();
                return;
            }
            
            const btnInitial = document.getElementById('btn-initial');
            const btnBack = document.getElementById('btn-back');
            const btnForward = document.getElementById('btn-forward');
            const btnFinal = document.getElementById('btn-final');

            if (!currentGame) {
                btnInitial.classList.add('disabled');
                btnBack.classList.add('disabled');
                btnForward.classList.add('disabled');
                btnFinal.classList.add('disabled');
                return;
            }

            // Update disabled states
            if (currentMoveIndex === 0) {
                btnInitial.classList.add('disabled');
                btnBack.classList.add('disabled');
            } else {
                btnInitial.classList.remove('disabled');
                btnBack.classList.remove('disabled');
            }

            if (currentMoveIndex >= currentGame.moves_detailed.length) {
                btnForward.classList.add('disabled');
                btnFinal.classList.add('disabled');
            } else {
                btnForward.classList.remove('disabled');
                btnFinal.classList.remove('disabled');
            }
        }

        // Visual mode functions (placeholder - no functionality yet)
        function switchVisualMode(mode) {
            currentVisualMode = mode;
            
            // Update active option
            const options = document.querySelectorAll('.mode-option');
            options.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.mode === mode) {
                    option.classList.add('active');
                }
            });
            
            // Apply visual effects
            applyVisualMode(mode);
        }

        // Flip notation function
        function flipNotation() {
            // Flip the letters (a-h)
            const letters = document.querySelectorAll('.notation-letter');
            const letterTexts = Array.from(letters).map(letter => letter.textContent);
            const reversedLetters = letterTexts.reverse();
            
            letters.forEach((letter, index) => {
                letter.textContent = reversedLetters[index];
            });
            
            // Flip the numbers (1-8)
            const numbers = document.querySelectorAll('.notation-number');
            const numberTexts = Array.from(numbers).map(number => number.textContent);
            const reversedNumbers = numberTexts.reverse();
            
            numbers.forEach((number, index) => {
                number.textContent = reversedNumbers[index];
            });
        }

        // Flip board function
        function flipBoard() {
            boardFlipped = !boardFlipped;
            
            // Update button appearance
            const flipBtn = document.getElementById('flip-board-btn');
            if (boardFlipped) {
                flipBtn.classList.add('flipped');
            } else {
                flipBtn.classList.remove('flipped');
            }
            
            // Flip the notation
            flipNotation();
            
            // Reinitialize the board with the new orientation
            initializeChessBoard();
            
            // If there's a current game, update the board position
            if (currentGame) {
                updateBoardPosition();
            } else {
                setupInitialPosition();
            }
            
            // Reinitialize drag and drop functionality
            reinitializeDragAndDrop();
        }

        function applyVisualMode(mode) {
            const pieces = document.querySelectorAll('.chess-piece');
            
            pieces.forEach(piece => {
                applyVisualModeToPiece(piece, mode);
            });
        }

        function applyVisualModeToPiece(piece, mode) {
            const currentPiece = piece.dataset.piece;
            
            // Store original piece type if not already stored
            if (!piece.dataset.originalPiece) {
                piece.dataset.originalPiece = currentPiece;
            }
            
            const originalPiece = piece.dataset.originalPiece;
            let newPiece = originalPiece; // Start with original piece
            
            switch(mode) {
                case 'grey':
                    // Switch all white pieces to black pieces
                    if (originalPiece.includes('lt45')) {
                        // White piece -> Black piece
                        newPiece = originalPiece.replace('lt45', 'dt45');
                    } else {
                        // Keep black pieces as black
                        newPiece = originalPiece;
                    }
                    piece.style.opacity = '1';
                    break;
                 case 'checkers':
                     // For checkers mode, use black plate for all pieces
                     newPiece = 'black-plate-for-your-kitchen-png.webp';
                     piece.style.opacity = '1';
                     break;
                case 'empty':
                    // Make pieces completely invisible
                    newPiece = originalPiece;
                    piece.style.opacity = '0';
                    piece.style.pointerEvents = 'auto'; // Ensure pieces remain clickable
                    break;
                case 'normal':
                default:
                    // Reset to original pieces with original colors
                    newPiece = originalPiece;
                    piece.style.opacity = '1';
                    break;
            }
            
            // Update the piece image if it changed
            if (newPiece !== currentPiece) {
                piece.dataset.piece = newPiece;
                piece.style.backgroundImage = `url('pieces/${newPiece}')`;
            }
         }

         // Challenge mode functions
         function toggleChallengeMode() {
             const challengeBtn = document.getElementById('challenge-btn');
             const modeOptions = document.querySelectorAll('.mode-option');
             const moveControls = document.querySelector('.move-controls');
             const movesList = document.getElementById('moves-list');
             const commentSection = document.getElementById('comment-section');
             
             if (!isChallengeMode && !currentGame) {
                 return;
             }
             
             if (!isChallengeMode) {
                 // Start challenge mode
                 isChallengeMode = true;
                 challengeBtn.textContent = 'Exit';
                 challengeBtn.classList.add('active');
                 
                 // Hide visual mode options and navigation buttons
                 modeOptions.forEach(option => {
                     option.style.display = 'none';
                 });
                 if (moveControls) {
                 moveControls.style.display = 'none';
                 }
                 if (movesList) {
                     movesList.style.display = 'block';
                 }
                 if (commentSection) {
                     commentSection.style.display = 'none';
                 }
                 
                // Reset to initial position (use game's initial_move_index if available)
                const initialIndex = currentGame.initial_move_index || 0;
                currentMoveIndex = initialIndex;
                setupInitialPosition();
                updateBoardPosition(); // Apply moves up to the initial position
                updateMoveButtons();
                highlightCurrentMove(); // Highlight the current move in the moves list
                 
                // Make all pieces slightly visible but still challenging
                const pieces = document.querySelectorAll('.chess-piece');
                pieces.forEach(piece => {
                    piece.style.opacity = '0.3'; // Slight opacity for visibility
                    piece.style.pointerEvents = 'auto'; // Ensure pieces remain clickable
                });
                 
                 console.log('Challenge mode started! Replay the game from memory.');
             } else {
                 // Exit challenge mode
                 isChallengeMode = false;
                 challengeBtn.textContent = 'Test';
                 challengeBtn.classList.remove('active');
                 
                 // Show visual mode options and navigation buttons
                 modeOptions.forEach(option => {
                     option.style.display = 'flex';
                 });
                 if (moveControls) {
                 moveControls.style.display = 'flex';
                 }
                 if (movesList) {
                     movesList.style.display = 'block';
                 }
                 if (commentSection) {
                     commentSection.style.display = 'block';
                 }
                 
                 // Restore full moves display
                 displayGameMoves(currentGame);
                 
                 // Restore current visual mode
                 applyVisualMode(currentVisualMode);
                 
                 console.log('Challenge mode ended!');
             }
         }
         
         function updateChallengeMovesDisplay() {
             if (!isChallengeMode || !currentGame) return;
             
             const movesList = document.getElementById('moves-list');
             if (!movesList) return;
             
             // Clear existing moves
             movesList.innerHTML = '';
             
             // Group moves by move number, but only show completed moves
             const moveGroups = {};
             const completedMoves = Math.floor(currentMoveIndex / 2);
             const isWhiteMoveCompleted = currentMoveIndex % 2 === 1;
             
             for (let i = 0; i < currentMoveIndex; i++) {
                 const move = currentGame.moves_detailed[i];
                 const moveNumber = Math.floor(i / 2) + 1;
                 
                 if (!moveGroups[moveNumber]) {
                     moveGroups[moveNumber] = {};
                 }
                 
                 if (i % 2 === 0) {
                     moveGroups[moveNumber].white = move.white || move.black;
                 } else {
                     moveGroups[moveNumber].black = move.white || move.black;
                 }
             }
             
             // Create the moves display (only completed moves)
             if (Object.keys(moveGroups).length > 0) {
                 const moveItem = document.createElement('div');
                 moveItem.className = 'move-item';
                 
                 Object.keys(moveGroups).forEach((moveNumber, moveIndex) => {
                     const group = moveGroups[moveNumber];
                     
                     const moveRow = document.createElement('div');
                     moveRow.className = 'move-row';
                     
                     const moveNumberSpan = document.createElement('span');
                     moveNumberSpan.textContent = moveNumber + '.';
                     moveNumberSpan.className = 'move-number';
                     moveRow.appendChild(moveNumberSpan);
                     
                     const whiteMoves = document.createElement('div');
                     whiteMoves.className = 'white-moves';
                     
                     const blackMoves = document.createElement('div');
                     blackMoves.className = 'black-moves';
                     
                     if (group.white) {
                         const whiteMoveSpan = document.createElement('span');
                         whiteMoveSpan.textContent = convertToChessSymbols(group.white);
                         whiteMoveSpan.className = 'clickable-move';
                         whiteMoves.appendChild(whiteMoveSpan);
                     }
                     
                     if (group.black) {
                         const blackMoveSpan = document.createElement('span');
                         blackMoveSpan.textContent = convertToChessSymbols(group.black);
                         blackMoveSpan.className = 'clickable-move';
                         blackMoves.appendChild(blackMoveSpan);
                     }
                     
                     moveRow.appendChild(whiteMoves);
                     moveRow.appendChild(blackMoves);
                     moveItem.appendChild(moveRow);
                 });
                 
                 movesList.appendChild(moveItem);
             } else {
                 // Show placeholder when no moves completed yet
                 const placeholder = document.createElement('div');
                 placeholder.className = 'move-item';
                 placeholder.style.textAlign = 'center';
                 placeholder.style.color = '#7f8c8d';
                 placeholder.style.fontStyle = 'italic';
                 placeholder.textContent = '';
                 movesList.appendChild(placeholder);
             }
         }
         
        function checkChallengeProgress() {
            if (!isChallengeMode || !currentGame) return;
            
            // Update the moves display to show progress
            updateChallengeMovesDisplay();
            
            // Check if user completed the entire game
            if (currentMoveIndex >= currentGame.moves_detailed.length) {
                showCompletionBadge();
            }
        }

        // Auto-play the next move
        function autoPlayNextMove() {
            console.log('=== AUTO PLAY NEXT MOVE ===');
            console.log('Current game:', currentGame ? currentGame.name : 'none');
            console.log('Current move index:', currentMoveIndex);
            console.log('Total moves:', currentGame ? currentGame.moves_detailed.length : 'none');
            
            if (!currentGame || currentMoveIndex >= currentGame.moves_detailed.length) {
                console.log('No more moves to play or no game');
                return;
            }
            
            const nextMove = currentGame.moves_detailed[currentMoveIndex];
            console.log('Next move data:', nextMove);
            
            if (!nextMove) {
                console.log('No next move found');
                return;
            }
            
            // Determine if it's a white or black move
            const isWhiteMove = nextMove.white !== null;
            const moveNotation = nextMove.white || nextMove.black;
            
            console.log('Is white move:', isWhiteMove);
            console.log('Move notation:', moveNotation);
            
            if (!moveNotation) {
                console.log('No move notation found');
                return;
            }
            
            console.log('Auto-playing next move:', moveNotation);
            
            // Parse the move to get source and target squares
            const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
            console.log('Parsed move:', parsedMove);
            
            if (parsedMove && parsedMove.source && parsedMove.target) {
                console.log('Applying move from', parsedMove.source, 'to', parsedMove.target);
                
                // Apply the move using the correct function
                applyMove(nextMove, true, true); // animate=true, enableSound=true
                
                // Reset idle timer after move
                progressTracker.resetIdleTimer();
                
                // Update game state
                currentMoveIndex++;
                updateMoveButtons();
                highlightCurrentMove();
                
                // Update comment section with current move info
                const move = currentGame.moves_detailed[currentMoveIndex - 1];
                const moveNotation = move.white || move.black;
                showMoveCommentary(move.commentary, moveNotation, move);
                
                // Check challenge progress if in challenge mode
                if (isChallengeMode) {
                    checkChallengeProgress();
                }
                
                // Check if this is the final move
                if (currentMoveIndex >= currentGame.moves_detailed.length) {
                    console.log('Reached end of game');
                    setTimeout(() => {
                        showCompletionIndicator();
                    }, 200);
                } else {
                    console.log('Auto-play completed - only playing one move');
                }
            } else {
                console.log('Failed to parse move or missing source/target');
            }
        }

         function showCompletionBadge() {
             const badge = document.getElementById('completion-badge');
             const overlay = document.getElementById('badge-overlay');
             
             // Mark this puzzle as completed
             if (currentGame) {
                 completedChallenges.add(currentGame.id);
                 
                 // Record completion in progress tracker based on type
                 const difficulty = currentGame.difficulty || 'medium';
                 if (currentGame.type === 'puzzle') {
                     progressTracker.recordPuzzleCompletion(difficulty, currentGame.id);
                 } else {
                     progressTracker.recordGameCompletion(difficulty, currentGame.id);
                 }
                 
                 // End the current training session
                 progressTracker.endSession();
                 
                 console.log('Puzzle completed! Progress updated:', progressTracker.getProgressSummary());
             }
             
             // Update badges in games list
             updateGameListBadges();
            
            // Trigger confetti celebration
            createConfetti();
             
             // Show overlay and badge with animation
             overlay.classList.add('show');
             setTimeout(() => {
                 badge.classList.add('show');
             }, 100);
         }

         function hideBadge() {
             const badge = document.getElementById('completion-badge');
             const overlay = document.getElementById('badge-overlay');
             
             // Hide badge and overlay
             badge.classList.remove('show');
             setTimeout(() => {
                 overlay.classList.remove('show');
                 // Exit challenge mode after hiding badge
                 toggleChallengeMode();
             }, 300);
         }


         function updateGameListBadges() {
             // Refresh completed challenges from progress tracker
             completedChallenges = loadCompletedChallenges();
             console.log('Updating puzzle badges with completed challenges:', completedChallenges);
             
             // Update badges in the games list sidebar
             const badges = document.querySelectorAll('.game-completion-badge');
             console.log('Found puzzle badges:', badges.length);
             badges.forEach(badge => {
                 const gameId = badge.dataset.game;
                 const isCompleted = completedChallenges.has(gameId);
                 console.log(`Puzzle ${gameId}: completed = ${isCompleted}`);
                 if (isCompleted) {
                     badge.classList.add('show');
                 } else {
                     badge.classList.remove('show');
                 }
             });
         }

         document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing...');

            // Initialize chess board
            initializeChessBoard();
            setupInitialPosition();
            reinitializeDragAndDrop(); // Ensure click handlers are attached to initial pieces
            
            // Hide custom game elements on initial load
            if (typeof hideCustomGameInfo === 'function') {
                hideCustomGameInfo();
            }
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }

            // Short puzzles submenu toggle
            const shortPuzzlesBtn = document.getElementById('short-puzzles-btn');
            const shortPuzzlesSubmenu = document.getElementById('short-puzzles-submenu');
            
            shortPuzzlesBtn.addEventListener('click', function(e) {
                e.preventDefault();
                
                if (shortPuzzlesSubmenu.classList.contains('show')) {
                    shortPuzzlesSubmenu.classList.remove('show');
                } else {
                    shortPuzzlesSubmenu.classList.add('show');
                }
            });

            // Medium puzzles submenu toggle
            const mediumPuzzlesBtn = document.getElementById('medium-puzzles-btn');
            const mediumPuzzlesSubmenu = document.getElementById('medium-puzzles-submenu');
            
            mediumPuzzlesBtn.addEventListener('click', function(e) {
                e.preventDefault();
                
                if (mediumPuzzlesSubmenu.classList.contains('show')) {
                    mediumPuzzlesSubmenu.classList.remove('show');
                } else {
                    mediumPuzzlesSubmenu.classList.add('show');
                }
            });

            // Long puzzles submenu toggle
            const longPuzzlesBtn = document.getElementById('long-puzzles-btn');
            const longPuzzlesSubmenu = document.getElementById('long-puzzles-submenu');
            
            longPuzzlesBtn.addEventListener('click', function(e) {
                e.preventDefault();
                
                if (longPuzzlesSubmenu.classList.contains('show')) {
                    longPuzzlesSubmenu.classList.remove('show');
                } else {
                    longPuzzlesSubmenu.classList.add('show');
                }
            });


            // Game submenu button clicks
            const submenuButtons = document.querySelectorAll('.submenu-button');
            console.log('Found submenu buttons:', submenuButtons.length);
            
            submenuButtons.forEach(button => {
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    const gameId = this.getAttribute('href').substring(1);
                    console.log('Button clicked, gameId:', gameId);
                    displayGame(gameId);
                });
            });

            // Game header click to expand/collapse details - use event delegation
            document.addEventListener('click', function(e) {
                // Only handle clicks on the main game header, not the custom game header
                if (e.target.closest('#game-header') && !e.target.closest('#custom-game-header')) {
                    const gameHeader = document.getElementById('game-header');
                    const gameDetails = document.getElementById('game-details');
                    
                    if (gameHeader && gameDetails && gameHeader.style.display !== 'none') {
                        gameHeader.classList.toggle('expanded');
                        gameDetails.classList.toggle('show');
                        
                        // Remove any inline display style that might be overriding the CSS
                        if (gameDetails.classList.contains('show')) {
                            gameDetails.style.display = '';
                        } else {
                            gameDetails.style.display = 'none';
                        }
                    }
                }
            });

            // Move navigation button event listeners
            document.getElementById('btn-initial').addEventListener('click', goToInitialPosition);
            document.getElementById('btn-back').addEventListener('click', goToPreviousMove);
            document.getElementById('btn-forward').addEventListener('click', goToNextMove);
            document.getElementById('btn-final').addEventListener('click', goToFinalPosition);

            // Visual mode option event listeners
            const modeOptions = document.querySelectorAll('.mode-option');
            modeOptions.forEach(option => {
                option.addEventListener('click', function() {
                    const mode = this.dataset.mode;
                    switchVisualMode(mode);
                });
            });

            // Flip board button event listener
            document.getElementById('flip-board-btn').addEventListener('click', flipBoard);

            // Challenge button event listener
            const challengeBtn = document.getElementById('challenge-btn');
            challengeBtn.addEventListener('click', function() {
                toggleChallengeMode();
            });


            // Initialize move buttons as disabled
            updateMoveButtons();
            
            // Initialize game list badges
            updateGameListBadges();
        });
    </script>

    <!-- Sign In Modal -->
    <div id="signInModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Sign In</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <form id="signInForm" onsubmit="handleSignIn(event)">
                <div class="form-group">
                    <label class="form-label" for="signInEmail">Email</label>
                    <input type="email" id="signInEmail" class="form-input" placeholder="Enter your email" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="signInPassword">Password</label>
                    <input type="password" id="signInPassword" class="form-input" placeholder="Enter your password" required>
                </div>
            <div class="modal-buttons">
                <button type="submit" class="btn-modal btn-primary">Sign In</button>
                <button type="button" class="btn-modal btn-secondary" onclick="closeModal()">Cancel</button>
            </div>
        </form>
        <div class="google-signup">
            <button type="button" class="btn-modal btn-google" onclick="signInWithGoogle()">
                <div class="google-icon"></div>
                Sign in with Google
            </button>
        </div>
        <div class="register-link">
            <p>Don't have an account yet? <a href="#" onclick="showRegisterModal()">Register here</a></p>
        </div>
        </div>
    </div>

    <!-- Register Modal -->
    <div id="registerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Create Account</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <form id="registerForm" onsubmit="handleRegister(event)">
                <div class="form-group">
                    <label class="form-label" for="registerEmail">Email</label>
                    <input type="email" id="registerEmail" class="form-input" placeholder="Enter your email" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="registerPassword">Password</label>
                    <input type="password" id="registerPassword" class="form-input" placeholder="Create a password" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="registerName">Full Name</label>
                    <input type="text" id="registerName" class="form-input" placeholder="Enter your full name" required>
                </div>
                <div class="modal-buttons">
                    <button type="submit" class="btn-modal btn-primary">Create Account</button>
                    <button type="button" class="btn-modal btn-secondary" onclick="closeModal()">Cancel</button>
                </div>
            </form>
            <div class="google-signup">
                <button type="button" class="btn-modal btn-google" onclick="registerWithGoogle()">
                    <div class="google-icon"></div>
                    Register with Google
                </button>
            </div>
        </div>
    </div>

    <!-- Logout Confirmation Modal -->
    <div id="logoutConfirmModal" class="logout-confirm-modal">
        <div class="logout-confirm-content">
            <div class="logout-confirm-header">
                <h2>Confirm Logout</h2>
            </div>
            <div class="logout-confirm-message">
                Are you sure you want to log out? You'll need to sign in again to access your account.
            </div>
            <div class="logout-confirm-buttons">
                <button class="btn-logout-confirm btn-logout-yes" onclick="confirmLogout()">Yes, Logout</button>
                <button class="btn-logout-confirm btn-logout-no" onclick="cancelLogout()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Subscription Required Modal -->
    <div id="subscriptionRequiredModal" class="subscription-required-modal">
        <div class="subscription-required-content">
            <div class="subscription-required-header">
                <h2>🔒 Subscription Required</h2>
            </div>
            <div class="subscription-required-message">
                This content is locked and requires a premium subscription to access. Upgrade your account to unlock all games and puzzles.
            </div>
            <div class="subscription-required-buttons">
                <button class="btn-subscription-required btn-subscription-yes" onclick="goToSubscription()">Get Subscription</button>
                <button class="btn-subscription-required btn-subscription-no" onclick="closeSubscriptionModal()">Cancel</button>
            </div>
        </div>
    </div>
</body>
</html>
