<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Memo Chess Games - Study master chess games without seeing the board. Practice blindfold chess visualization with interactive training games.">
    <meta name="keywords" content="chess games, blindfold chess, chess training, chess visualization, chess practice, chess study">
    <meta name="author" content="Memo Chess">
    <title>Memo Chess - Interactive Chess Training Games</title>
    <link rel="icon" type="image/png" href="images/chess-board.png">
    <script>
        // Subscription tab removed - content is now on home page
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
        }

        .navbar {
            background-color: #f5f5f5;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .logo {
            display: flex;
            align-items: center;
            color: #1e3a8a;
            font-size: 1.5rem;
            font-weight: bold;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        .logo:hover {
            color: #1e3a8a;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            margin-right: 10px;
            border-radius: 8px;
            object-fit: cover;
        }

        .nav-links {
            display: flex;
            list-style: none;
            gap: 2rem;
            align-items: center;
        }

        .nav-links a {
            color: #1e3a8a;
            text-decoration: none;
            font-weight: 500;
            font-size: 1.1rem;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
        }

        .nav-links a:hover {
            background-color: #e5e7eb;
        }

        /* Profile Button Styles */
        .profile-button {
            color: #1e3a8a;
            text-decoration: none;
            font-weight: normal;
            font-size: 1.1rem;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
        }

        .profile-button:hover {
            background-color: #e5e7eb;
        }

        /* Profile Dropdown Styles */
        .profile-dropdown {
            position: relative;
        }

        .profile-icon {
            display: flex;
            align-items: center;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-size: 1rem;
            font-weight: 500;
            position: relative;
        }


        .profile-icon:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .profile-avatar {
            font-size: 1.2rem;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
        }

        .profile-avatar img {
            border-radius: 50%;
            background: white;
        }


        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 180px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 1000;
            border: 1px solid #e9ecef;
        }

        .profile-dropdown:hover .dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            color: #1a1a1a;
            text-decoration: none;
            transition: all 0.2s ease;
            border-bottom: 1px solid #f8f9fa;
            width: 100%;
            box-sizing: border-box;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background-color: transparent !important;
            color: #1a1a1a !important;
            transform: translateX(2px);
        }
        

        .dropdown-icon {
            font-size: 1rem;
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }

        .dropdown-text {
            font-size: 0.9rem;
            font-weight: 500;
            color: #1a1a1a;
        }

        .nav-links a.active {
            background-color: #1e3a8a;
            color: #ffffff;
        }

        .main-layout {
            display: flex;
            flex-direction: column;
            min-height: calc(100vh - 60px);
            justify-content: center;
            align-items: center;
            padding: 0.5rem 0 2rem 0;
        }

        /* Games Tabs Styles */
        .games-tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 0;
            margin-left: -8px;
            border-bottom: 2px solid transparent;
            width: 100%;
        }

        .games-tabs .tab {
            padding: 0.6rem 1rem;
            cursor: pointer;
            font-weight: 600;
            color: #7f8c8d;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            font-size: 1.04rem;
            flex: 1;
            text-align: center;
            max-width: 120px;
        }

        .games-tabs .tab.active {
            color: #1e3a8a !important;
            border-bottom: 3px solid #1e3a8a !important;
        }

        .games-tabs .tab:hover {
            color: #1e3a8a;
        }

        /* Tab Content Styles */
        .tab-content {
            width: 100%;
            max-width: 400px;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        /* Simplified Tab Content Styles */
        .my-games-content, .gm-games-content {
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .my-games-header, .gm-games-header {
            text-align: center;
            margin-bottom: 1rem;
        }

        .my-games-header h3, .gm-games-header h3 {
            font-size: 1.3rem;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .my-games-header p, .gm-games-header p {
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .my-games-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .stat-card {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e0e0e0;
        }

        .stat-card .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1e3a8a;
            margin-bottom: 0.25rem;
        }

        .stat-card .stat-label {
            color: #7f8c8d;
            font-weight: 500;
            font-size: 0.8rem;
        }

        .my-games-list {
            min-height: 100px;
        }

        .loading {
            text-align: center;
            padding: 1rem;
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .gm-categories {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .gm-category h4 {
            font-size: 1rem;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid #1e3a8a;
        }

        .gm-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .gm-item {
            background: white;
            padding: 0.75rem;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .gm-item:hover {
            border-color: #1e3a8a;
        }

        .gm-name {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .gm-games-count {
            color: #7f8c8d;
            font-size: 0.8rem;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 0.75rem;
        }

        .game-item {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            transition: all 0.3s ease;
        }

        .game-item.completed {
            border-color: #2ecc71;
            background: #f0f9f4;
        }

        .game-item:hover {
            border-color: #1e3a8a;
        }

        .game-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }

        .game-info {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .game-moves, .game-difficulty {
            font-size: 0.8rem;
            color: #7f8c8d;
        }

        .game-status {
            font-weight: 600;
            color: #2ecc71;
            font-size: 0.8rem;
        }

        .empty-state {
            text-align: center;
            padding: 2rem;
            color: #7f8c8d;
        }

        .empty-state h4 {
            margin-bottom: 0.5rem;
            color: #2c3e50;
            font-size: 1rem;
        }

        .main-layout {
            display: flex;
            flex-direction: column;
            min-height: calc(100vh - 60px);
            justify-content: flex-start;
            align-items: center;
            padding: 0.5rem 0 2rem 0;
            position: relative;
        }

        .top-section {
            width: 100%;
            max-width: 800px;
            margin-top: 10px;
            margin-left: -95px;
            display: flex;
            justify-content: flex-start;
        }

        .bottom-section {
            display: flex;
            flex-direction: row;
            width: 100%;
            max-width: 1400px;
            gap: 1rem;
            align-items: flex-start;
            justify-content: center;
            margin-left: -20px;
        }

        .left-panel {
            flex: 0 0 310px;
            min-width: 350px;
            display: flex;
            flex-direction: column;
            margin-top: 30px;
            margin-left: 25px;
        }

        .right-panel {
            flex: 1;
            min-width: 600px;
            max-width: 1000px;
            display: flex;
            flex-direction: column;
            margin-left: -10px;
        }

        .main-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .game-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 1.25rem;
            width: 280px;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border: none;
        }

        .game-button {
            background-color: #ffffff;
            border: 2px solid #bdc3c7;
            border-radius: 12px;
            padding: 1rem;
            text-decoration: none;
            color: #2c3e50;
            text-align: center;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            width: 100%;
        }

        .game-button:hover {
            border-color: #1e3a8a;
            background-color: #f8f9fa;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .submenu-button.locked {
            position: relative;
            cursor: not-allowed;
        }

        .submenu-button.locked:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            background-color: #ffffff;
            margin: 5% auto;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            position: relative;
            animation: slideIn 0.3s ease;
        }

        .modal-header {
            margin-bottom: 1.5rem;
            position: relative;
        }

        .modal-header h2 {
            margin: 0;
            color: #2c3e50;
            font-size: 1.25rem;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            color: #2c3e50;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1rem;
            box-sizing: border-box;
        }

        .form-input:focus {
            outline: none;
            border-color: #1e3a8a;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .btn-modal {
            flex: 1;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background-color: #1e3a8a;
            color: white;
        }

        .btn-primary:hover {
            background-color: #1e40af;
        }

        .btn-secondary {
            background-color: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #7f8c8d;
        }

        .account-info {
            padding: 1rem 0;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid #f8f9fa;
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .info-item label {
            font-weight: 600;
            color: #2c3e50 !important;
            min-width: 100px;
        }

        .info-item span {
            color: #7f8c8d !important;
            text-align: right;
        }

        .register-link {
            text-align: center;
            margin-top: 1rem;
        }

        .register-link a {
            color: #1e3a8a;
            text-decoration: none;
        }

        .register-link a:hover {
            text-decoration: underline;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
        }

        .close:hover {
            color: #000;
        }

        .btn-google {
            background-color: #ffffff;
            color: #333;
            border: 1px solid #dadce0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: box-shadow 0.2s;
            width: 100%;
        }

        .btn-google:hover {
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .google-icon {
            width: 20px;
            height: 20px;
            background: url('images/google.png') no-repeat center;
            background-size: contain;
        }

        .google-signup {
            margin-top: 1rem;
            text-align: center;
        }

        /* Logout Confirmation Modal */
        .logout-confirm-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s ease;
        }

        .logout-confirm-content {
            background-color: #ffffff;
            margin: 15% auto;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            position: relative;
            animation: slideIn 0.3s ease;
            text-align: center;
        }

        .logout-confirm-header {
            margin-bottom: 1.5rem;
        }

        .logout-confirm-header h2 {
            margin: 0;
            color: #2c3e50;
            font-size: 1.25rem;
            font-weight: 600;
        }

        .logout-confirm-message {
            color: #7f8c8d;
            margin-bottom: 2rem;
            line-height: 1.5;
        }

        .logout-confirm-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .btn-logout-confirm {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .btn-logout-yes {
            background-color: #e74c3c;
            color: white;
        }

        .btn-logout-yes:hover {
            background-color: #c0392b;
        }

        .btn-logout-no {
            background-color: #95a5a6;
            color: white;
        }

        .btn-logout-no:hover {
            background-color: #7f8c8d;
        }

        /* Subscription Required Modal */
        .subscription-required-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s ease;
        }

        .subscription-required-content {
            background-color: #ffffff;
            margin: 15% auto;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 450px;
            position: relative;
            animation: slideIn 0.3s ease;
        }

        .subscription-required-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .subscription-required-header h2 {
            color: #2c3e50;
            margin: 0;
            font-size: 1.5rem;
        }

        .subscription-required-message {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .subscription-required-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .btn-subscription-required {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .btn-subscription-yes {
            background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
            color: white;
        }

        .btn-subscription-yes:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        .btn-subscription-no {
            background: #95a5a6;
            color: white;
        }

        .btn-subscription-no:hover {
            background: #7f8c8d;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .lock-overlay {
            position: absolute;
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #7f8c8d;
            font-weight: bold;
            z-index: 10;
        }

        .lock-icon {
            font-size: 1.5rem;
            margin-bottom: 0.25rem;
        }

        .lock-text {
            font-size: 0.7rem;
            text-align: center;
        }

        .game-button.active {
            border-color: #1e3a8a;
            background-color: #e0e7ff;
            color: #1e40af;
        }

        .game-button .description {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-top: 0.5rem;
            font-weight: 400;
        }

        .game-button-container {
            display: flex;
            flex-direction: column;
        }

        .game-button-container .game-button {
            background-color: #ffffff;
            border: 2px solid #bdc3c7;
            border-radius: 12px;
            padding: 1rem;
            text-decoration: none;
            color: #2c3e50;
            text-align: center;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            width: 100%;
        }

        .game-button-container .game-button:hover {
            border-color: #1e3a8a;
            background-color: #f8f9fa;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .game-button-container .game-button.active {
            border-color: #1e3a8a;
            background-color: #e0e7ff;
            color: #1e40af;
        }

        .submenu {
            display: none;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
            padding-left: 1rem;
            animation: slideDown 0.3s ease-out;
        }

        .submenu.show {
            display: flex;
        }

        .submenu-button {
            background-color: #e9ecef;
            border: 1px solid #ced4da;
            border-radius: 8px;
            padding: 0.75rem;
            text-decoration: none;
            color: #495057;
            text-align: center;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .submenu-button:hover {
            background-color: #dee2e6;
            border-color: #adb5bd;
            transform: translateX(5px);
        }

        .submenu-button.selected {
            transform: translateX(6px) !important;
            background-color: #e0e7ff !important;
            border: 1px solid #1e3a8a !important;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2) !important;
            font-weight: normal !important;
            color: #1e3a8a !important;
        }

        .submenu-button.selected:hover {
            background-color: #e0e7ff !important;
            border-color: #1e3a8a !important;
            transform: translateX(6px) !important;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2) !important;
        }

        .game-completion-badge {
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%) scale(0);
            opacity: 0;
            transition: all 0.15s ease;
            z-index: 10;
        }

        .game-completion-badge img {
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }

        .game-completion-badge.show {
            opacity: 1;
            transform: translateY(-50%) scale(1);
        }

        .game-completion-badge:hover::after {
            content: "Memory challenge completed";
            position: absolute;
            bottom: 100%;
            right: 0;
            background-color: #333;
            color: white;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            margin-bottom: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .game-completion-badge:hover::before {
            content: "";
            position: absolute;
            bottom: 100%;
            right: 8px;
            border: 4px solid transparent;
            border-top-color: #333;
            z-index: 1000;
            margin-bottom: -4px;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .game-display {
            display: block;
            padding: 1rem 2rem;
        }

        .game-display.show {
            display: block;
        }

        .game-content {
            display: flex;
            gap: 3.5rem;
            align-items: flex-start;
            justify-content: center;
            width: 100%;
            max-width: 1000px;
        }

        .board-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
        }

         .visual-modes {
             display: flex;
             flex-direction: row;
             gap: 1rem;
             justify-content: center;
             align-items: center;
             padding: 1rem;
             background-color: #f8f9fa;
             border-radius: 12px;
             border: 2px solid #dee2e6;
             box-shadow: 0 4px 12px rgba(0,0,0,0.1);
             width: 520px;
         }


        .mode-option {
            background-color: #ffffff;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            color: #495057;
            transition: all 0.2s ease;
            text-align: center;
            min-height: 40px;
            min-width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mode-option:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-1px);
        }

        .mode-option.active {
            background-color: #1e3a8a;
            border-color: #1e40af;
            color: white;
        }

        .mode-option.active:hover {
            background-color: #1e40af;
            transform: translateY(-1px);
        }


        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 520px;
            height: 520px;
            border: 3px solid #2c3e50;
            border-radius: 10px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.25);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 6px;
            position: relative;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .chess-board.ready {
            opacity: 1;
        }

        .chess-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            border-radius: 4px;
        }
        
        .chess-board.dragging .chess-square {
            transition: none !important;
        }

        /* Board coordinates styles */
        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .board-coordinates {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .board-notation {
            display: flex;
            width: 502px;
            margin: 5px auto 0 auto;
            justify-content: space-between;
        }
        
        .notation-letter {
            width: 62.75px;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            color: #000000;
            padding: 5px 0;
            box-sizing: border-box;
        }
        
        .rank-notation {
            display: flex;
            flex-direction: column;
            width: 47.5px;
            height: 502px;
            position: absolute;
            right: -40.5px;
            top: 7px;
            justify-content: space-between;
        }
        
        .notation-number {
            height: 62.75px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: #000000;
            box-sizing: border-box;
        }

        .coordinate-labels-bottom {
            grid-area: bottom;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            height: 20px;
        }

        .coordinate-labels-right {
            grid-area: right;
            display: grid;
            grid-template-rows: repeat(8, 1fr);
            width: 20px;
        }

        .coordinate-label {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #2c3e50;
            user-select: none;
        }

        .coordinate-label.letter {
            color: #34495e;
        }

        .coordinate-label.number {
            color: #34495e;
        }

        .chess-square.light {
            background: linear-gradient(135deg, #f0d9b5 0%, #e8d5b7 100%);
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
        }

        .chess-square.dark {
            background: linear-gradient(135deg, #b58863 0%, #a67c52 100%);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .chess-square:hover {
            background: linear-gradient(135deg, #ffeb3b 0%, #ffc107 100%);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(255,235,59,0.4);
            z-index: 10;
        }

        .chess-piece {
            width: 60px;
            height: 60px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transition: all 0.2s ease;
            cursor: grab;
        }
        
        .chess-piece.dragging {
            transition: none !important;
        }

        .chess-piece:hover {
            transform: scale(1.1);
        }

        .chess-piece:active {
            cursor: grabbing;
        }

        .chess-square.valid-move {
            background-color: rgba(144, 238, 144, 0.3) !important;
            outline: 3px solid #32CD32;
            outline-offset: -3px;
            transition: background-color 0.3s ease, outline 0s !important;
        }

        .chess-square.valid-move:hover {
            background-color: rgba(152, 251, 152, 0.4) !important;
        }

        .chess-square.selected {
            background: #FFD700 !important;
            box-shadow: inset 0 2px 4px rgba(255, 215, 0, 0.5) !important;
        }

        .chess-square.selected.light {
            background: #FFD700 !important;
            box-shadow: inset 0 2px 4px rgba(255, 215, 0, 0.5) !important;
        }

        .chess-square.selected.dark {
            background: #FFD700 !important;
            box-shadow: inset 0 2px 4px rgba(255, 215, 0, 0.5) !important;
        }

        .moves-panel {
            width: 420px;
            background-color: #ffffff;
            margin-left: 30px;
            border: none;
            border-radius: 12px;
            padding: 1.25rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            max-height: 630px;
            overflow-y: auto;
            align-self: flex-start;
        }

        .game-header {
            background: #ffffff;
            color: #333333;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            border: 1px solid #e0e0e0;
            box-shadow: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .game-header:hover {
            background: #f5f5f5;
            border-color: #cccccc;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .game-header::after {
            content: 'â–¼';
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.2s ease;
            font-size: 0.8rem;
            color: #666666;
        }

        .game-header.expanded::after {
            transform: translateY(-50%) rotate(180deg);
        }


        .game-title-line {
            font-size: 1rem;
            font-weight: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333333;
            text-align: center;
        }

        .move-count {
            font-size: 0.85rem;
            color: #666666;
            background: #e9ecef;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-weight: 400;
        }

        .move-count-left {
            font-size: 0.8rem;
            color: #7f8c8d;
            font-weight: 400;
            font-style: italic;
        }

        .game-title {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .game-info {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .game-details {
            background-color: #f8f9fa;
            border: none;
            border-radius: 0 0 6px 6px;
            margin-top: 0;
            max-height: 0;
            overflow: hidden;
            padding: 0 1rem;
            transition: max-height 0.4s ease, padding 0.4s ease, margin 0.4s ease;
        }

        .game-details.show {
            max-height: 600px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e9ecef;
        }

        .detail-item:last-child {
            border-bottom: none;
        }

        .detail-label {
            font-weight: bold;
            color: #2c3e50;
            font-size: 0.9rem;
            flex-shrink: 0;
            margin-right: 1rem;
        }

        .detail-value {
            color: #495057;
            font-size: 0.9rem;
            text-align: right;
            line-height: 1.4;
            flex: 1;
        }

        .detail-facts {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #dee2e6;
        }

        .facts-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .facts-text {
            color: #495057;
            font-size: 0.85rem;
            line-height: 1.4;
        }


        .move-controls {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .move-btn {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            color: #495057;
            transition: all 0.2s ease;
            min-width: 40px;
            text-align: center;
        }

        .move-btn:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-1px);
        }

        .move-btn:active {
            transform: translateY(0);
        }

        .move-btn:disabled {
            background-color: #f8f9fa;
            color: #adb5bd;
            cursor: not-allowed;
            transform: none;
        }

        .move-btn:disabled:hover {
            background-color: #f8f9fa;
            border-color: #dee2e6;
            transform: none;
        }

        .move-icon {
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #495057;
            user-select: none;
            width: 40px;
            height: 40px;
            flex-shrink: 0;
        }

        .move-icon:hover {
            background-color: #e9ecef;
            transform: translateY(-1px);
        }

        .move-icon:active {
            transform: translateY(0);
        }

        .move-icon.disabled {
            color: #adb5bd;
            cursor: not-allowed;
            transform: none;
        }

        .move-icon.disabled:hover {
            background-color: transparent;
            transform: none;
        }

          .visual-modes {
              display: flex;
              align-items: center;
              margin-top: 5px;
          }

          .mode-title {
              margin-right: 10px;
              margin-top: 4px;
          }


          .challenge-title {
              font-weight: bold;
              color: #2c3e50;
              font-size: 0.9rem;
              margin-right: 10px;
          }

          .challenge-btn {
              background-color: #ffffff;
              border: 2px solid #dee2e6;
              border-radius: 8px;
              padding: 0.75rem 1.5rem;
              cursor: pointer;
              font-size: 0.85rem;
              font-weight: 500;
              color: #495057;
              transition: all 0.2s ease;
              min-width: 120px;
              text-align: center;
              display: flex;
              align-items: center;
              justify-content: center;
          }

          .challenge-btn:hover {
              background-color: #e9ecef;
              border-color: #adb5bd;
              transform: translateY(-1px);
          }

          .challenge-btn.active {
              background-color: #dc3545;
              border-color: #c82333;
              color: white;
          }

          .test-btn {
              background: linear-gradient(135deg, #ff6b6b, #ee5a24);
              border: 2px solid #ee5a24;
              border-radius: 8px;
              padding: 0.75rem 1.5rem;
              cursor: pointer;
              font-size: 0.85rem;
              font-weight: 600;
              color: white;
              transition: all 0.2s ease;
              min-width: 80px;
              text-align: center;
              display: flex;
              align-items: center;
              justify-content: center;
              box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
          }

          .test-btn:hover {
              background: linear-gradient(135deg, #ee5a24, #d63031);
              border-color: #d63031;
              transform: translateY(-1px);
              box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
          }

          .test-btn.active {
              background: linear-gradient(135deg, #d63031, #a71e2e);
              border-color: #a71e2e;
              box-shadow: 0 2px 8px rgba(214, 48, 49, 0.4);
          }

          .test-btn.active:hover {
              background: linear-gradient(135deg, #a71e2e, #8b1538);
              border-color: #8b1538;
              transform: translateY(-1px);
          }

          .flip-board-icon {
              display: flex;
              align-items: center;
              justify-content: center;
              transition: all 0.2s ease;
          }

          .flip-board-icon:hover {
              transform: scale(1.1);
          }

          .flip-board-icon.flipped {
              transform: rotate(180deg);
          }

          .flip-board-icon.flipped:hover {
              transform: rotate(180deg) scale(1.1);
          }


          .completion-badge {
              position: fixed;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%) scale(0);
              background: #ffffff;
              color: #2c3e50;
              padding: 2.5rem 3rem;
              border-radius: 12px;
              box-shadow: 0 12px 24px rgba(0,0,0,0.15), 0 0 0 1px rgba(0,0,0,0.05);
              text-align: center;
              z-index: 9999;
              font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
              border: 2px solid #e8f5e8;
              transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
              max-width: 400px;
              backdrop-filter: blur(20px);
          }

          .completion-badge.show {
              transform: translate(-50%, -50%) scale(1);
          }

          .completion-badge .badge-icon {
              margin-bottom: 1.5rem;
              text-align: center;
              animation: bounce 1s infinite;
              filter: drop-shadow(0 2px 4px rgba(40, 167, 69, 0.2));
          }

          .completion-badge .badge-title {
              font-size: 1.75rem;
              font-weight: 700;
              margin-bottom: 0.75rem;
              color: #2c3e50;
              letter-spacing: -0.5px;
          }

          .completion-badge .badge-subtitle {
              font-size: 1rem;
              color: #7f8c8d;
              margin-bottom: 2rem;
              line-height: 1.5;
              font-weight: 400;
          }

          .completion-badge .badge-close {
              background: linear-gradient(135deg, #1e3a8a, #1e40af);
              border: 2px solid #1e3a8a;
              color: white;
              padding: 0.75rem 2rem;
              border-radius: 8px;
              cursor: pointer;
              font-size: 0.95rem;
              font-weight: 600;
              transition: all 0.2s ease;
              font-family: inherit;
              box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
          }

          .completion-badge .badge-close:hover {
              background: linear-gradient(135deg, #1e40af, #1e3a8a);
              border-color: #1e40af;
              transform: translateY(-1px);
              box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
          }

          .badge-overlay {
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: rgba(44, 62, 80, 0.85);
              backdrop-filter: blur(4px);
              z-index: 9998;
              opacity: 0;
              transition: all 0.3s ease;
              pointer-events: none;
          }

          .badge-overlay.show {
              opacity: 1;
              pointer-events: all;
          }

          @keyframes bounce {
              0%, 20%, 50%, 80%, 100% {
                  transform: translateY(0);
              }
              40% {
                  transform: translateY(-10px);
              }
              60% {
                  transform: translateY(-5px);
              }
          }

          .moves-title {
            font-size: 1.2rem;
            color: #2c3e50;
            margin-bottom: 1rem;
            text-align: center;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 0.5rem;
        }

        .move-item {
            padding: 0.25rem 0.5rem;
            background-color: #fff;
            border: none;
            margin-bottom: 0.1rem;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            color: #495057;
            transition: background-color 0.2s ease;
            user-select: none;
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
        }


        .move-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-height: 1rem;
            padding: 0.1rem 0;
        }

        .move-number {
            font-weight: bold;
            color: #6c757d;
            font-size: 0.9rem;
            min-width: 1.5rem;
            text-align: center;
        }

        .white-moves {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
            padding: 0.3rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .black-moves {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
            justify-content: flex-start;
            padding: 0.3rem 0.3rem 0.3rem 1.3rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .clickable-move {
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: background-color 0.2s ease;
            display: inline-block;
            font-size: 1rem;
            font-weight: normal;
        }

        .white-moves:hover .clickable-move {
            background-color: #f8f9fa;
        }

        .black-moves:hover .clickable-move {
            background-color: #f8f9fa;
        }

        .white-moves.clicked .clickable-move {
            background-color: #e0e7ff;
            color: #1e3a8a;
        }

        .black-moves.clicked .clickable-move {
            background-color: #e0e7ff;
            color: #1e3a8a;
        }

        .clickable-move.active-move {
            font-weight: bold;
        }


        .moves-container {
            padding: 0.5rem;
            background-color: #fff;
            border-radius: 4px;
            border: 1px solid #e9ecef;
            margin-top: 0.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.125rem;
        }


        .main-content {
            flex: 1;
            padding: 1rem 2rem;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 1200px;
            width: 100%;
        }

        .main-content h1 {
            color: #2c3e50;
            margin-bottom: 1rem;
        }

        .main-content p {
            color: #7f8c8d;
            font-size: 1.1rem;
        }

        @media (max-width: 768px) {
            .navbar {
                padding: 0.5rem 1rem;
                flex-direction: column;
                gap: 0.5rem;
            }

            .nav-links {
                gap: 1rem;
            }

            .nav-links a {
                padding: 0.4rem 0.8rem;
                font-size: 0.9rem;
            }

            .main-content {
                padding: 0.5rem 1rem;
            }

            .game-display {
                padding: 0.5rem 1rem;
            }

            .main-layout {
                flex-direction: column;
                align-items: center;
                padding: 0.25rem 0 1rem 0;
            }
            
            .bottom-section {
                flex-direction: column;
                gap: 1rem;
                align-items: center;
                padding: 0 1rem;
            }
            
            .left-panel {
                flex: none;
                width: 100%;
                max-width: 400px;
                margin-left: 40px;
            }
            
            .right-panel {
                flex: none;
                width: 100%;
                max-width: 500px;
                margin-left: 15px;
            }

            .game-buttons {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
                padding: 1.25rem;
                margin-left: 1rem;
                gap: 0.5rem;
            }

            .game-button {
                flex: 1;
                min-width: 120px;
                padding: 0.8rem 0.5rem;
                font-size: 0.9rem;
            }
        }
        
        /* Responsive styles for smaller laptops */
        @media (max-width: 1200px) {
            .bottom-section {
                gap: 1.5rem;
            }
            
            .left-panel {
                flex: 0 0 350px;
                min-width: 300px;
            }
            
            .right-panel {
                min-width: 500px;
            }
            
            .game-buttons {
                width: 240px;
                padding: 1.25rem;
            }
            
            .game-content {
                gap: 2rem;
            }
            
            .chess-board {
                width: 440px;
                height: 440px;
            }
            
            .board-coordinates {
                grid-template-columns: 440px 20px;
                grid-template-rows: 440px 20px;
            }
            
            .visual-modes {
                width: 440px;
            }
            
            .moves-panel {
                width: 360px;
                max-height: 550px;
            }
            
            .chess-piece {
                width: 50px;
                height: 50px;
            }
        }

        /* Toggle Switch Styles */
        .toggle-switch {
            position: relative;
            display: inline-block;
        }

        .toggle-switch input[type="checkbox"] {
            display: none;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 2px 4px;
            background: transparent;
            border: none;
            border-radius: 6px;
            transition: all 0.3s ease;
            font-size: 12px;
            font-weight: 500;
            color: #495057;
        }

        .toggle-label::before {
            content: '';
            width: 24px;
            height: 12px;
            background: #dee2e6;
            border-radius: 12px;
            margin-right: 6px;
            position: relative;
            transition: all 0.3s ease;
        }

        .toggle-label::after {
            content: '';
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            position: absolute;
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
            transition: all 0.3s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .toggle-switch input:checked + .toggle-label {
            background: transparent;
            border: none;
            color: #495057;
        }

        .toggle-switch input:checked + .toggle-label::before {
            background: #28a745;
        }

        .toggle-switch input:checked + .toggle-label::after {
            left: 20px;
        }

        .toggle-label:hover {
            background: transparent;
        }

        .toggle-switch input:checked + .toggle-label:hover {
            background: transparent;
        }

        .moves-toggle-icon {
            padding: 0;
            background: transparent;
            border: none;
        }

        .toggle-icon {
            width: 36px;
            height: 36px;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s ease;
            background: transparent;
        }

        .toggle-icon:hover {
            background: #f0f0f0;
        }

        .moves-toggle-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            flex-shrink: 0;
        }

        /* Confetti styles */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #ff6b6b;
            animation: confetti-fall 3s linear infinite;
            z-index: 9999;
        }

        .confetti:nth-child(2n) {
            background: #4ecdc4;
            animation-delay: 0.1s;
        }

        .confetti:nth-child(3n) {
            background: #45b7d1;
            animation-delay: 0.2s;
        }

        .confetti:nth-child(4n) {
            background: #96ceb4;
            animation-delay: 0.3s;
        }

        .confetti:nth-child(5n) {
            background: #feca57;
            animation-delay: 0.4s;
        }

        .confetti:nth-child(6n) {
            background: #ff9ff3;
            animation-delay: 0.5s;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Game completion indicator */
        .completion-indicator {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #4CAF50;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            font-weight: bold;
            z-index: 10;
            animation: completionPulse 2s ease-in-out infinite;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
            opacity: 1;
        }

        @keyframes completionPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 4px 12px rgba(76, 175, 80, 0.6);
            }
        }

        /* Custom Game Valid Move Highlighting */
        .valid-move {
            background-color: rgba(0, 255, 0, 0.3) !important;
            outline: 2px solid #00ff00;
            outline-offset: -2px;
        }

        .valid-move:hover {
            background-color: rgba(0, 255, 0, 0.5) !important;
        }

        /* Delete Game Button - Subtle Version */
        .delete-game-btn-subtle {
            background: #f8f9fa;
            color: #6c757d;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .delete-game-btn-subtle:hover {
            background: #e9ecef;
            color: #495057;
            border-color: #adb5bd;
        }

        .delete-game-btn-subtle:active {
            transform: scale(0.98);
        }


        /* Custom Game Info Section Styles */
        .custom-game-info-section {
            margin-bottom: 15px;
        }

        .custom-game-info-section .game-header {
            background: #ffffff;
            color: #333333;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            border: 1px solid #e0e0e0;
            box-shadow: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .custom-game-info-section .game-header:hover {
            background: #f5f5f5;
            border-color: #cccccc;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .custom-game-info-section .game-header::after {
            content: 'â–¼';
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.2s ease;
            font-size: 0.8rem;
            color: #666666;
        }

        .custom-game-info-section .game-header.expanded::after {
            transform: translateY(-50%) rotate(180deg);
        }

        .custom-game-info-section .game-details {
            background-color: #f8f9fa;
            border: none;
            border-radius: 0 0 6px 6px;
            margin-top: 0;
            max-height: 0;
            overflow: hidden;
            padding: 0 1rem;
            transition: max-height 0.4s ease, padding 0.4s ease, margin 0.4s ease;
        }

        .custom-game-info-section .game-details.show {
            max-height: 600px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .custom-game-info-section #custom-game-title-input {
            background: none;
            border: none;
            text-align: center;
            font-size: inherit;
            font-weight: inherit;
            color: inherit;
            width: 100%;
            outline: none;
            font-family: inherit;
            padding: 0;
            margin: 0;
        }

        .custom-game-info-section #custom-game-title-input:focus {
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #1e3a8a;
            border-radius: 4px;
            padding: 2px 6px;
        }

        .custom-game-info-section #custom-game-title-input::placeholder {
            color: #999;
            font-style: italic;
        }

        .custom-game-info-section #custom-game-title-input:invalid {
            border: 1px solid #e74c3c;
        }

        /* Custom Detail Input Styles */
        .custom-detail-input {
            background: #ffffff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 13px;
            font-family: inherit;
            color: #333;
            width: 100%;
            max-width: 200px;
            transition: border-color 0.2s ease;
        }

        .custom-detail-input:focus {
            outline: none;
            border-color: #1e3a8a;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .custom-detail-input[readonly] {
            background: #f8f9fa;
            color: #6c757d;
            cursor: not-allowed;
        }

        .custom-detail-select {
            background: #ffffff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 13px;
            font-family: inherit;
            color: #333;
            width: 100%;
            max-width: 200px;
            transition: border-color 0.2s ease;
            cursor: pointer;
        }

        .custom-detail-select:focus {
            outline: none;
            border-color: #1e3a8a;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e9ecef;
        }

        .detail-item:last-child {
            border-bottom: none;
        }

        @media (max-width: 900px) {
            .bottom-section {
                flex-direction: column;
                gap: 1rem;
                align-items: center;
            }
            
            .left-panel {
                flex: none;
                width: 100%;
                max-width: 500px;
                margin-left: 40px;
            }
            
            .right-panel {
                flex: none;
                width: 100%;
                max-width: 600px;
                margin-left: 15px;
            }
            
            .game-buttons {
                padding: 1.25rem;
                margin-left: 1rem;
            }
            
            .game-content {
                flex-direction: column;
                align-items: center;
                gap: 2rem;
            }
            
            .chess-board {
                width: 400px;
                height: 400px;
            }
            
            .board-coordinates {
                grid-template-columns: 400px 20px;
                grid-template-rows: 400px 20px;
            }
            
            .visual-modes {
                width: 400px;
            }
            
            .moves-panel {
                width: 360px;
                max-height: 470px;
            }
            
            .chess-piece {
                width: 46px;
                height: 46px;
            }
        }
        
        .hint-button {
            background-color: #ffffff;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 5px 0;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            color: #495057;
            transition: all 0.2s ease;
            text-align: center;
            min-height: 40px;
            width: 110px;
            margin: 10px auto;
            display: block;
        }

        .hint-button:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-1px);
        }

        .hint-button.active {
            background-color: #1e3a8a;
            border-color: #1e40af;
            color: white;
        }

        .hint-button.active:hover {
            background-color: #1e40af;
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <a href="index.html" class="logo">
            <img src="images/chess-board.png" alt="Memo Chess" class="logo-icon">
            <span>Memo Chess</span>
        </a>
                <ul class="nav-links">
                    <li><a href="index.html">Home</a></li>
                <li><a href="games.html" class="active">Games</a></li>
                <li><a href="puzzles.html">Puzzles</a></li>
                <!-- <li><a href="leaderboard.html">Community</a></li> -->
                    <li>
                        <a href="profile.html" id="profileLink" class="profile-button">Profile</a>
                    </li>
                </ul>
    </nav>

    <div class="main-layout">
        <!-- Top Section: Games Tabs -->
        <div class="top-section">
                <div class="games-tabs">
                    <div class="tab active" data-tab="difficulty">By Moves</div>
                    <div class="tab" data-tab="gm-games">Classic Era</div>
                    <div class="tab" data-tab="opening">Openings</div>
                    <div class="tab" data-tab="my-games">My Games</div>
                </div>
        </div>

        <!-- Bottom Section: Left and Right Panels -->
        <div class="bottom-section">
            <!-- Left Side: Game Selection -->
            <div class="left-panel">
                <!-- Tab Content -->
                <div class="tab-content">
                <!-- Games by Difficulty Tab -->
                <div class="tab-panel active" id="difficulty-panel">
                    <div class="game-buttons">
            <div class="game-button-container">
                <a href="#short-games" class="game-button active" id="short-games-btn">
                    <div>Fundamental Games</div>
                    <div class="description">Under 10 moves</div>
                </a>
                <div class="submenu" id="short-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            <div class="game-button-container">
                <a href="#medium-games" class="game-button" id="medium-games-btn">
                    <div>Short Games</div>
                    <div class="description">10 to 30 moves</div>
                </a>
                <div class="submenu" id="medium-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            <div class="game-button-container">
                <a href="#long-games" class="game-button" id="long-games-btn">
                    <div>Medium Games</div>
                    <div class="description">30 to 50 moves</div>
            </a>
                <div class="submenu" id="long-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            <div class="game-button-container">
                <a href="#epic-games" class="game-button" id="epic-games-btn">
                    <div>Long Games</div>
                    <div class="description">50+ moves</div>
                </a>
                <div class="submenu" id="epic-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            </div>
        </div>

        <!-- My Games Tab -->
        <div class="tab-panel" id="my-games-panel">
            <div class="game-buttons">
            <div class="game-button-container">
                <a href="#my-games" class="game-button active" id="my-games-my-games-btn">
                <div>Custom</div>
                <div class="description">Your saved games</div>
            </a>
                <div class="submenu" id="my-games-my-games-submenu">
                    <!-- Custom games will be populated dynamically -->
                </div>
            </div>
            </div>
        </div>

        <!-- Games by GM Tab -->
        <div class="tab-panel" id="gm-games-panel">
            <div class="game-buttons">
            <div class="game-button-container">
                <a href="#fischer-games" class="game-button active" id="gm-games-fischer-games-btn">
                    <div>Classic Era</div>
                </a>
                <div class="submenu" id="gm-games-fischer-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            </div>
        </div>

        <!-- Games by Opening Tab -->
        <div class="tab-panel" id="opening-panel">
            <div class="game-buttons">
                <!-- Opening categories will be populated dynamically -->
            </div>
        </div>
        </div>
        </div>

            <!-- Right Side: Board and Moves -->
            <div class="right-panel">
            <main class="main-content">
            <div class="game-display" id="game-display">
                <div class="game-content">
                    <div class="board-section">
                        <div class="board-container">
                            <div class="board-coordinates">
                                <div class="chess-board" id="chess-board">
                                    <!-- Chess board will be generated by JavaScript -->
                                </div>
                                
                                <!-- Rank notation to the right of the board -->
                                <div class="rank-notation">
                                    <div class="notation-number">8</div>
                                    <div class="notation-number">7</div>
                                    <div class="notation-number">6</div>
                                    <div class="notation-number">5</div>
                                    <div class="notation-number">4</div>
                                    <div class="notation-number">3</div>
                                    <div class="notation-number">2</div>
                                    <div class="notation-number">1</div>
                                </div>
                            </div>
                            
                            <!-- Square notation below the board -->
                            <div class="board-notation">
                                <div class="notation-letter">a</div>
                                <div class="notation-letter">b</div>
                                <div class="notation-letter">c</div>
                                <div class="notation-letter">d</div>
                                <div class="notation-letter">e</div>
                                <div class="notation-letter">f</div>
                                <div class="notation-letter">g</div>
                                <div class="notation-letter">h</div>
                            </div>
                        </div>
                         <div class="visual-modes">
                             <div class="mode-option active" data-mode="normal">Normal</div>
                             <div class="mode-option" data-mode="grey">Black</div>
                             <div class="mode-option" data-mode="checkers">Checkers</div>
                             <div class="mode-option" data-mode="empty">Empty</div>
                             <button class="test-btn" id="challenge-btn">Test</button>
                         </div>
                         
                         <!-- Supabase Data Table -->
                         <div class="supabase-data-section" style="margin: 1rem 0; padding: 1rem; background-color: #ffffff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                             <h3 style="margin-bottom: 0.75rem; color: #1e3a8a; font-size: 1rem;">Supabase Data (Raw)</h3>
                             <table id="supabaseDataTable" class="supabase-data-table" style="width: 100%; border-collapse: collapse;">
                                 <thead>
                                     <tr style="background-color: #f3f4f6; border-bottom: 2px solid #d1d5db;">
                                         <th style="padding: 0.75rem; text-align: left; border: 1px solid #d1d5db; font-size: 0.875rem;">Field</th>
                                         <th style="padding: 0.75rem; text-align: left; border: 1px solid #d1d5db; font-size: 0.875rem;">Value</th>
                                     </tr>
                                 </thead>
                                 <tbody id="supabaseDataTableBody">
                                     <tr>
                                         <td style="padding: 0.75rem; border: 1px solid #d1d5db; font-weight: 500;">Loading...</td>
                                         <td style="padding: 0.75rem; border: 1px solid #d1d5db;">-</td>
                                     </tr>
                                 </tbody>
                             </table>
                         </div>
                     </div>
                    <div class="moves-panel" id="moves-panel">
                        <div class="game-header" id="game-header" style="display: none;">
                            <div class="game-title-line" id="game-title-line">Select a Game</div>
                        </div>
                        <div class="game-details" id="game-details">
                            <div class="detail-item">
                                <span class="detail-label">Description:</span>
                                <span class="detail-value" id="detail-description">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Moves:</span>
                                <span class="detail-value" id="detail-moves">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">White Player:</span>
                                <span class="detail-value" id="detail-white">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Black Player:</span>
                                <span class="detail-value" id="detail-black">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Opening:</span>
                                <span class="detail-value" id="detail-opening">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Difficulty:</span>
                                <span class="detail-value" id="detail-difficulty">-</span>
                            </div>
                            <div class="detail-facts">
                                <div class="facts-title">Interesting Facts:</div>
                                <div class="facts-text" id="detail-facts">-</div>
                            </div>
                        </div>
                        
                        <!-- Custom Game Information Tab (shown in Add Game mode) -->
                        <div id="custom-game-info" class="custom-game-info-section" style="display: none;">
                            <div class="game-header" id="custom-game-header">
                                <div class="game-title-line" id="custom-game-title-line">
                                    <input type="text" id="custom-game-title-input" value="" placeholder="Enter title" maxlength="25" required style="background: none; border: none; text-align: center; font-size: inherit; font-weight: inherit; color: inherit; width: 100%; outline: none;">
                                </div>
                            </div>
                            <div class="game-details" id="custom-game-details">
                                <div class="detail-item">
                                    <span class="detail-label">Description:</span>
                                    <input type="text" id="custom-detail-description" class="custom-detail-input" placeholder="Enter description..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Moves:</span>
                                    <input type="text" id="custom-detail-moves" class="custom-detail-input" value="0" readonly>
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">White Player:</span>
                                    <input type="text" id="custom-detail-white" class="custom-detail-input" placeholder="Enter white player name..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Black Player:</span>
                                    <input type="text" id="custom-detail-black" class="custom-detail-input" placeholder="Enter black player name..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Opening:</span>
                                    <input type="text" id="custom-detail-opening" class="custom-detail-input" placeholder="Enter opening name..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Result:</span>
                                    <select id="custom-detail-result" class="custom-detail-select">
                                        <option value="In progress">In progress</option>
                                        <option value="1-0">1-0 (White wins)</option>
                                        <option value="0-1">0-1 (Black wins)</option>
                                        <option value="1/2-1/2">1/2-1/2 (Draw)</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        
                        <div class="move-controls">
                            <div class="move-icon flip-board-icon" id="flip-board-btn" title="Flip board perspective"><img src="images/switch-camera.png" alt="Flip Board" style="width: 20px; height: 20px;"></div>
                            <div class="move-icon" id="btn-initial" title="Go to initial position"><img src="images/fast-forward.png" alt="Initial" style="width: 20px; height: 20px; transform: scaleX(-1);"></div>
                            <div class="move-icon" id="btn-back" title="Previous move"><img src="images/next.png" alt="Back" style="width: 20px; height: 20px; transform: scaleX(-1);"></div>
                            <div class="move-icon" id="btn-forward" title="Next move"><img src="images/next.png" alt="Next" style="width: 20px; height: 20px;"></div>
                            <div class="move-icon" id="btn-final" title="Go to final position"><img src="images/fast-forward.png" alt="Last" style="width: 20px; height: 20px;"></div>
                            <div class="moves-toggle-icon" id="moves-toggle" style="display: none;">
                                <img src="images/hide.png" class="toggle-icon" id="moves-toggle-img" alt="Toggle moves visibility" title="Toggle moves visibility">
                        </div>
                        </div>
                        
                        <!-- Play Color Selection -->
                        <div id="play-color-section" style="display: none; margin: 10px 0; padding: 10px 0; text-align: center;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 15px; font-size: 14px; color: #34495e;">
                                <span style="font-weight: 500;">Play for:</span>
                                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                    <input type="radio" name="play-color" value="white" style="margin: 0;">
                                    <span>White</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                    <input type="radio" name="play-color" value="black" style="margin: 0;">
                                    <span>Black</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                    <input type="radio" name="play-color" value="both" checked style="margin: 0;">
                                    <span>Both</span>
                                </label>
                            </div>
                        </div>
                        
                        <div id="moves-list" style="max-height: 300px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 8px; padding: 10px; background: #fff;">
                            <p style="text-align: center; color: #7f8c8d;">Select a game to view moves</p>
                        </div>
                        
                        <!-- Comment Section -->
                        <div id="comment-section" style="display: none; margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #1e3a8a;">
                            <div id="comment-content" style="color: #34495e; line-height: 1.4; font-size: 13px; text-align: left;">
                                Click on any move to see detailed commentary
                            </div>
                        </div>
                        
                        <!-- Hint Button -->
                        <button id="hint-btn" class="hint-button" title="Get a hint for the next move" style="display: none;">
                            ðŸ’¡ Get Hint
                        </button>
                        
                    <!-- Delete Game Button (only for custom games) -->
                    <div id="delete-game-section" style="display: none; margin-top: 15px; text-align: center;">
                        <button id="delete-game-btn" class="delete-game-btn-subtle" title="Delete this custom game">
                            Delete Game
                        </button>
                    </div>


                    </div>
                </div>
            </div>
        </main>
        </div>
        </div>
    </div>

    <!-- Completion Badge -->
    <div class="badge-overlay" id="badge-overlay"></div>
    <div class="completion-badge" id="completion-badge">
        <div class="badge-icon"><img src="images/checklist.png" alt="Complete" style="width: 56px; height: 56px;"></div>
        <div class="badge-title">Challenge Complete!</div>
        <div class="badge-subtitle">You successfully completed the memory challenge</div>
        <button class="badge-close" onclick="hideBadge()">Continue</button>
    </div>

    <script src="chess-move-parser.js?v=3"></script>
    <script src="custom-games.js"></script>
    <script src="progress-tracker.js"></script>
    <script>
        console.log('ðŸ”µ SCRIPT BLOCK STARTING - games.html inline script');
        // GameLoader class to handle loading games from files
        console.log('ðŸ“ GameLoader class definition script executing...');
        class GameLoader {
            static async loadGamesFromFiles() {
                try {
                    console.log('ðŸŽ® GameLoader.loadGamesFromFiles() called');
                    console.log('Loading games from files...');
                    
                    // Load both games.json and custom games from API
                    const isProduction = !window.location.hostname.includes('localhost') && !window.location.hostname.includes('127.0.0.1');
                    const customApiUrl = isProduction ? '/api/get-games' : 'http://localhost:3001/get-games';
                    
                    let allGames = [];
                    
                    // Load main games
                    try {
                        const gamesUrl = `games/games.json?t=${Date.now()}`;
                        console.log('Fetching games from:', gamesUrl);
                        const gamesResponse = await fetch(gamesUrl);
                        
                        if (gamesResponse.ok) {
                            const gamesData = await gamesResponse.json();
                            if (gamesData.games && Array.isArray(gamesData.games)) {
                                allGames = allGames.concat(gamesData.games);
                                console.log(`âœ… Loaded ${gamesData.games.length} games from games.json`);
                            } else {
                                console.warn('games.json does not have a games array:', gamesData);
                            }
                        } else {
                            console.error('âŒ Could not load games.json:', gamesResponse.status, gamesResponse.statusText);
                        }
                    } catch (error) {
                        console.error('âŒ Error loading games.json:', error);
                    }
                    
                    // Load custom games from Supabase
                    try {
                        console.log('=== LOADING CUSTOM GAMES FROM SUPABASE ===');
                        
                        // Wait for supabase-helpers.js to load if needed
                        let attempts = 0;
                        while (typeof window.getUserCustomGames !== 'function' && attempts < 20) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                            attempts++;
                        }
                        
                        // Check if user is logged in using Supabase session
                        let isLoggedIn = false;
                        console.log('ðŸ” Checking authentication...');
                        console.log('  - window.isSignedIn available:', typeof window.isSignedIn === 'function');
                        console.log('  - window.getCurrentUser available:', typeof window.getCurrentUser === 'function');
                        console.log('  - window.getSupabase available:', typeof window.getSupabase === 'function');
                        console.log('  - window.getUserCustomGames available:', typeof window.getUserCustomGames === 'function');
                        
                        if (typeof window.isSignedIn === 'function') {
                            isLoggedIn = await window.isSignedIn();
                            console.log('  - isSignedIn() result:', isLoggedIn);
                        } else if (typeof window.getCurrentUser === 'function') {
                            const user = await window.getCurrentUser();
                            isLoggedIn = user !== null;
                            console.log('  - getCurrentUser() result:', user ? 'user found' : 'no user');
                        } else if (typeof window.getSupabase === 'function') {
                            const supabase = window.getSupabase();
                            if (supabase && supabase.auth) {
                                const { data: { session } } = await supabase.auth.getSession();
                                isLoggedIn = session !== null && session.user !== null;
                                console.log('  - getSession() result:', session ? 'session found' : 'no session');
                            }
                        }
                        
                        console.log('ðŸ” Final isLoggedIn status:', isLoggedIn);
                        
                        if (isLoggedIn && typeof window.getUserCustomGames === 'function') {
                            console.log('âœ… User is logged in, loading custom games from Supabase...');
                            const customGamesData = await window.getUserCustomGames();
                            console.log('ðŸ“¦ Raw custom games data from Supabase:', customGamesData);
                            
                            if (customGamesData && Array.isArray(customGamesData) && customGamesData.length > 0) {
                                // Extract game_data from each custom game record, filtering out invalid records
                                const customGames = customGamesData
                                    .map(record => {
                                        const gameData = record.game_data;
                                        
                                        // Validate that game_data exists and has required fields
                                        if (!gameData || typeof gameData !== 'object' || !gameData.id) {
                                            console.warn('âš ï¸ Invalid game_data in record:', record.id, gameData);
                                            return null;
                                        }
                                        
                                        // Add the Supabase record ID for deletion purposes
                                        if (record.id) {
                                            gameData.supabase_id = record.id;
                                        }
                                        return gameData;
                                    })
                                    .filter(game => game !== null && game !== undefined); // Remove null/undefined entries
                                
                                if (customGames && Array.isArray(customGames) && customGames.length > 0) {
                                    console.log(`ðŸ“‹ Extracted ${customGames.length} valid custom games`);
                                    console.log('ðŸ“‹ Custom game IDs:', customGames.map(g => g.id));
                                    // Avoid duplicates
                                    const existingIds = allGames.map(g => g && g.id).filter(id => id !== undefined);
                                    console.log('ðŸ“‹ Existing game IDs:', existingIds);
                                    const newCustomGames = customGames.filter(g => g && g.id && !existingIds.includes(g.id));
                                    console.log(`ðŸ“‹ New custom games (after deduplication): ${newCustomGames.length}`);
                                    allGames = allGames.concat(newCustomGames);
                                    console.log(`âœ… Loaded ${newCustomGames.length} custom games from Supabase`);
                                    console.log('âœ… Custom games added to allGames:', newCustomGames.map(g => ({ id: g.id, name: g.name })));
                                } else {
                                    console.log('âš ï¸ No valid custom games after extraction');
                                }
                            } else {
                                console.log('No custom games found in Supabase');
                            }
                        } else {
                            if (!isLoggedIn) {
                                console.log('User not logged in, skipping custom games load');
                            } else {
                                console.log('getUserCustomGames function not available');
                            }
                        }
                    } catch (error) {
                        console.error('âŒ Error loading custom games from Supabase:', error);
                    }
                    
                    console.log(`ðŸ“Š Total games loaded: ${allGames.length}`);
                    if (allGames.length === 0) {
                        console.error('âš ï¸ WARNING: No games loaded! Check file paths and network requests.');
                    }
                    console.log('Games with locked status:', allGames.map(g => ({ name: g.name, locked: g.locked })));
                    return { games: allGames };
                    
                } catch (error) {
                    console.error('Error loading games:', error);
                    return { games: [] };
                }
            }
        }
    </script>
    <script>
        // Global variables for move navigation
        let currentGame = null;
         let currentMoveIndex = 0;
         let currentVisualMode = 'normal';
         let boardFlipped = false;
         let draggedPiece = null;
         let draggedFromSquare = null;
         let validMoves = [];
         let isChallengeMode = false;
         let completedChallenges = new Set(); // Track completed challenges
         
         // Load completed challenges from progress tracker
         function loadCompletedChallenges() {
             return progressTracker.getAllCompletedChallengesSet();
         }
         let selectedPiece = null; // Track clicked/selected piece
         let selectedSquare = null; // Track selected square
         
         // Initialize progress tracker
         let progressTracker = new ProgressTracker();
         
         // Initialize the move parser
         const moveParser = new ChessMoveParser();
        
        // Audio objects for sound effects - using your custom sound file
        const customSound = new Audio('sounds/click-21156.mp3');
        
        // Function to play sound effects - using your custom sound file
        function playSound(isCapture) {
            try {
                // Reset the sound to the beginning and play
                customSound.currentTime = 0;
                customSound.play().catch(error => {
                    console.log('Sound play failed:', error);
                });
            } catch (error) {
                console.log('Could not play sound:', error);
            }
        }

        // Load games data dynamically
        let gamesData = null;
        
        // Check login status and update navigation
        async function updateNavigation() {
            // Navigation UI updates can go here if needed
            // Profile link click handler is set up separately below
        }

        // Show account information modal
        function showAccountInfoModal() {
            const userName = localStorage.getItem('userName') || 'User';
            const userEmail = localStorage.getItem('userEmail') || 'No email provided';
            const subscriptionPlan = localStorage.getItem('subscriptionPlan') || 'free';
            
            // Format subscription display
            let subscriptionDisplay = 'Free Account';
            if (subscriptionPlan === 'monthly') {
                subscriptionDisplay = 'Premium Monthly';
            } else if (subscriptionPlan === 'quarterly') {
                subscriptionDisplay = 'Premium Quarterly';
            } else if (subscriptionPlan === 'monthly_cancelled') {
                subscriptionDisplay = 'Premium Monthly (Cancelled)';
            } else if (subscriptionPlan === 'quarterly_cancelled') {
                subscriptionDisplay = 'Premium Quarterly (Cancelled)';
            }
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Account Information</h2>
                        <span class="close" onclick="closeModal()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="account-info">
                            <div class="info-item">
                                <label>Name:</label>
                                <span>${userName}</span>
                            </div>
                            <div class="info-item">
                                <label>Email:</label>
                                <span>${userEmail}</span>
                            </div>
                            <div class="info-item">
                                <label>Subscription:</label>
                                <span>${subscriptionDisplay}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.style.display = 'block';
        }


        // Subscription Required Modal functions
        function showSubscriptionRequiredModal() {
            document.getElementById('subscriptionRequiredModal').style.display = 'block';
        }

        function closeSubscriptionModal() {
            document.getElementById('subscriptionRequiredModal').style.display = 'none';
        }

        function goToSubscription() {
            window.location.href = 'subscription.html';
        }

        // Modal functions
        function showSignInModal() {
            document.getElementById('signInModal').style.display = 'block';
            document.getElementById('registerModal').style.display = 'none';
        }

        function showRegisterModal() {
            document.getElementById('registerModal').style.display = 'block';
            document.getElementById('signInModal').style.display = 'none';
        }

        function closeModal() {
            // Close static modals
            const signInModal = document.getElementById('signInModal');
            const registerModal = document.getElementById('registerModal');
            const logoutConfirmModal = document.getElementById('logoutConfirmModal');
            const subscriptionRequiredModal = document.getElementById('subscriptionRequiredModal');
            if (signInModal) signInModal.style.display = 'none';
            if (registerModal) registerModal.style.display = 'none';
            if (logoutConfirmModal) logoutConfirmModal.style.display = 'none';
            if (subscriptionRequiredModal) subscriptionRequiredModal.style.display = 'none';
            
            // Close dynamically created modals
            const dynamicModals = document.querySelectorAll('.modal');
            dynamicModals.forEach(modal => {
                if (modal.id !== 'signInModal' && modal.id !== 'registerModal') {
                    modal.remove();
                }
            });
        }

        // Sign in form handler
        async function handleSignIn(event) {
            event.preventDefault();
            const email = document.getElementById('signInEmail').value.trim();
            const password = document.getElementById('signInPassword').value;
            
            const signInForm = document.getElementById('signInForm');
            const errorMessage = signInForm.querySelector('.error-message');
            
            if (errorMessage) {
                errorMessage.remove();
            }
            
            if (!email || !password) {
                showError(signInForm, 'Please enter both email and password');
                return;
            }
            
            const submitButton = signInForm.querySelector('button[type="submit"]');
            const originalButtonText = submitButton.textContent;
            submitButton.disabled = true;
            submitButton.textContent = 'Signing In...';
            
            const result = await signInWithEmail(email, password);
            
            if (result.success) {
                closeModal();
                window.location.href = 'profile.html';
            } else {
                showError(signInForm, result.error || 'Invalid email or password');
                submitButton.disabled = false;
                submitButton.textContent = originalButtonText;
            }
        }

        // Google OAuth handler
        async function handleGoogleSignIn() {
            const result = await signInWithGoogle();
            if (!result.success) {
                alert(result.error || 'Google sign-in failed');
            }
        }

        // Logout function
        function logout() {
            const modal = document.getElementById('logoutConfirmModal');
            if (modal) {
                modal.style.display = 'block';
            }
        }

        // Confirm logout function
        async function confirmLogout() {
            const result = await signOut();
            
            if (result.success) {
                // Close modal
                const modal = document.getElementById('logoutConfirmModal');
                if (modal) {
                    modal.style.display = 'none';
                }
                
                // Redirect to home page
                window.location.href = 'index.html';
            } else {
                alert(result.error || 'Failed to sign out');
            }
        }

        // Cancel logout function
        function cancelLogout() {
            const modal = document.getElementById('logoutConfirmModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Make functions globally accessible
        window.handleSignIn = handleSignIn;
        window.handleGoogleSignIn = handleGoogleSignIn;
        window.logout = logout;
        window.confirmLogout = confirmLogout;
        window.cancelLogout = cancelLogout;

        // Register form handler
        async function handleRegister(event) {
            event.preventDefault();
            const email = document.getElementById('registerEmail').value.trim();
            const password = document.getElementById('registerPassword').value;
            const name = document.getElementById('registerName').value.trim();
            
            // Get form elements for error display
            const registerForm = document.getElementById('registerForm');
            const errorMessage = registerForm.querySelector('.error-message');
            
            // Remove any existing error messages
            if (errorMessage) {
                errorMessage.remove();
            }
            
            // Validate inputs
            if (!email || !password || !name) {
                showError(registerForm, 'Please fill in all fields');
                return;
            }
            
            if (password.length < 6) {
                showError(registerForm, 'Password must be at least 6 characters');
                return;
            }
            
            // Show loading state
            const submitButton = registerForm.querySelector('button[type="submit"]');
            const originalButtonText = submitButton.textContent;
            submitButton.disabled = true;
            submitButton.textContent = 'Creating Account...';
            
            const result = await signUpWithEmail(email, password, name);
            
            if (result.success) {
                // Welcome email will be sent by setupAuthListener when it detects the new user
                // No need to send here to avoid duplicates
                
                closeModal();
                window.location.href = 'profile.html';
            } else {
                showError(registerForm, result.error || 'Registration failed');
                submitButton.disabled = false;
                submitButton.textContent = originalButtonText;
            }
        }
        
        // Helper function to show error messages
        function showError(form, message) {
            // Remove existing error
            const existingError = form.querySelector('.error-message');
            if (existingError) {
                existingError.remove();
            }
            
            // Create error element
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.style.color = '#e74c3c';
            errorDiv.style.marginTop = '0.5rem';
            errorDiv.style.fontSize = '0.9rem';
            errorDiv.textContent = message;
            
            // Insert before submit button
            const submitButton = form.querySelector('button[type="submit"]');
            submitButton.parentElement.insertBefore(errorDiv, submitButton);
        }

        
        // Handle OAuth callback from Google
        async function handleOAuthCallback() {
            // Supabase OAuth uses URL hash fragments (#access_token=... or #error=...)
            // Check if we have a hash with access_token or error
            const hash = window.location.hash;
            const hasOAuthHash = hash && (hash.includes('access_token') || hash.includes('error') || hash.includes('type=recovery'));
            
            if (hasOAuthHash && typeof getSupabase === 'function') {
                const supabase = getSupabase();
                if (supabase) {
                    try {
                        // Wait a bit for Supabase to process the hash
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        // Get the session - Supabase should have processed the hash by now
                        const { data, error } = await supabase.auth.getSession();
                        
                        if (!error && data.session && data.session.user) {
                            console.log('âœ… Google OAuth successful!', data.session.user);
                            
                            // Hide page content immediately to prevent flash
                            if (document.body) {
                                document.body.style.display = 'none';
                            }
                            
                            // Store user data in localStorage
                            const user = data.session.user;
                            localStorage.setItem('isLoggedIn', 'true');
                            localStorage.setItem('userEmail', user.email || '');
                            const userName = user.user_metadata?.name || 
                                           user.user_metadata?.full_name || 
                                           user.email?.split('@')[0] || 
                                           'User';
                            localStorage.setItem('userName', userName);
                            
                            // Create initial user_progress if new user
                            if (typeof window.saveUserProgress === 'function') {
                                try {
                                    await window.saveUserProgress({
                                        completedGames: [],
                                        completedPuzzles: [],
                                        totalGamesPlayed: 0,
                                        trainingHours: 0,
                                        currentStreak: 0
                                    });
                                    console.log('âœ… Initial user progress created');
                                } catch (progressError) {
                                    console.log('Note: Progress may already exist or will be created on first activity', progressError);
                                }
                            }
                            
                            // Clean up URL (remove hash)
                            window.history.replaceState({}, document.title, window.location.pathname);
                            
                            // Check for pending subscription
                            const pendingPlan = localStorage.getItem('pendingSubscription');
                            if (pendingPlan) {
                                localStorage.removeItem('pendingSubscription');
                                if (typeof redirectToDodoPayments === 'function') {
                                    redirectToDodoPayments(pendingPlan);
                                } else {
                                    window.location.href = 'index.html';
                                }
                            } else {
                                // Redirect to profile immediately after Google sign-in (no delay)
                                window.location.replace('profile.html');
                            }
                            
                            return true; // Success
                        } else if (error) {
                            console.error('OAuth session error:', error);
                            return false;
                        }
                    } catch (error) {
                        console.error('OAuth callback error:', error);
                        return false;
                    }
                }
            }
            return false;
        }
        
        // Initialize tabs functionality
        function initializeTabs() {
            console.log('Initializing tabs...');
            const tabs = document.querySelectorAll('.games-tabs .tab');
            const panels = document.querySelectorAll('.tab-panel');
            
            console.log('Found tabs:', tabs.length);
            console.log('Found panels:', panels.length);
            
            tabs.forEach((tab, index) => {
                console.log(`Setting up tab ${index}:`, tab.textContent, tab.dataset.tab);
                tab.addEventListener('click', (e) => {
                    console.log('Tab clicked:', tab.textContent, tab.dataset.tab);
                    e.preventDefault();
                    
                    // Remove active class from all tabs and panels
                    tabs.forEach(t => t.classList.remove('active'));
                    panels.forEach(p => p.classList.remove('active'));
                    
                    // Add active class to clicked tab
                    tab.classList.add('active');
                    
                    // Show corresponding panel
                    const tabId = tab.dataset.tab;
                    const panel = document.getElementById(`${tabId}-panel`);
                    console.log('Looking for panel:', `${tabId}-panel`, panel);
                    if (panel) {
                        panel.classList.add('active');
                        console.log('Panel activated:', panel.id);
                    } else {
                        console.error('Panel not found:', `${tabId}-panel`);
                    }
                    
                    // Exit test mode when switching tabs
                    if (isChallengeMode) {
                        toggleChallengeMode();
                    }
                    
                    // Reset to initial page state when switching tabs
                    resetBoard();
                    currentGame = null;
                    currentMoveIndex = 0;
                    updateMoveButtons();
                    
                    // Hide hint button when switching tabs
                    updateHintButtonVisibility();
                    
                    // Hide game display
                    const gameDisplay = document.getElementById('game-display');
                    if (gameDisplay) {
                        gameDisplay.classList.remove('show');
                    }
                    
                    // Reset moves list to initial state
                    const movesList = document.getElementById('moves-list');
                    if (movesList) {
                        movesList.innerHTML = '<p style="text-align: center; color: #7f8c8d;">Select a game to view moves</p>';
                        movesList.style.display = 'block';
                    }
                    
                    // Reset game details to initial state
                    document.getElementById('detail-description').textContent = '-';
                    document.getElementById('detail-moves').textContent = '-';
                    document.getElementById('detail-white').textContent = '-';
                    document.getElementById('detail-black').textContent = '-';
                    document.getElementById('detail-opening').textContent = '-';
                    document.getElementById('detail-difficulty').textContent = '-';
                    document.getElementById('detail-facts').textContent = '-';
                    
                    // Hide game header
                    const gameHeader = document.getElementById('game-header');
                    if (gameHeader) {
                        gameHeader.style.display = 'none';
                    }
                    
                    // Hide play color selection
                    const playColorSection = document.getElementById('play-color-section');
                    if (playColorSection) {
                        playColorSection.style.display = 'none';
                    }
                    
                    // Hide comment section
                    const commentSection = document.getElementById('comment-section');
                    if (commentSection) {
                        commentSection.style.display = 'none';
                    }
                    
                    // All tabs now use the same game functionality
                    // Games are loaded automatically by updateGameButtons()
                });
            });
        }

        // All tabs now use the same game functionality
        // The loadMyGamesContent and loadGMGamesContent functions are no longer needed
        // since all tabs display the same game categories

        // TEST FUNCTION - Run this in console to test custom games loading
        window.testCustomGames = async function() {
            console.log('ðŸ§ª TEST: Testing custom games loading...');
            
            // Check if functions are available
            console.log('ðŸ§ª window.getSupabase:', typeof window.getSupabase);
            console.log('ðŸ§ª window.getUserCustomGames:', typeof window.getUserCustomGames);
            console.log('ðŸ§ª window.isSignedIn:', typeof window.isSignedIn);
            console.log('ðŸ§ª window.getCurrentUser:', typeof window.getCurrentUser);
            
            // Check authentication
            let isLoggedIn = false;
            if (typeof window.isSignedIn === 'function') {
                isLoggedIn = await window.isSignedIn();
                console.log('ðŸ§ª isSignedIn():', isLoggedIn);
            } else if (typeof window.getCurrentUser === 'function') {
                const user = await window.getCurrentUser();
                isLoggedIn = user !== null;
                console.log('ðŸ§ª getCurrentUser():', user ? 'user found' : 'no user');
            } else if (typeof window.getSupabase === 'function') {
                const supabase = window.getSupabase();
                if (supabase && supabase.auth) {
                    const { data: { session } } = await supabase.auth.getSession();
                    isLoggedIn = session !== null && session.user !== null;
                    console.log('ðŸ§ª getSession():', session ? 'session found' : 'no session');
                }
            }
            
            console.log('ðŸ§ª Final isLoggedIn:', isLoggedIn);
            
            // Try to load custom games
            if (isLoggedIn && typeof window.getUserCustomGames === 'function') {
                console.log('ðŸ§ª Calling getUserCustomGames()...');
                const customGames = await window.getUserCustomGames();
                console.log('ðŸ§ª Result:', customGames);
                console.log('ðŸ§ª Number of games:', customGames ? customGames.length : 0);
                if (customGames && customGames.length > 0) {
                    console.log('ðŸ§ª First game sample:', customGames[0]);
                    console.log('ðŸ§ª First game game_data:', customGames[0].game_data);
                }
                return customGames;
            } else {
                console.log('ðŸ§ª Cannot load - isLoggedIn:', isLoggedIn, 'getUserCustomGames available:', typeof window.getUserCustomGames === 'function');
                return null;
            }
        };

        // Initialize games data on page load
        async function loadGamesOnPageLoad() {
            console.log('ðŸŽ¯ loadGamesOnPageLoad() called');
            console.log('DOM loaded, loading games...');
            
            // Wait for GameLoader to be available (might be from chess-move-parser.js)
            let attempts = 0;
            while (typeof GameLoader === 'undefined' && attempts < 50) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            // CRITICAL: Load games FIRST, independently of Supabase
            // Games should work even if Supabase fails
            try {
                console.log('ðŸš€ About to call GameLoader.loadGamesFromFiles()...');
                console.log('ðŸš€ GameLoader available:', typeof GameLoader !== 'undefined');
                
                if (typeof GameLoader === 'undefined') {
                    console.error('âŒ GameLoader is not defined after waiting!');
                    return;
                }
                
                gamesData = await GameLoader.loadGamesFromFiles();
                console.log('âœ… GameLoader.loadGamesFromFiles() completed');
                console.log('Loaded games:', gamesData);
                console.log('Number of games loaded:', gamesData ? gamesData.games.length : 0);
                console.log('Custom games count:', gamesData ? gamesData.games.filter(g => g && g.id && g.id.startsWith('custom-game-')).length : 0);
                
                // Update game buttons immediately after loading games
                updateGameButtons();
            } catch (error) {
                console.error('âŒ Error loading games:', error);
                console.error('Error stack:', error.stack);
                gamesData = { games: [] };
                // Still try to update UI even if games failed to load
                try {
                    updateGameButtons();
                } catch (e) {
                    console.error('Error updating game buttons:', e);
                }
            }
        }

        // Call reloadGamesData() on page load (same function that works manually)
        console.log('ðŸŽ¯ Script executing, document.readyState:', document.readyState);
        console.log('ðŸŽ¯ Setting up automatic games loading...');
        
        // Use reloadGamesData since we know it works
        async function autoLoadGames() {
            console.log('ðŸŽ¯ autoLoadGames() called - using reloadGamesData()');
            if (typeof reloadGamesData === 'function') {
                await reloadGamesData();
            } else {
                console.log('ðŸŽ¯ reloadGamesData not available yet, calling loadGamesOnPageLoad()');
                await loadGamesOnPageLoad();
            }
        }
        
        if (document.readyState === 'loading') {
            console.log('ðŸŽ¯ DOM still loading, waiting for DOMContentLoaded...');
            document.addEventListener('DOMContentLoaded', function() {
                console.log('ðŸŽ¯ DOMContentLoaded fired, calling autoLoadGames()...');
                autoLoadGames();
            });
        } else {
            // DOM already loaded, call immediately
            console.log('ðŸŽ¯ DOM already loaded, calling autoLoadGames() immediately...');
            autoLoadGames();
        }
        
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('ðŸŽ¯ DOMContentLoaded event fired - games.html');
            
            // Initialize tabs (doesn't depend on Supabase)
            try {
                initializeTabs();
            } catch (error) {
                console.error('Error initializing tabs:', error);
            }
            
            // Profile link click handler - checks auth before navigation
            const profileLink = document.getElementById('profileLink');
            if (profileLink) {
                // Remove any existing click handlers by cloning
                const newProfileLink = profileLink.cloneNode(true);
                profileLink.parentNode.replaceChild(newProfileLink, profileLink);
                
                newProfileLink.addEventListener('click', async function(e) {
                    e.preventDefault();
                    
                    // Check auth state using getSupabase() and getSession()
                    if (typeof window.getSupabase === 'function') {
                        const supabase = window.getSupabase();
                        if (supabase && supabase.auth) {
                            const { data: { session } } = await supabase.auth.getSession();
                            if (session && session.user) {
                                // User is authenticated - navigate to profile
                                window.location.href = 'profile.html';
                            } else {
                                // User is NOT authenticated - show login modal
                                if (typeof showSignInModal === 'function') {
                                    showSignInModal();
                                }
                            }
                        } else {
                            // Supabase not ready - show login modal
                            if (typeof showSignInModal === 'function') {
                                showSignInModal();
                            }
                        }
                    } else {
                        // getSupabase not available - show login modal
                        if (typeof showSignInModal === 'function') {
                            showSignInModal();
                        }
                    }
                });
            }

            // Load completed challenges from Supabase (optional - games work without this)
            // CRITICAL: Load completed challenges ONLY from Supabase (no cache, no fallback)
            if (typeof window.getUserProgress === 'function') {
                try {
                    console.log('ðŸ”„ Fetching fresh progress from Supabase for badges (no cache, no fallback)');
                    const supabaseProgress = await window.getUserProgress();
                    if (supabaseProgress) {
                        console.log('âœ… Loading completed games/puzzles from Supabase for badges...');
                        console.log('Supabase completed_games:', supabaseProgress.completed_games);
                        console.log('Supabase completed_puzzles:', supabaseProgress.completed_puzzles);
                        
                        // Build completedChallenges Set directly from Supabase data (no progressTracker)
                        completedChallenges = new Set();
                        if (supabaseProgress.completed_games && Array.isArray(supabaseProgress.completed_games)) {
                            supabaseProgress.completed_games.forEach(gameId => completedChallenges.add(gameId));
                        }
                        if (supabaseProgress.completed_puzzles && Array.isArray(supabaseProgress.completed_puzzles)) {
                            supabaseProgress.completed_puzzles.forEach(puzzleId => completedChallenges.add(puzzleId));
                        }
                        
                        console.log('âœ… Loaded completed challenges from Supabase:', completedChallenges);
                        console.log('Completed challenges array:', Array.from(completedChallenges));
                        
                        // Fetch subscription and payment data
                        let subscriptionData = null;
                        let lastPayment = null;
                        
                        // Fetch subscription data
                        if (typeof window.getUserSubscription === 'function') {
                            try {
                                subscriptionData = await window.getUserSubscription();
                                console.log('ðŸ“¦ Subscription data:', subscriptionData);
                            } catch (subError) {
                                console.error('âŒ Error fetching subscription:', subError);
                            }
                        }
                        
                        // Fetch last payment
                        if (window.getSupabase && window.getSupabase()) {
                            try {
                                const supabase = window.getSupabase();
                                const { data: { user } } = await supabase.auth.getUser();
                                if (user) {
                                    const { data: payments, error: paymentError } = await supabase
                                        .from('payments')
                                        .select('*')
                                        .eq('user_id', user.id)
                                        .eq('status', 'paid')
                                        .order('payment_date', { ascending: false })
                                        .limit(1);
                                    
                                    if (!paymentError && payments && payments.length > 0) {
                                        lastPayment = payments[0];
                                        console.log('ðŸ’³ Last payment:', lastPayment);
                                    }
                                }
                            } catch (paymentError) {
                                console.error('âŒ Error fetching last payment:', paymentError);
                            }
                        }
                        
                        // Update Supabase data table with progress, subscription, and payment data
                        updateSupabaseDataTable(supabaseProgress, subscriptionData, lastPayment);
                    } else {
                        // No data in Supabase - clear completed challenges (show 0 badges)
                        console.log('ðŸ“Š No Supabase data - clearing completed challenges (no badges)');
                        completedChallenges = new Set();
                        updateSupabaseDataTable(null, null, null);
                    }
                } catch (error) {
                    console.error('âŒ Error loading progress from Supabase:', error);
                    // On error, clear completed challenges (no fallback to cache)
                    completedChallenges = new Set();
                    updateSupabaseDataTable(null, null, null);
                }
            } else {
                // getUserProgress not available - clear completed challenges
                console.log('âš ï¸ getUserProgress not available - clearing completed challenges');
                completedChallenges = new Set();
                updateSupabaseDataTable(null, null, null);
            }
            
            // Update the game buttons display (already called after games load, but call again to refresh badges)
            try {
                updateGameButtons();
            } catch (error) {
                console.error('Error updating game buttons:', error);
            }
            
            // Function to update the Supabase data table
            function updateSupabaseDataTable(supabaseData, subscriptionData, lastPayment) {
                const tbody = document.getElementById('supabaseDataTableBody');
                if (!tbody) {
                    console.warn('âš ï¸ supabaseDataTableBody not found in games.html');
                    return;
                }
                
                if (!supabaseData) {
                    tbody.innerHTML = `
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid #d1d5db; font-weight: 500;">Status</td>
                            <td style="padding: 0.75rem; border: 1px solid #d1d5db; color: #ef4444;">No data available</td>
                        </tr>
                    `;
                    return;
                }
                
                // Format the data for display
                const rows = [];
                
                // User ID
                if (supabaseData.user_id) {
                    rows.push({
                        field: 'user_id',
                        value: supabaseData.user_id
                    });
                }
                
                // Completed Games
                rows.push({
                    field: 'completed_games',
                    value: Array.isArray(supabaseData.completed_games) 
                        ? `[${supabaseData.completed_games.length} items] ${JSON.stringify(supabaseData.completed_games)}`
                        : String(supabaseData.completed_games || 'null')
                });
                
                // Completed Puzzles
                rows.push({
                    field: 'completed_puzzles',
                    value: Array.isArray(supabaseData.completed_puzzles)
                        ? `[${supabaseData.completed_puzzles.length} items] ${JSON.stringify(supabaseData.completed_puzzles)}`
                        : String(supabaseData.completed_puzzles || 'null')
                });
                
                // Training Hours
                rows.push({
                    field: 'training_hours',
                    value: supabaseData.training_hours !== null && supabaseData.training_hours !== undefined
                        ? String(supabaseData.training_hours)
                        : 'null'
                });
                
                // Current Streak
                rows.push({
                    field: 'current_streak',
                    value: supabaseData.current_streak !== null && supabaseData.current_streak !== undefined
                        ? String(supabaseData.current_streak)
                        : 'null'
                });
                
                // Add subscription and payment information
                rows.push({
                    field: '--- Payment Information ---',
                    value: '---'
                });
                
                // Subscription Status
                if (subscriptionData) {
                    rows.push({
                        field: 'subscribed',
                        value: 'Yes'
                    });
                    
                    // Plan Type (Monthly or Quarterly)
                    rows.push({
                        field: 'plan_type',
                        value: subscriptionData.plan_type ? subscriptionData.plan_type.charAt(0).toUpperCase() + subscriptionData.plan_type.slice(1) : 'null'
                    });
                    
                    // Amount Paid
                    rows.push({
                        field: 'amount_paid',
                        value: subscriptionData.amount_paid !== null && subscriptionData.amount_paid !== undefined
                            ? `${subscriptionData.amount_paid} ${subscriptionData.currency || 'EUR'}`
                            : 'null'
                    });
                    
                    // Billing Period
                    rows.push({
                        field: 'billing_period',
                        value: subscriptionData.plan_type === 'monthly' ? 'Monthly' : subscriptionData.plan_type === 'quarterly' ? 'Quarterly' : 'null'
                    });
                    
                    // Next Payment Date
                    rows.push({
                        field: 'next_payment',
                        value: subscriptionData.next_billing_date 
                            ? new Date(subscriptionData.next_billing_date).toLocaleDateString()
                            : 'null'
                    });
                    
                    // Cancelled Status
                    rows.push({
                        field: 'cancelled',
                        value: subscriptionData.status === 'cancelled' ? 'Yes' : 'No'
                    });
                } else {
                    rows.push({
                        field: 'subscribed',
                        value: 'No'
                    });
                    rows.push({
                        field: 'plan_type',
                        value: 'Free'
                    });
                    rows.push({
                        field: 'amount_paid',
                        value: 'null'
                    });
                    rows.push({
                        field: 'billing_period',
                        value: 'null'
                    });
                    rows.push({
                        field: 'next_payment',
                        value: 'null'
                    });
                    rows.push({
                        field: 'cancelled',
                        value: 'N/A'
                    });
                }
                
                // Last Payment
                rows.push({
                    field: 'last_payment',
                    value: lastPayment 
                        ? `${lastPayment.amount} ${lastPayment.currency || 'EUR'} on ${new Date(lastPayment.payment_date).toLocaleDateString()}`
                        : 'null'
                });
                
                // Add any other fields that might exist
                Object.keys(supabaseData).forEach(key => {
                    if (!['user_id', 'completed_games', 'completed_puzzles', 'training_hours', 'current_streak'].includes(key)) {
                        const value = supabaseData[key];
                        rows.push({
                            field: key,
                            value: typeof value === 'object' ? JSON.stringify(value) : String(value || 'null')
                        });
                    }
                });
                
                // Build table rows
                tbody.innerHTML = rows.map(row => `
                    <tr>
                        <td style="padding: 0.75rem; border: 1px solid #d1d5db; font-weight: 500; background-color: #f9fafb; font-size: 0.875rem;">${row.field}</td>
                        <td style="padding: 0.75rem; border: 1px solid #d1d5db; font-family: monospace; font-size: 0.75rem; word-break: break-all; max-width: 500px;">${row.value}</td>
                    </tr>
                `).join('');
            }
            updateNavigation();
            
            // Update completion badges after games are loaded
            updateGameListBadges();
            
            // Set up training timer click detection
            setupTrainingTimer();
            
            // Add event listeners for forms
            document.getElementById('signInForm').addEventListener('submit', handleSignIn);
            document.getElementById('registerForm').addEventListener('submit', handleRegister);
            
            // Add event listeners for close buttons
            document.querySelectorAll('.close').forEach(closeBtn => {
                closeBtn.addEventListener('click', closeModal);
            });
            
            // Close modal when clicking outside
            window.addEventListener('click', function(event) {
                const signInModal = document.getElementById('signInModal');
                const registerModal = document.getElementById('registerModal');
                const logoutConfirmModal = document.getElementById('logoutConfirmModal');
                const subscriptionRequiredModal = document.getElementById('subscriptionRequiredModal');
                if (event.target === signInModal) {
                    closeModal();
                }
                if (event.target === registerModal) {
                    closeModal();
                }
                if (event.target === logoutConfirmModal) {
                    closeModal();
                }
                if (event.target === subscriptionRequiredModal) {
                    closeModal();
                }
            });
        });
        
        // Set up training timer for piece movements
        function setupTrainingTimer() {
            // Training timer will be started when pieces are moved
            // (handled in movePiece and movePieceDirectly functions)
            
            // Reset idle timer on any user activity
            document.addEventListener('mousemove', function() {
                if (progressTracker.trainingTimer.isRunning) {
                    progressTracker.resetTrainingIdleTimer();
                }
            });
            
            document.addEventListener('keydown', function() {
                if (progressTracker.trainingTimer.isRunning) {
                    progressTracker.resetTrainingIdleTimer();
                }
            });
            
            // Stop training timer when leaving the page
            window.addEventListener('beforeunload', function() {
                progressTracker.stopTrainingTimer();
            });
        }

        // Function to reload games data
        async function reloadGamesData() {
            try {
                console.log('ðŸ”„ Reloading games data...');
                gamesData = await GameLoader.loadGamesFromFiles();
                console.log('ðŸ“Š Reloaded games:', gamesData);
                console.log('ðŸ“Š Total games loaded:', gamesData ? gamesData.games.length : 0);
                console.log('ðŸ“Š Custom games:', gamesData ? gamesData.games.filter(g => g && g.id && g.id.startsWith('custom-game-')).length : 0);
                updateGameButtons();
                console.log('âœ… Game buttons updated');
            } catch (error) {
                console.error('âŒ Error reloading games:', error);
            }
        }
        
        // Function to clear the chess board - remove all pieces
        function clearChessBoard() {
            console.log('Clearing chess board...');
            
            // Clear all squares on the board
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.querySelector(`[data-square="${String.fromCharCode(97 + j)}${8 - i}"]`);
                    if (square) {
                        square.innerHTML = '';
                    }
                }
            }
            
            // Clear any selection or highlights on the board
            document.querySelectorAll('.selected').forEach(element => {
                element.classList.remove('selected');
            });
            document.querySelectorAll('.valid-move').forEach(element => {
                element.classList.remove('valid-move');
            });
            document.querySelectorAll('.last-move').forEach(element => {
                element.classList.remove('last-move');
            });
            
            console.log('Chess board cleared');
        }

        // Function to clear only custom game elements (not the entire right section)
        function clearCustomGameElements() {
            console.log('Clearing custom game elements...');
            
            // Hide custom game info section
            const customGameInfo = document.getElementById('custom-game-info');
            if (customGameInfo) {
                customGameInfo.style.display = 'none';
            }
            
            // Hide custom commentary section
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            
            // Hide custom save button and message
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }
            
            // Clear the chess board - remove all pieces
            clearChessBoard();
            
            console.log('Custom game elements cleared');
        }

        // Function to clear the right section (moves section)
        function clearRightSection() {
            console.log('Clearing right section...');
            
            // Clear the moves list
            const movesList = document.getElementById('moves-list');
            if (movesList) {
                movesList.innerHTML = '';
                movesList.style.display = 'none';
            }
            
            // Hide game info sections
            const gameHeader = document.getElementById('game-header');
            const gameDetails = document.getElementById('game-details');
            if (gameHeader) {
                gameHeader.style.display = 'none';
            }
            if (gameDetails) {
                gameDetails.style.display = 'none';
            }
            
            // Hide custom game info section
            const customGameInfo = document.getElementById('custom-game-info');
            if (customGameInfo) {
                customGameInfo.style.display = 'none';
            }
            
            // Hide comment section
            const commentSection = document.getElementById('comment-section');
            if (commentSection) {
                commentSection.style.display = 'none';
            }
            
            // Hide delete game section
            const deleteGameSection = document.getElementById('delete-game-section');
            if (deleteGameSection) {
                deleteGameSection.style.display = 'none';
            }
            
            // Hide custom commentary section
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            
            // Hide custom save button and message
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }
            
            // Reset move buttons
            const btnInitial = document.getElementById('btn-initial');
            const btnBack = document.getElementById('btn-back');
            const btnForward = document.getElementById('btn-forward');
            const btnFinal = document.getElementById('btn-final');
            
            if (btnInitial) btnInitial.classList.add('disabled');
            if (btnBack) btnBack.classList.add('disabled');
            if (btnForward) btnForward.classList.add('disabled');
            if (btnFinal) btnFinal.classList.add('disabled');
            
            // Clear any highlights
            document.querySelectorAll('.clickable-move').forEach(span => {
                span.classList.remove('active-move');
            });
            document.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                section.classList.remove('clicked');
            });
            
            // Clear the chess board - remove all pieces
            clearChessBoard();
            
            console.log('Right section cleared');
        }

        // Store reference to Supabase delete helper at module level (before function definition)
        // This ensures we get the helper from supabase-helpers.js before any local function overwrites it
        let supabaseDeleteHelperRef = null;
        
        // Function to get the Supabase delete helper (cached)
        // IMPORTANT: This must be called BEFORE the local deleteCustomGame function is used
        async function getSupabaseDeleteHelper() {
            if (supabaseDeleteHelperRef) {
                return supabaseDeleteHelperRef;
            }
            
            // Wait for supabase-helpers.js to load
            let attempts = 0;
            while (attempts < 50) {
                // Check if the function exists and verify it's the Supabase helper
                // The Supabase helper only takes one parameter (gameId), not (event, gameId)
                if (typeof window.deleteCustomGame === 'function') {
                    // Store the reference immediately
                    supabaseDeleteHelperRef = window.deleteCustomGame;
                    console.log('âœ… Got Supabase delete helper reference');
                    return supabaseDeleteHelperRef;
                }
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            console.error('âŒ Supabase deleteCustomGame function not available');
            return null;
        }
        
        // Function to delete a custom game (local wrapper that handles the event)
        async function deleteCustomGameLocal(event, gameId) {
            event.stopPropagation(); // Prevent the game from being selected
            
            try {
                console.log('ðŸ—‘ï¸ Deleting custom game:', gameId);
                console.log('ðŸ—‘ï¸ Event object type:', typeof event, event.constructor.name);
                console.log('ðŸ—‘ï¸ GameId type:', typeof gameId, gameId);
                
                // Validate gameId - ensure it's not the event object
                if (!gameId || typeof gameId !== 'string' || gameId === '[object PointerEvent]') {
                    console.error('âŒ Invalid gameId:', gameId);
                    alert('Error: Invalid game ID. Please refresh the page and try again.');
                    return;
                }
                
                // Use Supabase helper function to delete the game
                // First, we need to get the Supabase game ID from the custom game ID
                // The gameId passed here is like "custom-game-123", but we need the database ID
                
                // Get all custom games to find the database ID
                if (typeof window.getUserCustomGames !== 'function') {
                    console.error('âŒ getUserCustomGames function not available');
                    alert('Error: Cannot delete game. Please refresh the page and try again.');
                    return;
                }
                
                const customGames = await window.getUserCustomGames();
                console.log('ðŸ—‘ï¸ Found custom games:', customGames.length);
                
                const gameToDelete = customGames.find(g => {
                    // Match by the game_data.id field
                    return g.game_data && g.game_data.id === gameId;
                });
                
                if (!gameToDelete) {
                    console.error('âŒ Game not found in Supabase:', gameId);
                    console.error('âŒ Available game IDs:', customGames.map(g => g.game_data?.id));
                    alert('Error: Game not found. It may have already been deleted.');
                    return;
                }
                
                console.log('ðŸ—‘ï¸ Found game to delete:', gameToDelete.id);
                console.log('ðŸ—‘ï¸ Database ID:', gameToDelete.id);
                console.log('ðŸ—‘ï¸ Database ID type:', typeof gameToDelete.id);
                
                // Get the Supabase delete helper
                const supabaseDeleteHelper = await getSupabaseDeleteHelper();
                if (!supabaseDeleteHelper) {
                    alert('Error: Cannot delete game. Please refresh the page and try again.');
                    return;
                }
                
                // Verify we have the correct ID (should be a UUID string, not an event)
                if (typeof gameToDelete.id !== 'string' || gameToDelete.id.includes('PointerEvent')) {
                    console.error('âŒ Invalid database ID:', gameToDelete.id);
                    alert('Error: Invalid game ID format. Please refresh the page and try again.');
                    return;
                }
                
                // Call the Supabase delete function with the database ID (NOT the event!)
                console.log('ðŸ—‘ï¸ Calling Supabase delete with ID:', gameToDelete.id);
                console.log('ðŸ—‘ï¸ Supabase helper type:', typeof supabaseDeleteHelper);
                const result = await supabaseDeleteHelper(gameToDelete.id);
                
                if (result.success) {
                    console.log('âœ… Game deleted successfully from Supabase');
                    
                    // Clear the right section (moves section) after successful deletion
                    clearRightSection();
                    
                    console.log('ðŸ”„ Reloading games data...');
                    // Reload the games data to update the display
                    await reloadGamesData();
                    console.log('âœ… Games data reloaded');
                } else {
                    console.error('âŒ Failed to delete game:', result.error);
                    alert('Error: ' + (result.error || 'Failed to delete game'));
                }
            } catch (error) {
                console.error('âŒ Error deleting game:', error);
                alert('Error: ' + (error.message || 'Failed to delete game'));
            }
        }


        // Make functions globally accessible
        window.reloadGamesData = reloadGamesData;
        window.updateGameButtons = updateGameButtons;
        // Note: deleteCustomGame is NOT assigned to window here because
        // we want to use the Supabase helper function from supabase-helpers.js
        // The local deleteCustomGame function handles the event and calls the Supabase helper

        // Function to update game buttons display
        function updateGameButtons() {
            console.log('Updating game buttons...');
            if (!gamesData || !gamesData.games) {
                console.log('No games data available');
                return;
            }
            
            // Group games by category (filter out undefined/null games first)
            const validGames = gamesData.games.filter(g => g && g.id);
            const shortGames = validGames.filter(g => g.moves <= 10 && !g.id.startsWith('custom-game-'));
            const mediumGames = validGames.filter(g => g.moves > 10 && g.moves <= 30 && !g.id.startsWith('custom-game-'));
            const longGames = validGames.filter(g => g.moves > 30 && !g.id.startsWith('custom-game-'));
            const customGames = validGames.filter(g => g.id.startsWith('custom-game-'));
            
            console.log('=== GAME CATEGORIZATION DEBUG ===');
            console.log('Total games loaded:', gamesData.games.length);
            console.log('Short games:', shortGames.length, shortGames.map(g => ({ name: g.name, locked: g.locked })));
            console.log('Medium games:', mediumGames.length, mediumGames.map(g => ({ name: g.name, locked: g.locked })));
            console.log('Long games:', longGames.length, longGames.map(g => ({ name: g.name, locked: g.locked })));
            console.log('Custom games:', customGames.length);
            console.log('Custom games details:', customGames);
            console.log('All games IDs:', gamesData.games.map(g => g.id));
            console.log('Custom game IDs:', customGames.map(g => g.id));
            console.log('Custom games for My Games tab:', customGames.filter(g => g.id.startsWith('custom-game-')));
            
            // Update all tabs with the same game data
            const tabPrefixes = ['', 'my-games-', 'gm-games-'];
            
            tabPrefixes.forEach(prefix => {
                // Update short games
                updateGameCategory(prefix + 'short-games-submenu', shortGames);
                // Update medium games  
                updateGameCategory(prefix + 'medium-games-submenu', mediumGames);
                // Update long games
                updateGameCategory(prefix + 'long-games-submenu', longGames);
                // Update custom games
                updateGameCategory(prefix + 'my-games-submenu', customGames);
            });
            
            // Update the My Games tab's custom submenu specifically
            updateGameCategory('my-games-my-games-submenu', customGames);
            
            // Update opening tab
            updateOpeningTab();
        }
        
        // Function to update the opening tab with games grouped by opening
        function updateOpeningTab() {
            if (!gamesData || !gamesData.games) {
                console.log('No games data available for opening tab');
                return;
            }
            
            // Filter out custom games
            const standardGames = gamesData.games.filter(g => g && g.id && !g.id.startsWith('custom-game-'));
            
            // Group games by opening
            const gamesByOpening = {};
            standardGames.forEach(game => {
                const opening = game.opening || 'Unknown Opening';
                if (!gamesByOpening[opening]) {
                    gamesByOpening[opening] = [];
                }
                gamesByOpening[opening].push(game);
            });
            
            // Get the opening panel container
            const openingPanel = document.getElementById('opening-panel');
            if (!openingPanel) {
                console.error('Opening panel not found');
                return;
            }
            
            const gameButtonsContainer = openingPanel.querySelector('.game-buttons');
            if (!gameButtonsContainer) {
                console.error('Game buttons container not found in opening panel');
                return;
            }
            
            // Clear existing content
            gameButtonsContainer.innerHTML = '';
            
            // Sort openings alphabetically
            const sortedOpenings = Object.keys(gamesByOpening).sort();
            
            // Create a button for each opening
            sortedOpenings.forEach((opening, index) => {
                const games = gamesByOpening[opening];
                const openingId = opening.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                
                // Create button container
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'game-button-container';
                
                // Create button
                const button = document.createElement('a');
                button.href = `#${openingId}`;
                button.className = 'game-button' + (index === 0 ? ' active' : '');
                button.id = `opening-${openingId}-btn`;
                
                const buttonDiv = document.createElement('div');
                buttonDiv.textContent = opening;
                button.appendChild(buttonDiv);
                
                const descriptionDiv = document.createElement('div');
                descriptionDiv.className = 'description';
                descriptionDiv.textContent = `${games.length} ${games.length === 1 ? 'game' : 'games'}`;
                button.appendChild(descriptionDiv);
                
                // Create submenu
                const submenu = document.createElement('div');
                submenu.className = 'submenu';
                submenu.id = `opening-${openingId}-submenu`;
                
                buttonContainer.appendChild(button);
                buttonContainer.appendChild(submenu);
                gameButtonsContainer.appendChild(buttonContainer);
                
                // Populate submenu with games
                updateGameCategory(`opening-${openingId}-submenu`, games);
                
                // Add click handler for the button
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // Remove active class from all buttons in opening panel
                    gameButtonsContainer.querySelectorAll('.game-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    // Hide all submenus
                    gameButtonsContainer.querySelectorAll('.submenu').forEach(sub => {
                        sub.style.display = 'none';
                    });
                    
                    // Add active class to clicked button
                    button.classList.add('active');
                    
                    // Show corresponding submenu
                    submenu.style.display = 'block';
                });
            });
            
            // Show first opening's submenu by default
            if (sortedOpenings.length > 0) {
                const firstOpeningId = sortedOpenings[0].toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                const firstSubmenu = document.getElementById(`opening-${firstOpeningId}-submenu`);
                if (firstSubmenu) {
                    firstSubmenu.style.display = 'block';
                }
            }
        }
        
        function updateGameCategory(categoryId, games) {
            console.log(`ðŸ“‹ Updating category ${categoryId} with ${games.length} games`);
            console.log(`ðŸ“‹ Games for ${categoryId}:`, games.map(g => g ? { id: g.id, name: g.name } : 'null/undefined'));
            
            // Filter out any null/undefined games
            const validGames = games.filter(g => g && g.id);
            console.log(`ðŸ“‹ Valid games after filtering: ${validGames.length}`);
            
            const categoryElement = document.getElementById(categoryId);
            if (!categoryElement) {
                console.error(`âŒ Category element not found: ${categoryId}`);
                return;
            }
            
            console.log(`âœ… Found category element: ${categoryId}`);
            
            // Clear existing content
            categoryElement.innerHTML = '';
            
            if (validGames.length === 0) {
                console.log(`âš ï¸ No valid games to display for ${categoryId}`);
            }
            
            validGames.forEach(game => {
                const gameButton = document.createElement('a');
                gameButton.href = '#';
                gameButton.className = 'submenu-button';
                gameButton.setAttribute('data-game-id', game.id);
                
                // Check if user has active subscription
                const hasActiveSubscription = localStorage.getItem('hasActiveSubscription') === 'true';
                const isGameLocked = game.locked && !hasActiveSubscription;
                
                // Add locked class if game is locked and user doesn't have subscription
                if (isGameLocked) {
                    gameButton.classList.add('locked');
                }
                
                gameButton.onclick = (e) => {
                    e.preventDefault();
                    if (isGameLocked) {
                        // Show subscription required modal
                        showSubscriptionRequiredModal();
                        return;
                    }
                    displayGame(game.id);
                };
                
                let buttonContent = `
                    <span>${game.name}</span>
                    <span class="game-completion-badge" data-game="${game.id}"><img src="images/checklist.png" alt="Complete" style="width: 20px; height: 20px;"></span>
                `;
                
                // Add lock overlay if game is locked and user doesn't have subscription
                if (isGameLocked) {
                    buttonContent += `
                        <div class="lock-overlay">
                            <div class="lock-icon">ðŸ”’</div>
                        </div>
                    `;
                }
                
                gameButton.innerHTML = buttonContent;
                
                categoryElement.appendChild(gameButton);
            });
            
            // Update completion badges after creating game buttons
            updateGameListBadges();
            
            // Add "Add Game" button to short games submenu
            
            // Add "Add Game" button to my games submenu
            if (categoryId === 'my-games-submenu' || categoryId === 'my-games-my-games-submenu') {
                const addGameButton = document.createElement('a');
                addGameButton.href = '#';
                addGameButton.className = 'submenu-button';
                addGameButton.id = 'add-game-my-btn';
                
                // Add Game button is now unlocked for all users
                addGameButton.onclick = (e) => {
                    e.preventDefault();
                    initializeCustomGameMode();
                };
                
                let buttonContent = `
                    <span>+ Add Game</span>
                `;
                
                addGameButton.innerHTML = buttonContent;
                
                categoryElement.appendChild(addGameButton);
            }
        }
        
        // Function to reset the board to empty state
        function resetBoard() {
            // Clear all squares
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.querySelector(`[data-square="${String.fromCharCode(97 + j)}${8 - i}"]`);
                    if (square) {
                        square.innerHTML = '';
                    }
                }
            }
            
            // Reset piece positions in parser
            moveParser.resetBoard();
            
            // Don't call setupStartingPosition() - board should be empty until game is selected
        }
        
        function setupStartingPosition() {
            // White pieces
            const whitePieces = {
                'a1': 'Chess_rlt45.svg.png', 'b1': 'Chess_nlt45.svg.png', 'c1': 'Chess_blt45.svg.png', 'd1': 'Chess_qlt45.svg.png',
                'e1': 'Chess_klt45.svg.png', 'f1': 'Chess_blt45.svg.png', 'g1': 'Chess_nlt45.svg.png', 'h1': 'Chess_rlt45.svg.png',
                'a2': 'Chess_plt45.svg.png', 'b2': 'Chess_plt45.svg.png', 'c2': 'Chess_plt45.svg.png', 'd2': 'Chess_plt45.svg.png',
                'e2': 'Chess_plt45.svg.png', 'f2': 'Chess_plt45.svg.png', 'g2': 'Chess_plt45.svg.png', 'h2': 'Chess_plt45.svg.png'
            };
            
            // Black pieces
            const blackPieces = {
                'a8': 'Chess_rdt45.svg.png', 'b8': 'Chess_ndt45.svg.png', 'c8': 'Chess_bdt45.svg.png', 'd8': 'Chess_qdt45.svg.png',
                'e8': 'Chess_kdt45.svg.png', 'f8': 'Chess_bdt45.svg.png', 'g8': 'Chess_ndt45.svg.png', 'h8': 'Chess_rdt45.svg.png',
                'a7': 'Chess_pdt45.svg.png', 'b7': 'Chess_pdt45.svg.png', 'c7': 'Chess_pdt45.svg.png', 'd7': 'Chess_pdt45.svg.png',
                'e7': 'Chess_pdt45.svg.png', 'f7': 'Chess_pdt45.svg.png', 'g7': 'Chess_pdt45.svg.png', 'h7': 'Chess_pdt45.svg.png'
            };
            
            // Place white pieces
            Object.entries(whitePieces).forEach(([square, piece]) => {
                const squareElement = document.querySelector(`[data-square="${square}"]`);
                if (squareElement) {
                    const pieceElement = createDraggablePiece(piece, square);
                    squareElement.appendChild(pieceElement);
                }
            });
            
            // Place black pieces
            Object.entries(blackPieces).forEach(([square, piece]) => {
                const squareElement = document.querySelector(`[data-square="${square}"]`);
                if (squareElement) {
                    const pieceElement = createDraggablePiece(piece, square);
                    squareElement.appendChild(pieceElement);
                }
            });
        }
        

        // Initialize chess board
        function generateCoordinateLabels() {
            const bottomLabels = document.getElementById('coordinate-labels-bottom');
            const rightLabels = document.getElementById('coordinate-labels-right');
            
            // Clear existing labels
            bottomLabels.innerHTML = '';
            rightLabels.innerHTML = '';
            
            // Generate letter labels (a-h) for bottom
            const letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            
            for (let i = 0; i < 8; i++) {
                const bottomLabel = document.createElement('div');
                const displayLetter = boardFlipped ? letters[7 - i] : letters[i];
                
                bottomLabel.className = 'coordinate-label letter';
                bottomLabel.textContent = displayLetter;
                
                bottomLabels.appendChild(bottomLabel);
            }
            
            // Generate number labels (1-8) for right
            const numbers = ['8', '7', '6', '5', '4', '3', '2', '1'];
            
            for (let i = 0; i < 8; i++) {
                const rightLabel = document.createElement('div');
                const displayNumber = boardFlipped ? numbers[7 - i] : numbers[i];
                
                rightLabel.className = 'coordinate-label number';
                rightLabel.textContent = displayNumber;
                
                rightLabels.appendChild(rightLabel);
            }
        }

        function initializeChessBoard() {
            const board = document.getElementById('chess-board');
            board.innerHTML = '';
            
            // Create 64 squares (8x8)
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    
                    // Calculate square color based on actual chess position
                    let actualRow, actualCol;
                    if (boardFlipped) {
                        // When flipped, we want to show the board from black's perspective
                        actualRow = 7 - row;  // Flip rows
                        actualCol = 7 - col;  // Flip columns
                    } else {
                        actualRow = row;
                        actualCol = col;
                    }
                    
                    const isLight = (actualRow + actualCol) % 2 === 0;
                    square.className = `chess-square ${isLight ? 'light' : 'dark'}`;
                    
                    // Convert row/col to chess notation (a1, b1, etc.)
                    // When flipped, reverse the row and column order
                    let file, rank;
                    if (boardFlipped) {
                        file = String.fromCharCode(97 + (7 - col)); // h, g, f, etc. when flipped
                        rank = row + 1; // 1, 2, 3, etc. when flipped
                    } else {
                        file = String.fromCharCode(97 + col); // a, b, c, etc.
                        rank = 8 - row; // 8, 7, 6, etc.
                    }
                    square.dataset.square = file + rank;
                    
                    // Add drop event listeners
                    square.addEventListener('dragover', handleDragOver);
                    square.addEventListener('drop', handleDrop);
                    
                    // Add click event listener
                    square.addEventListener('click', handleSquareClick);
                    
                    board.appendChild(square);
                }
            }
            
            // Show board after rendering is complete
            setTimeout(() => {
                board.classList.add('ready');
            }, 0);
        }

        // Set up initial board position
        function setupInitialPosition() {
            const board = document.getElementById('chess-board');
            const squares = board.querySelectorAll('.chess-square');
            
            // Clear all pieces
            squares.forEach(square => {
                square.innerHTML = '';
            });

            // Only set up pieces if a game is selected
            if (currentGame) {
                let initialPosition;
                
                // Check if the game has a custom initial position
                if (currentGame.initial_position) {
                    initialPosition = currentGame.initial_position;
                } else {
                    // Use standard starting position
                    initialPosition = {
                        // Black pieces
                        'a8': 'Chess_rdt45.svg.png', 'b8': 'Chess_ndt45.svg.png', 'c8': 'Chess_bdt45.svg.png', 'd8': 'Chess_qdt45.svg.png',
                        'e8': 'Chess_kdt45.svg.png', 'f8': 'Chess_bdt45.svg.png', 'g8': 'Chess_ndt45.svg.png', 'h8': 'Chess_rdt45.svg.png',
                        'a7': 'Chess_pdt45.svg.png', 'b7': 'Chess_pdt45.svg.png', 'c7': 'Chess_pdt45.svg.png', 'd7': 'Chess_pdt45.svg.png',
                        'e7': 'Chess_pdt45.svg.png', 'f7': 'Chess_pdt45.svg.png', 'g7': 'Chess_pdt45.svg.png', 'h7': 'Chess_pdt45.svg.png',
                        
                        // White pieces
                        'a1': 'Chess_rlt45.svg.png', 'b1': 'Chess_nlt45.svg.png', 'c1': 'Chess_blt45.svg.png', 'd1': 'Chess_qlt45.svg.png',
                        'e1': 'Chess_klt45.svg.png', 'f1': 'Chess_blt45.svg.png', 'g1': 'Chess_nlt45.svg.png', 'h1': 'Chess_rlt45.svg.png',
                        'a2': 'Chess_plt45.svg.png', 'b2': 'Chess_plt45.svg.png', 'c2': 'Chess_plt45.svg.png', 'd2': 'Chess_plt45.svg.png',
                        'e2': 'Chess_plt45.svg.png', 'f2': 'Chess_plt45.svg.png', 'g2': 'Chess_plt45.svg.png', 'h2': 'Chess_plt45.svg.png'
                    };
                }

                // Place pieces on their corresponding squares
                Object.entries(initialPosition).forEach(([squareNotation, pieceImage]) => {
                    if (pieceImage && pieceImage !== '') { // Only place pieces if there's an image and it's not empty
                        const square = board.querySelector(`[data-square="${squareNotation}"]`);
                        if (square) {
                            const pieceElement = createDraggablePiece(pieceImage, squareNotation);
                            square.appendChild(pieceElement);
                        }
                    }
                });
            }
        }

        // Helper function to get square notation from index
        function getSquareNotation(index) {
            const row = Math.floor(index / 8);
            const col = index % 8;
            
            // When flipped, we need to calculate notation differently
            if (boardFlipped) {
                const file = String.fromCharCode(97 + (7 - col));
                const rank = row + 1;
                return file + rank;
            } else {
                return String.fromCharCode(97 + col) + (8 - row);
            }
        }

        // Create a draggable piece element
        function createDraggablePiece(pieceImage, squareNotation) {
            const pieceElement = document.createElement('div');
            pieceElement.className = 'chess-piece';
            pieceElement.style.backgroundImage = `url('pieces/${pieceImage}')`;
            pieceElement.draggable = true;
            pieceElement.dataset.piece = pieceImage;
            pieceElement.dataset.square = squareNotation;
            
            // Store original piece before applying visual mode
            pieceElement.dataset.originalPiece = pieceImage;
            
            // Add drag event listeners
            pieceElement.addEventListener('dragstart', handleDragStart);
            pieceElement.addEventListener('dragend', handleDragEnd);
            
            // Add click event listener
            pieceElement.addEventListener('click', handlePieceClick);
            
            // Apply current visual mode to the new piece
            applyVisualModeToPiece(pieceElement, currentVisualMode);
            
            // Make invisible if in challenge mode
            if (isChallengeMode) {
                pieceElement.style.opacity = '0';
            }
            
            return pieceElement;
        }

        // Update piece square notation when moved
        function updatePieceSquare(pieceElement, newSquare) {
            pieceElement.dataset.square = newSquare;
        }

        // Re-initialize drag and drop for all pieces on the board
        function reinitializeDragAndDrop() {
            const pieces = document.querySelectorAll('.chess-piece');
            pieces.forEach((piece, index) => {
                // Remove existing event listeners
                piece.removeEventListener('dragstart', handleDragStart);
                piece.removeEventListener('dragend', handleDragEnd);
                piece.removeEventListener('click', handlePieceClick);
                
                // Re-add event listeners
                piece.addEventListener('dragstart', handleDragStart);
                piece.addEventListener('dragend', handleDragEnd);
                piece.addEventListener('click', handlePieceClick);
                
                // Ensure piece is draggable
                piece.draggable = true;
                
                // Apply current visual mode to ensure consistency
                applyVisualModeToPiece(piece, currentVisualMode);
                
                // Make invisible if in test mode (overrides visual mode)
                if (isChallengeMode) {
                    piece.style.opacity = '0';
                }
            });
            
            // Also re-setup drop event listeners for squares
            const squares = document.querySelectorAll('.chess-square');
            squares.forEach(square => {
                // Remove existing event listeners
                square.removeEventListener('dragover', handleDragOver);
                square.removeEventListener('drop', handleDrop);
                square.removeEventListener('click', handleSquareClick);
                
                // Re-add event listeners
                square.addEventListener('dragover', handleDragOver);
                square.addEventListener('drop', handleDrop);
                square.addEventListener('click', handleSquareClick);
            });
        }

        // Handle drag start
        function handleDragStart(e) {
            console.log('Target:', e.target);
            console.log('Custom game mode:', typeof customGameMode !== 'undefined' ? customGameMode : 'undefined');
            console.log('Window custom game mode:', typeof window.customGameMode !== 'undefined' ? window.customGameMode : 'undefined');
            
            draggedPiece = e.target;
            draggedFromSquare = e.target.dataset.square;
            
            // Add dragging class to disable transitions on piece and board
            e.target.classList.add('dragging');
            const board = document.getElementById('chess-board');
            board.classList.add('dragging');
            console.log('Added dragging class to piece, classes now:', e.target.classList.toString());
            console.log('Added dragging class to board, classes now:', board.classList.toString());
            
            // Highlight valid moves
            highlightValidMoves();
            
            // Create a custom drag image with consistent size
            const dragImage = e.target.cloneNode(true);
            dragImage.style.width = '60px';
            dragImage.style.height = '60px';
            dragImage.style.position = 'absolute';
            dragImage.style.top = '-1000px';
            dragImage.style.left = '-1000px';
            
            // Apply current visual mode to drag image
            if (currentVisualMode === 'empty' || isChallengeMode) {
                dragImage.style.opacity = '0'; // Keep invisible in empty mode or challenge mode
            } else {
                dragImage.style.opacity = '1';
            }
            
            document.body.appendChild(dragImage);
            
            e.dataTransfer.setDragImage(dragImage, 30, 30);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
            
            // Clean up the drag image after a short delay
            setTimeout(() => {
                if (dragImage.parentNode) {
                    dragImage.parentNode.removeChild(dragImage);
                }
            }, 0);
            
            // Keep original piece invisible in empty mode or challenge mode, otherwise semi-transparent
            if (currentVisualMode === 'empty' || isChallengeMode) {
                e.target.style.opacity = '0';
            } else {
                e.target.style.opacity = '0.5';
            }
        }

        // Handle drag end
        function handleDragEnd(e) {
            console.log('Target:', e.target);
            console.log('Target current square:', e.target.dataset.square);
            console.log('Dragged from square:', draggedFromSquare);
            console.log('Custom game mode:', typeof customGameMode !== 'undefined' ? customGameMode : 'undefined');
            console.log('Window custom game mode:', typeof window.customGameMode !== 'undefined' ? window.customGameMode : 'undefined');
            console.log('Valid moves at drag end:', validMoves);
            
            // Check if the piece is still in the same position (hasn't been moved)
            const isStillInOriginalPosition = e.target.dataset.square === draggedFromSquare;
            console.log('Piece still in original position:', isStillInOriginalPosition);
            
            // Check if a move was actually completed by looking for a piece at the destination
            let moveWasCompleted = false;
            if (draggedFromSquare && validMoves.length > 0) {
                // Check if any of the valid move squares now have a piece
                validMoves.forEach(squareNotation => {
                    const square = getSquareByNotation(squareNotation);
                    if (square && square.querySelector('.chess-piece')) {
                        moveWasCompleted = true;
                        console.log('Move was completed - found piece at', squareNotation);
                    }
                });
            }
            console.log('Move was completed:', moveWasCompleted);
            
            // Remove dragging class to re-enable transitions
            e.target.classList.remove('dragging');
            const board = document.getElementById('chess-board');
            board.classList.remove('dragging');
            console.log('Removed dragging class from piece, classes now:', e.target.classList.toString());
            console.log('Removed dragging class from board, classes now:', board.classList.toString());
            
            // Clear highlights
            clearHighlights();
            
            // Only restore opacity if the piece is still in its original position AND no move was completed
            // If it was moved, the new piece already has the correct opacity
            if (isStillInOriginalPosition && !moveWasCompleted) {
                console.log('Restoring opacity for unmoved piece');
                // Restore piece opacity based on current visual mode or challenge mode
                if (currentVisualMode === 'empty' || isChallengeMode) {
                    e.target.style.opacity = '0';
                } else {
                    e.target.style.opacity = '1';
                }
            } else if (moveWasCompleted) {
                console.log('Move was completed - not restoring opacity for original piece');
                // Hide the original piece since it was moved
                e.target.style.opacity = '0';
                
                // Check if we should autoplay the next move after a manual move
                // Note: currentMoveIndex has already been incremented in the move validation logic
                const selectedColor = window.selectedPlayColor || 'both';
                if (selectedColor !== 'both' && currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                    const nextMove = currentGame.moves_detailed[currentMoveIndex];
                    const isNextWhiteMove = !!nextMove.white;
                    const shouldAutoplayNext = (selectedColor === 'white' && !isNextWhiteMove) || 
                                             (selectedColor === 'black' && isNextWhiteMove);
                    
                    console.log('Manual move completed - checking autoplay:', {
                        selectedColor,
                        currentMoveIndex,
                        nextMove: nextMove.white || nextMove.black,
                        isNextWhiteMove,
                        shouldAutoplayNext
                    });
                    
                    if (shouldAutoplayNext) {
                        console.log('Auto-playing next move after manual move');
                        setTimeout(() => {
                            goToNextMove();
                        }, 300); // Short delay after manual move
                    }
                }
            } else {
                console.log('Piece was moved, skipping opacity restoration');
            }
            
            // Reset drag variables
            draggedPiece = null;
            draggedFromSquare = null;
        }

        // Handle piece click (for click-to-select)
        function handlePieceClick(e) {
            e.stopPropagation(); // Prevent square click from firing
            
            const piece = e.target;
            const square = piece.parentElement;
            const squareNotation = getSquareNotationFromElement(square);
            
            console.log('Piece clicked on square:', squareNotation);
            
            // Clear previous selection
            clearSelection();
            
            // Select this piece
            selectedPiece = piece;
            selectedSquare = squareNotation;
            
            // Calculate valid moves for this piece
            draggedPiece = piece; // Temporarily set for move calculation
            draggedFromSquare = squareNotation;
            calculateValidMoves();
            
            // Show selection highlight (only in normal mode)
            if (!isChallengeMode) {
                console.log('Adding selected class to square:', square);
                square.classList.add('selected');
                console.log('Square classes after adding selected:', square.className);
                
                // Show valid move highlights too
                validMoves.forEach(moveSquare => {
                    const validSquare = getSquareByNotation(moveSquare);
                    if (validSquare) {
                        validSquare.classList.add('valid-move');
                    }
                });
            }
            
            console.log('Piece selected. Valid moves:', validMoves);
        }

        // Handle square click (for click-to-move)
        function handleSquareClick(e) {
            const clickedSquare = e.target;
            const clickedSquareNotation = getSquareNotationFromElement(clickedSquare);
            
            console.log('Square clicked:', clickedSquareNotation);
            const pieceOnSquare = clickedSquare.querySelector('.chess-piece');
            console.log('Square has piece:', pieceOnSquare !== null);
            
            // If there's a piece on this square and no piece is currently selected, select this piece
            if (pieceOnSquare && (!selectedPiece || !selectedSquare)) {
                console.log('Selecting piece on clicked square');
                handlePieceClick({ target: pieceOnSquare, stopPropagation: () => {} });
                return;
            }
            
            // If no piece is selected, do nothing
            if (!selectedPiece || !selectedSquare) {
                console.log('No piece selected');
                return;
            }
            
            // Check if this is a valid move
            if (validMoves.includes(clickedSquareNotation)) {
                console.log('Valid move! Moving from', selectedSquare, 'to', clickedSquareNotation);
                
                // Execute the move
                movePieceDirectly(selectedSquare, clickedSquareNotation, selectedPiece.dataset.piece);
                
                // Reset idle timer after move
                progressTracker.resetIdleTimer();
                
                // Update game state
                if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                    currentMoveIndex++;
                    updateMoveButtons();
                    highlightCurrentMove();
                    
                    // Unclick hint button after move
                    unclickHintButton();
                    
                    // Update hint button visibility (hide if on last move)
                    updateHintButtonVisibility();
                    
                    // Show green check indicator when on the last move (for all modes except test mode)
                    if (currentMoveIndex >= currentGame.moves_detailed.length) {
                        removeLastMoveCheck();
                        setTimeout(() => {
                            showLastMoveCheck();
                        }, 50);
                    }
                    
                    // Check if this is the final move and trigger completion indicator (only in test mode)
                    if (isChallengeMode && currentMoveIndex >= currentGame.moves_detailed.length) {
                        setTimeout(() => {
                            showCompletionIndicator();
                        }, 200);
                    }
                    
                    // Update comment section with current move info
                    const move = currentGame.moves_detailed[currentMoveIndex - 1];
                    const moveNotation = move.white || move.black;
                    showMoveCommentary(move.description, moveNotation, move);
                    
                    checkChallengeProgress();
                }
                
                // Clear selection
                clearSelection();
                
                // Reinitialize drag and drop
                setTimeout(() => {
                    reinitializeDragAndDrop();
                }, 100);
            } else {
                console.log('Invalid move to', clickedSquareNotation);
                // Clear selection on invalid move
                clearSelection();
            }
        }

        // Clear piece selection and highlights
        function clearSelection() {
            // Clear visual highlights
            const selectedSquares = document.querySelectorAll('.chess-square.selected');
            selectedSquares.forEach(square => square.classList.remove('selected'));
            
            clearHighlights();
            
            // Clear selection variables
            selectedPiece = null;
            selectedSquare = null;
            draggedPiece = null;
            draggedFromSquare = null;
            validMoves = [];
        }

        // Calculate valid moves for current piece
        function calculateValidMoves() {
            if (!currentGame || currentMoveIndex >= currentGame.moves_detailed.length) {
                validMoves = [];
                return;
            }
            
            const currentMove = currentGame.moves_detailed[currentMoveIndex];
            const isWhiteMove = !!currentMove.white;
            
            // Debug: Log all properties of the move object
            console.log('Move object keys:', Object.keys(currentMove));
            console.log('Move object values:', Object.values(currentMove));
            console.log('white_to field:', currentMove.white_to);
            console.log('black_to field:', currentMove.black_to);
            
            // Check if the dragged piece is the correct piece for this move
            const expectedFrom = isWhiteMove ? currentMove.white_from : currentMove.black_from;
            const expectedTo = isWhiteMove ? currentMove.white_to : currentMove.black_to;
            
            console.log('Move validation:', {
                gameId: currentGame.id,
                gameName: currentGame.name,
                totalMoves: currentGame.moves_detailed.length,
                moveIndex: currentMoveIndex,
                move: currentMove.white || currentMove.black,
                isWhiteMove,
                expectedFrom,
                expectedTo,
                draggedFrom: draggedFromSquare,
                rawMove: currentMove
            });
            
            if (draggedFromSquare !== expectedFrom) {
                console.log('Wrong piece! Expected on', expectedFrom, 'but dragged from', draggedFromSquare);
                validMoves = [];
                return;
            }
            
            // Set valid destination square
            validMoves = [expectedTo];
            console.log('Valid moves set to:', validMoves);
        }

        // Highlight valid moves for current piece (only in normal mode)
        function highlightValidMoves() {
            // Calculate valid moves first
            calculateValidMoves();
            
            // Don't highlight moves in challenge mode - pure memory test
            if (isChallengeMode) {
                console.log('Challenge mode active - no move highlighting');
                return;
            }
            
            // Highlight valid squares
            validMoves.forEach(squareNotation => {
                const square = getSquareByNotation(squareNotation);
                if (square) {
                    square.classList.add('valid-move');
                    console.log('Highlighted square:', squareNotation);
                }
            });
        }


        // Clear move highlights
        function clearHighlights() {
            const squares = document.querySelectorAll('.chess-square');
            squares.forEach(square => {
                square.classList.remove('valid-move');
            });
        }

        // Handle drag over
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation(); // Prevent event bubbling to avoid infinite loops
            e.dataTransfer.dropEffect = 'move';
            
            // Only process if we're dragging over a square, not a piece
            if (e.target.classList.contains('chess-piece')) {
                return; // Don't process dragover events on pieces
            }
            
            
            if (e.target.classList.contains('chess-square')) {
                const squareNotation = getSquareNotationFromElement(e.target);
            }
        }

        // Handle drop
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation(); // Prevent event bubbling
            
            
            if (!draggedPiece || !draggedFromSquare) {
                console.log('No dragged piece or from square');
                return;
            }
            
            // Find the square element (not the piece)
            let toSquare = e.target;
            console.log('Initial toSquare:', toSquare);
            
            // If we dropped on a piece, get its parent square
            if (toSquare.classList.contains('chess-piece')) {
                console.log('Dropped on piece, getting parent square');
                toSquare = toSquare.parentElement;
                console.log('Parent square:', toSquare);
            }
            
            // Make sure we have a square element
            if (!toSquare.classList.contains('chess-square')) {
                console.log('Not a valid square element:', toSquare);
                return;
            }
            
            const toSquareNotation = getSquareNotationFromElement(toSquare);
            console.log('Destination square notation:', toSquareNotation);
            console.log('Is valid move?', validMoves.includes(toSquareNotation));
            
            // Check if trying to drop on the same square
            if (toSquareNotation === draggedFromSquare) {
                console.log('Cannot drop on the same square!');
                return;
            }
            
            // Check if this is a valid move
            if (validMoves.includes(toSquareNotation)) {
                console.log('Valid move! Executing move from', draggedFromSquare, 'to', toSquareNotation);
                
                // Move the piece directly without animation since it's already being dragged
                movePieceDirectly(draggedFromSquare, toSquareNotation, draggedPiece.dataset.piece);
                
                // Reset idle timer after move
                progressTracker.resetIdleTimer();
                
                 // Advance to next move
                 if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                     currentMoveIndex++;
                     
                     // Use the same update system as move buttons
                     updateBoardPosition();
                     updateMoveButtons();
                     highlightCurrentMove();
                     
                     // Unclick hint button after move
                     unclickHintButton();
                     
                     // Update hint button visibility (hide if on last move)
                     updateHintButtonVisibility();
                     
                     // Show green check indicator when on the last move (for all modes except test mode)
                     if (currentMoveIndex >= currentGame.moves_detailed.length) {
                         removeLastMoveCheck();
                         setTimeout(() => {
                             showLastMoveCheck();
                         }, 300);
                     }
                     
                     // Check if this is the final move and trigger completion indicator (only in test mode)
                     if (isChallengeMode && currentMoveIndex >= currentGame.moves_detailed.length) {
                         setTimeout(() => {
                             showCompletionIndicator();
                         }, 200);
                     }
                     
                     // Update comment section with current move info
                     const move = currentGame.moves_detailed[currentMoveIndex - 1];
                     const moveNotation = move.white || move.black;
                     showMoveCommentary(move.description, moveNotation, move);
                     
                     // Check challenge progress
                     checkChallengeProgress();
                 }
            } else {
                console.log('Invalid move! Cannot drop on', toSquareNotation);
            }
        }

        // Get square notation from element
        function getSquareNotationFromElement(squareElement) {
            // Get the notation directly from the data-square attribute
            return squareElement.dataset.square;
        }

        // Execute a move (either by drag or button)
        function executeMove(from, to, piece) {
            // Move the piece with animation
            movePiece(from, to, piece, true);
            
            // Advance to next move
            if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                currentMoveIndex++;
                updateMoveButtons();
            }
        }

        // Move piece directly without animation (for drag and drop)
        function movePieceDirectly(from, to, piece) {
            // Start training timer on piece movement
            progressTracker.startTrainingTimer();
            
            console.log('=== MOVE PIECE DIRECTLY DEBUG ===');
            console.log('Moving piece from', from, 'to', to);
            const fromSquare = getSquareByNotation(from);
            const toSquare = getSquareByNotation(to);
            
            if (fromSquare && toSquare) {
                // Debug square dimensions BEFORE any changes
                const fromRectBefore = fromSquare.getBoundingClientRect();
                const toRectBefore = toSquare.getBoundingClientRect();
                console.log('BEFORE CHANGES:');
                console.log('From square dimensions:', {
                    width: fromRectBefore.width,
                    height: fromRectBefore.height,
                    classes: fromSquare.classList.toString()
                });
                console.log('To square dimensions:', {
                    width: toRectBefore.width,
                    height: toRectBefore.height,
                    classes: toSquare.classList.toString()
                });
                
                // Ensure board is in dragging state to disable transitions
                const board = document.getElementById('chess-board');
                board.classList.add('dragging');
                console.log('Added dragging class to board');
                console.log('Board classes after adding dragging:', board.classList.toString());
                
                // Check if transitions are actually disabled
                const computedStyle = window.getComputedStyle(toSquare);
                const transition = computedStyle.transition;
                console.log('To square transition property:', transition);
                
                // Clear valid-move class from ALL squares BEFORE making changes
                // This prevents size changes during the move operation
                clearHighlights();
                console.log('Cleared all highlights');
                
                // Debug square dimensions AFTER clearing highlights
                const fromRectAfterHighlights = fromSquare.getBoundingClientRect();
                const toRectAfterHighlights = toSquare.getBoundingClientRect();
                console.log('AFTER CLEARING HIGHLIGHTS:');
                console.log('From square dimensions:', {
                    width: fromRectAfterHighlights.width,
                    height: fromRectAfterHighlights.height,
                    classes: fromSquare.classList.toString()
                });
                console.log('To square dimensions:', {
                    width: toRectAfterHighlights.width,
                    height: toRectAfterHighlights.height,
                    classes: toSquare.classList.toString()
                });
                
                // Clear source square completely
                fromSquare.innerHTML = '';
                console.log('Cleared source square');
                
                // Debug square dimensions AFTER clearing source
                const fromRectAfterClear = fromSquare.getBoundingClientRect();
                console.log('AFTER CLEARING SOURCE:');
                console.log('From square dimensions:', {
                    width: fromRectAfterClear.width,
                    height: fromRectAfterClear.height,
                    classes: fromSquare.classList.toString()
                });
                
                // Clear destination square (in case there's a piece to capture)
                toSquare.innerHTML = '';
                console.log('Cleared destination square');
                
                // Debug square dimensions AFTER clearing destination
                const toRectAfterClear = toSquare.getBoundingClientRect();
                console.log('AFTER CLEARING DESTINATION:');
                console.log('To square dimensions:', {
                    width: toRectAfterClear.width,
                    height: toRectAfterClear.height,
                    classes: toSquare.classList.toString()
                });
                
                // Create new piece at destination
                const pieceElement = createDraggablePiece(piece, to);
                toSquare.appendChild(pieceElement);
                console.log('Added piece to destination');
                
                // Debug square dimensions AFTER adding piece
                const toRectAfterPiece = toSquare.getBoundingClientRect();
                console.log('AFTER ADDING PIECE:');
                console.log('To square dimensions:', {
                    width: toRectAfterPiece.width,
                    height: toRectAfterPiece.height,
                    classes: toSquare.classList.toString()
                });
                
                // Remove dragging class after a short delay to re-enable transitions
                setTimeout(() => {
                    board.classList.remove('dragging');
                    console.log('Removed dragging class from board');
                    
                    // Final debug after removing dragging class
                    const toRectFinal = toSquare.getBoundingClientRect();
                    console.log('FINAL DIMENSIONS:');
                    console.log('To square dimensions:', {
                        width: toRectFinal.width,
                        height: toRectFinal.height,
                        classes: toSquare.classList.toString()
                    });
                }, 50);
                
                console.log('Move completed');
                
                // Play move sound effect
                playSound(false);
            } else {
                console.log('Invalid squares - from:', fromSquare, 'to:', toSquare);
            }
            console.log('=== END MOVE PIECE DIRECTLY ===');
        }



        // Animate existing piece from source to destination
        function animateExistingPiece(sourceSquare, destinationSquare, pieceImage) {
            // Get the existing piece from source square
            const existingPiece = sourceSquare.querySelector('.chess-piece');
            if (!existingPiece) return;

            // Get the chess board container
            const board = document.getElementById('chess-board');
            
            // Create a temporary piece for animation
            const tempPiece = existingPiece.cloneNode(true);
            tempPiece.style.position = 'absolute';
            tempPiece.style.zIndex = '1000';
            tempPiece.style.pointerEvents = 'none';
            tempPiece.style.width = '60px';
            tempPiece.style.height = '60px';
            tempPiece.style.transition = 'all 0.3s ease-in-out';

            // Get positions
            const sourceRect = sourceSquare.getBoundingClientRect();
            const destRect = destinationSquare.getBoundingClientRect();
            const boardRect = board.getBoundingClientRect();

            // Calculate positions relative to the board
            const sourceLeft = sourceRect.left - boardRect.left;
            const sourceTop = sourceRect.top - boardRect.top;
            const destLeft = destRect.left - boardRect.left;
            const destTop = destRect.top - boardRect.top;

            // Position the temp piece at source
            tempPiece.style.left = sourceLeft + 'px';
            tempPiece.style.top = sourceTop + 'px';

            // Add to board
            board.appendChild(tempPiece);

            // Remove the original piece immediately to prevent double pieces
            sourceSquare.innerHTML = '';

            // Animate to destination
            requestAnimationFrame(() => {
                tempPiece.style.left = destLeft + 'px';
                tempPiece.style.top = destTop + 'px';
            });

            // After animation, place piece in destination square and clean up
            setTimeout(() => {
                // Remove temp piece
                if (tempPiece.parentNode) {
                    tempPiece.parentNode.removeChild(tempPiece);
                }

                // Clear destination square completely before placing new piece
                destinationSquare.innerHTML = '';
                
                // Create a new draggable piece at destination
                const newPiece = createDraggablePiece(pieceImage, getSquareNotationFromElement(destinationSquare));
                destinationSquare.appendChild(newPiece);
                
                // Play sound after animation completes
                playSound(false);
                
                // Re-initialize drag and drop for all pieces
                reinitializeDragAndDrop();
            }, 300);
        }

        // Show move commentary
        function showMoveCommentary(commentary, move, moveData) {
            // Update the comment content
            const commentContent = document.getElementById('comment-content');
            const commentSection = document.getElementById('comment-section');
            
            if (commentContent && moveData) {
                const moveNumber = moveData.move_number;
                const player = moveData.white ? 'White' : 'Black';
                const annotation = moveData.annotation || '';
                
                // Only show commentary if there's an annotation mark and commentary
                if (annotation && moveData.commentary) {
                    // Show only the commentary text without move details
                    commentContent.innerHTML = moveData.commentary;
                    // Show the comment section
                    if (commentSection) {
                        commentSection.style.display = 'block';
                    }
                } else {
                    // Hide the comment section if no annotation or commentary
                    if (commentSection) {
                        commentSection.style.display = 'none';
                    }
                }
            } else if (commentContent) {
                commentContent.innerHTML = `<strong>Move ${convertToChessSymbols(move)}:</strong><br>${commentary}`;
                // Show the comment section for fallback commentary
                if (commentSection) {
                    commentSection.style.display = 'block';
                }
            }
        }

        // Display game moves
        function displayGameMoves(game) {
            const movesList = document.getElementById('moves-list');
            movesList.innerHTML = '';
            
            // Reset comment section when displaying new game
            const commentContent = document.getElementById('comment-content');
            const commentSection = document.getElementById('comment-section');
            if (commentContent) {
                commentContent.innerHTML = 'Click on any move to see detailed commentary';
            }
            // Hide comment section by default
            if (commentSection) {
                commentSection.style.display = 'none';
            }

            // Group moves by move number (white and black moves together)
            const moveGroups = {};
            game.moves_detailed.forEach(move => {
                if (!moveGroups[move.move_number]) {
                    moveGroups[move.move_number] = { white: null, black: null };
                }
                if (move.white) {
                    moveGroups[move.move_number].white = move.white;
                }
                if (move.black) {
                    moveGroups[move.move_number].black = move.black;
                }
            });

            // Display all moves in a structured layout
            const moveItem = document.createElement('div');
            moveItem.className = 'move-item';
            
            // Create move numbers and moves
            Object.keys(moveGroups).forEach((moveNumber, moveIndex) => {
                const group = moveGroups[moveNumber];
                
                // Create move row
                const moveRow = document.createElement('div');
                moveRow.className = 'move-row';
                
                // Add move number to the row
                const moveNumberSpan = document.createElement('span');
                moveNumberSpan.textContent = moveNumber + '.';
                moveNumberSpan.className = 'move-number';
                moveRow.appendChild(moveNumberSpan);
                
                // Create white moves container
                const whiteMoves = document.createElement('div');
                whiteMoves.className = 'white-moves';
                
                // Create black moves container
                const blackMoves = document.createElement('div');
                blackMoves.className = 'black-moves';
                
                // Add white move if it exists
                if (group.white) {
                    const whiteMoveSpan = document.createElement('span');
                    whiteMoveSpan.textContent = convertToChessSymbols(group.white);
                    whiteMoveSpan.className = 'clickable-move';
                    whiteMoveSpan.dataset.moveIndex = moveIndex * 2;
                    
                    // Find the move data for annotations
                    const whiteMoveData = game.moves_detailed.find(m => m.white === group.white && m.move_number == moveNumber);
                    if (whiteMoveData) {
                        // Add annotation if it exists
                        if (whiteMoveData.annotation) {
                            const annotationSpan = document.createElement('span');
                            annotationSpan.textContent = whiteMoveData.annotation;
                            annotationSpan.className = 'move-annotation';
                            annotationSpan.style.marginLeft = '4px';
                            annotationSpan.style.color = '#000000';
                            whiteMoveSpan.appendChild(annotationSpan);
                        }
                        
                    }
                    
                    whiteMoves.appendChild(whiteMoveSpan);
                }
                
                // Add click listener to entire white-moves div
                whiteMoves.addEventListener('click', function() {
                    if (group.white) {
                        currentMoveIndex = moveIndex * 2 + 1;
                        updateBoardPosition();
                        updateMoveButtons();
                        
                        // Unclick hint button when clicking on moves
                        unclickHintButton();
                        
                        // Update hint button visibility
                        updateHintButtonVisibility();
                        
                        // Show green check indicator when on the last move (for all modes except test mode)
                        if (currentMoveIndex >= game.moves_detailed.length) {
                            removeLastMoveCheck();
                            setTimeout(() => {
                                showLastMoveCheck();
                            }, 50);
                        }
                        
                        // Check if this is the final move and trigger completion indicator (only in test mode)
                        if (isChallengeMode && currentMoveIndex >= game.moves_detailed.length) {
                            setTimeout(() => {
                                showCompletionIndicator();
                            }, 200);
                        }
                        
                        // Remove highlight from all moves and sections
                        moveItem.querySelectorAll('.clickable-move').forEach(span => {
                            span.classList.remove('active-move');
                        });
                        moveItem.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                            section.classList.remove('clicked');
                        });
                        // Highlight current move and section
                        if (group.white) {
                            whiteMoves.querySelector('.clickable-move').classList.add('active-move');
                        }
                        whiteMoves.classList.add('clicked');
                        
                        // Show commentary if available
                        const whiteMoveData = game.moves_detailed.find(m => m.white === group.white && m.move_number == moveNumber);
                        if (whiteMoveData) {
                            showMoveCommentary(whiteMoveData.description, group.white, whiteMoveData);
                        }
                        
                        // Check if we should autoplay the next move after clicking a move
                        const selectedColor = window.selectedPlayColor || 'both';
                        if (selectedColor !== 'both' && currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                            const nextMove = currentGame.moves_detailed[currentMoveIndex];
                            const isNextWhiteMove = !!nextMove.white;
                            const shouldAutoplayNext = (selectedColor === 'white' && !isNextWhiteMove) || 
                                                     (selectedColor === 'black' && isNextWhiteMove);
                            
                            console.log('Move clicked - checking autoplay:', {
                                selectedColor,
                                currentMoveIndex,
                                nextMove: nextMove.white || nextMove.black,
                                isNextWhiteMove,
                                shouldAutoplayNext
                            });
                            
                            if (shouldAutoplayNext) {
                                console.log('Auto-playing next move after move click');
                                setTimeout(() => {
                                    goToNextMove();
                                }, 300); // Short delay after move click
                            }
                        }
                    }
                });
                
                // Add black move if it exists
                if (group.black) {
                    const blackMoveSpan = document.createElement('span');
                    blackMoveSpan.textContent = convertToChessSymbols(group.black);
                    blackMoveSpan.className = 'clickable-move';
                    blackMoveSpan.dataset.moveIndex = moveIndex * 2 + 1;
                    
                    // Find the move data for annotations
                    const blackMoveData = game.moves_detailed.find(m => m.black === group.black && m.move_number == moveNumber);
                    if (blackMoveData) {
                        // Add annotation if it exists
                        if (blackMoveData.annotation) {
                            const annotationSpan = document.createElement('span');
                            annotationSpan.textContent = blackMoveData.annotation;
                            annotationSpan.className = 'move-annotation';
                            annotationSpan.style.marginLeft = '4px';
                            annotationSpan.style.color = '#000000';
                            blackMoveSpan.appendChild(annotationSpan);
                        }
                        
                    }
                    
                    blackMoves.appendChild(blackMoveSpan);
                }
                
                // Add click listener to entire black-moves div
                blackMoves.addEventListener('click', function() {
                    if (group.black) {
                        currentMoveIndex = moveIndex * 2 + 2;
                        updateBoardPosition();
                        updateMoveButtons();
                        
                        // Unclick hint button when clicking on moves
                        unclickHintButton();
                        
                        // Update hint button visibility
                        updateHintButtonVisibility();
                        
                        // Show green check indicator when on the last move (for all modes except test mode)
                        if (currentMoveIndex >= game.moves_detailed.length) {
                            removeLastMoveCheck();
                            setTimeout(() => {
                                showLastMoveCheck();
                            }, 50);
                        }
                        
                        // Check if this is the final move and trigger completion indicator (only in test mode)
                        if (isChallengeMode && currentMoveIndex >= game.moves_detailed.length) {
                            setTimeout(() => {
                                showCompletionIndicator();
                            }, 200);
                        }
                        
                        // Remove highlight from all moves and sections
                        moveItem.querySelectorAll('.clickable-move').forEach(span => {
                            span.classList.remove('active-move');
                        });
                        moveItem.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                            section.classList.remove('clicked');
                        });
                        // Highlight current move and section
                        if (group.black) {
                            blackMoves.querySelector('.clickable-move').classList.add('active-move');
                        }
                        blackMoves.classList.add('clicked');
                        
                        // Show commentary if available
                        const blackMoveData = game.moves_detailed.find(m => m.black === group.black && m.move_number == moveNumber);
                        if (blackMoveData) {
                            showMoveCommentary(blackMoveData.description, group.black, blackMoveData);
                        }
                        
                        // Check if we should autoplay the next move after clicking a move
                        const selectedColor = window.selectedPlayColor || 'both';
                        if (selectedColor !== 'both' && currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                            const nextMove = currentGame.moves_detailed[currentMoveIndex];
                            const isNextWhiteMove = !!nextMove.white;
                            const shouldAutoplayNext = (selectedColor === 'white' && !isNextWhiteMove) || 
                                                     (selectedColor === 'black' && isNextWhiteMove);
                            
                            console.log('Move clicked - checking autoplay:', {
                                selectedColor,
                                currentMoveIndex,
                                nextMove: nextMove.white || nextMove.black,
                                isNextWhiteMove,
                                shouldAutoplayNext
                            });
                            
                            if (shouldAutoplayNext) {
                                console.log('Auto-playing next move after move click');
                                setTimeout(() => {
                                    goToNextMove();
                                }, 300); // Short delay after move click
                            }
                        }
                    }
                });
                
                // Add moves to row
                moveRow.appendChild(whiteMoves);
                moveRow.appendChild(blackMoves);
                moveItem.appendChild(moveRow);
            });
            
            movesList.appendChild(moveItem);
            
            // Add result notation if the game ends in checkmate
            if (game.result && (game.result.includes('wins') || game.result.includes('White wins') || game.result.includes('Black wins'))) {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'game-result';
                resultDiv.style.cssText = 'text-align: center; font-weight: bold; font-size: 16px; margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px; border: 2px solid #dee2e6;';
                
                // Determine the result notation
                let resultNotation = '';
                if (game.result.includes('White wins')) {
                    resultNotation = '1-0';
                } else if (game.result.includes('Black wins')) {
                    resultNotation = '0-1';
                }
                
                if (resultNotation) {
                    resultDiv.textContent = resultNotation;
                    movesList.appendChild(resultDiv);
                }
            }

        }

        // Function to attach event listeners for game header dropdown
        function attachGameHeaderEventListeners() {
            const gameHeader = document.getElementById('game-header');
            const gameDetails = document.getElementById('game-details');
            
            if (gameHeader && gameDetails) {
                // Remove any existing event listeners by cloning the element
                const newGameHeader = gameHeader.cloneNode(true);
                gameHeader.parentNode.replaceChild(newGameHeader, gameHeader);
                
                // Re-attach the event listener
                newGameHeader.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Game header clicked');
                    newGameHeader.classList.toggle('expanded');
                    gameDetails.classList.toggle('show');
                });
                
                console.log('Game header event listeners attached');
            } else {
                console.log('Game header or game details not found');
            }
        }

        // Function to restore main game event listeners
        function restoreMainGameEventListeners() {
            console.log('=== RESTORING MAIN GAME EVENT LISTENERS ===');
            const pieces = document.querySelectorAll('.piece');
            console.log('Found pieces:', pieces.length);
            pieces.forEach((piece, index) => {
                console.log(`Piece ${index}:`, piece);
                // Remove custom game event listeners
                piece.removeEventListener('click', handleCustomPieceClick);
                piece.removeEventListener('dragstart', handleCustomDragStart);
                piece.removeEventListener('dragend', handleCustomDragEnd);
                
                // Restore main game event listeners
                piece.addEventListener('dragstart', handleDragStart);
                piece.addEventListener('dragend', handleDragEnd);
                piece.addEventListener('click', handlePieceClick);
                console.log(`Restored event listeners for piece ${index}`);
            });
        }

        // Function to completely exit custom game mode
        function exitCustomGameMode() {
            // Reset custom game variables
            if (typeof customGameMode !== 'undefined') {
                customGameMode = false;
                window.customGameMode = false;
            }
            
            // Clear custom game elements
            clearCustomGameElements();
            
            // Hide custom game info section
            if (typeof hideCustomGameInfo === 'function') {
                hideCustomGameInfo();
            }
            
            // Hide custom save button
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            
            // Hide custom commentary section
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            
            // Hide custom save message
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }
            
            // Restore main game event listeners
            restoreMainGameEventListeners();
        }

        // Display selected game
        function displayGame(gameId) {
            console.log('Displaying game:', gameId);
            console.log('Games data:', gamesData);
            
            // Always exit custom game mode when displaying any game
            exitCustomGameMode();
            
            // Exit test mode if switching to a different game
            if (isChallengeMode && currentGame && currentGame.id !== gameId) {
                toggleChallengeMode();
            }
            
            if (!gamesData) {
                console.error('No games data available');
                return;
            }
            
            const game = gamesData.games.find(g => g.id === gameId);
            console.log('Found game:', game);
            
            if (!game) {
                console.error('Game not found:', gameId);
                return;
            }

            // Set current game and reset move index
            currentGame = game;
            // Check if game has a custom initial move index, otherwise start at 0
            currentMoveIndex = game.initial_move_index || 0;
            
            // Update hint button visibility
            updateHintButtonVisibility();
            
            // Start training session tracking based on type
            const sessionType = 'game';
            progressTracker.startSession(sessionType);
            
            // Update selected state for game buttons
            document.querySelectorAll('.submenu-button').forEach(btn => {
                btn.classList.remove('selected');
            });
            const selectedButton = document.querySelector(`[data-game-id="${gameId}"]`);
            if (selectedButton) {
                selectedButton.classList.add('selected');
            }
            
            // Reset board orientation to standard (white at bottom) first
            if (boardFlipped) {
                boardFlipped = false;
                const flipBtn = document.getElementById('flip-board-btn');
                flipBtn.classList.remove('flipped');
                flipNotation();
                initializeChessBoard();
            }
            
            // Reset the board to starting position
            resetBoard();
            
            // Clear any piece selection
            clearSelection();
            
            // Reset to normal visual mode when switching games
            currentVisualMode = 'normal';
            switchVisualMode('normal');

            // Show game display
            const gameDisplay = document.getElementById('game-display');
            gameDisplay.classList.add('show');

            // Show and update game header in moves panel
            const gameHeader = document.getElementById('game-header');
            gameHeader.style.display = 'block';
            document.getElementById('game-title-line').innerHTML = `<span>${game.name}</span>`;
            
            // Event listeners are handled via delegation, no need to reattach

            // Show moves toggle
            const movesToggle = document.getElementById('moves-toggle');
            movesToggle.style.display = 'block';

            // Show play color selection
            const playColorSection = document.getElementById('play-color-section');
            if (playColorSection) {
                playColorSection.style.display = 'block';
                
                // Reset play color selection to "Both"
                const bothRadio = playColorSection.querySelector('input[value="both"]');
                const whiteRadio = playColorSection.querySelector('input[value="white"]');
                const blackRadio = playColorSection.querySelector('input[value="black"]');
                
                if (bothRadio) bothRadio.checked = true;
                if (whiteRadio) whiteRadio.checked = false;
                if (blackRadio) blackRadio.checked = false;
                
                // Reset selected play color
                window.selectedPlayColor = 'both';
                
                // Remove existing event listeners first to avoid duplicates
                const radioButtons = playColorSection.querySelectorAll('input[type="radio"]');
                radioButtons.forEach(radio => {
                    // Clone the radio button to remove all event listeners
                    const newRadio = radio.cloneNode(true);
                    radio.parentNode.replaceChild(newRadio, radio);
                });
                
                // Get the new radio buttons after cloning
                const newRadioButtons = playColorSection.querySelectorAll('input[type="radio"]');
                newRadioButtons.forEach(radio => {
                    // Track when this radio becomes checked (from other radios)
                    radio.addEventListener('change', function() {
                        // This is handled in the autoplay functionality below
                    });
                });
                
                // Add autoplay functionality based on selected color
                newRadioButtons.forEach(radio => {
                    radio.addEventListener('change', function() {
                        if (this.checked) {
                            const selectedColor = this.value;
                            console.log('Play color changed to:', selectedColor);
                            
                            // Flip board based on selected color
                            if (currentGame) {
                                if (selectedColor === 'black' && !boardFlipped) {
                                    // Flip to black perspective
                                    flipBoard();
                                } else if (selectedColor === 'white' && boardFlipped) {
                                    // Flip to white perspective
                                    flipBoard();
                                }
                                
                                currentMoveIndex = currentGame.initial_move_index || 0;
                                updateMoveButtons();
                                highlightCurrentMove();
                                
                                // Reset board to initial position when switching play colors
                                resetBoard();
                                updateBoardPosition();
                                
                                // Display game moves
                                displayGameMoves(currentGame);
                            }
                            
            // Store the selected color for use in move navigation
            window.selectedPlayColor = selectedColor;
            
            // If a game is loaded and we're switching to autoplay mode, start autoplay
            if (currentGame && selectedColor !== 'both') {
                // Check if the first move should be autoplayed
                const firstMove = currentGame.moves_detailed[0];
                if (firstMove) {
                    const isWhiteMove = !!firstMove.white;
                    const shouldAutoplayFirst = (selectedColor === 'white' && !isWhiteMove) || 
                                             (selectedColor === 'black' && isWhiteMove);
                    
                    if (shouldAutoplayFirst) {
                        console.log('Starting autoplay from first move');
                        setTimeout(() => {
                            goToNextMove();
                        }, 500);
                    }
                }
            }
                        }
                    });
                });
            }

            // Show comment section for games with commentary
            const commentSection = document.getElementById('comment-section');
            if (commentSection) {
                if (game.id.startsWith('custom-game-')) {
                    // For custom games, show comment section if they have commentary
                    const hasCommentary = game.moves_detailed && game.moves_detailed.some(move => move.commentary && move.commentary.trim() !== '');
                    commentSection.style.display = hasCommentary ? 'block' : 'none';
                } else {
                    commentSection.style.display = 'block';
                }
            }
            
            // Handle custom game elements visibility
            if (game.id.startsWith('custom-game-')) {
                // Show custom game elements for custom games
                // Ensure moves list is visible for saved custom games
                const movesList = document.getElementById('moves-list');
                if (movesList) {
                    movesList.style.display = 'block';
                }
            } else {
                // Hide custom game elements for preprogrammed games
                if (typeof hideCustomGameInfo === 'function') {
                    hideCustomGameInfo();
                }
                if (typeof hideCustomSaveButton === 'function') {
                    hideCustomSaveButton();
                }
                if (typeof hideCustomCommentarySection === 'function') {
                    hideCustomCommentarySection();
                }
                if (typeof hideCustomSaveMessage === 'function') {
                    hideCustomSaveMessage();
                }
            }

            // Update completion badges to reflect current state
            updateGameListBadges();

            // Populate game details
            populateGameDetails(game);

            // Setup board and display moves
            setupInitialPosition();
            reinitializeDragAndDrop(); // Ensure click handlers are attached
            displayGameMoves(game);
            updateMoveButtons();
            
            // Check if we should start autoplay based on selected color
            const selectedColor = window.selectedPlayColor || 'both';
            if (selectedColor !== 'both' && game.moves_detailed.length > 0) {
                const firstMove = game.moves_detailed[0];
                const isWhiteMove = !!firstMove.white;
                const shouldAutoplayFirst = (selectedColor === 'white' && !isWhiteMove) || 
                                         (selectedColor === 'black' && isWhiteMove);
                
                if (shouldAutoplayFirst) {
                    console.log('Starting autoplay from first move on game load');
                    setTimeout(() => {
                        goToNextMove();
                    }, 1000); // Longer delay for initial load
                }
            }
            
            // If game has a custom initial move index, update board to that position
            if (game.initial_move_index && game.initial_move_index > 0) {
                updateBoardPosition();
            }
             highlightCurrentMove();
             
            // Show/hide delete button for custom games (only when viewing saved custom games, not in Add Game mode)
            const deleteGameSection = document.getElementById('delete-game-section');
            const deleteGameBtn = document.getElementById('delete-game-btn');
            if (game.id.startsWith('custom-game-') && !window.customGameMode) {
                deleteGameSection.style.display = 'block';
                // Use deleteCustomGameLocal to avoid confusion with window.deleteCustomGame
                deleteGameBtn.onclick = (e) => deleteCustomGameLocal(e, game.id);
                 
                 // Hide custom commentary section and save button when viewing saved custom games
                 if (typeof hideCustomCommentarySection === 'function') {
                     hideCustomCommentarySection();
                 }
                 if (typeof hideCustomSaveButton === 'function') {
                     hideCustomSaveButton();
                 }
             } else {
                 deleteGameSection.style.display = 'none';
             }
             
             // Update game list badges
             updateGameListBadges();
             
             // Visual mode placeholder - no effects applied yet
        }

        // Populate game details
        function populateGameDetails(game) {
            document.getElementById('detail-description').textContent = game.description;
            document.getElementById('detail-moves').textContent = `${game.moves} moves`;
            document.getElementById('detail-white').textContent = game.white_player;
            document.getElementById('detail-black').textContent = game.black_player;
            document.getElementById('detail-opening').textContent = game.opening;
            document.getElementById('detail-difficulty').textContent = game.difficulty;
            
            // Use facts from JSON data (single source of truth)
            const facts = game.facts || 'No interesting facts available for this game.';
            document.getElementById('detail-facts').textContent = facts;
        }

        // Toggle moves visibility
        function toggleMovesVisibility() {
            const movesList = document.getElementById('moves-list');
            const commentSection = document.getElementById('comment-section');
            const toggleImg = document.getElementById('moves-toggle-img');
            
            if (movesList.style.display === 'none') {
                movesList.style.display = 'block';
                // Show comment section for games with commentary
                if (currentGame) {
                    if (currentGame.id.startsWith('custom-game-')) {
                        // For custom games, show comment section if they have commentary
                        const hasCommentary = currentGame.moves_detailed && currentGame.moves_detailed.some(move => move.commentary && move.commentary.trim() !== '');
                        commentSection.style.display = hasCommentary ? 'block' : 'none';
                    } else {
                        commentSection.style.display = 'block';
                    }
                }
                toggleImg.src = 'images/hide.png';
            } else {
                movesList.style.display = 'none';
                commentSection.style.display = 'none';
                toggleImg.src = 'images/view.png';
            }
        }

        // Create confetti effect
        function createConfetti() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.position = 'fixed';
                confetti.style.width = '10px';
                confetti.style.height = '10px';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.top = '-10px';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.zIndex = '9999';
                confetti.style.pointerEvents = 'none';
                confetti.style.animation = 'confetti-fall 3s linear forwards';
                confetti.style.animationDelay = Math.random() * 2 + 's';
                
                document.body.appendChild(confetti);
                
                // Remove confetti after animation
                setTimeout(() => {
                    if (confetti.parentNode) {
                        confetti.parentNode.removeChild(confetti);
                    }
                }, 5000);
            }
        }

        // Show completion indicator on the piece that made the final move
        function showCompletionIndicator() {
            if (!currentGame || currentMoveIndex < currentGame.moves_detailed.length) return;
            
            // Get the last move to find which piece moved
            const lastMove = currentGame.moves_detailed[currentGame.moves_detailed.length - 1];
            const moveNotation = lastMove.white || lastMove.black;
            const isWhiteMove = !!lastMove.white;
            
            // Parse the move to get the destination square
            const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
            if (parsedMove) {
                const destinationSquare = document.querySelector(`[data-square="${parsedMove.target}"]`);
                if (destinationSquare) {
                    // Remove any existing completion indicator
                    const existingIndicator = document.querySelector('.completion-indicator');
                    if (existingIndicator) {
                        existingIndicator.remove();
                    }
                    
                    // Create new completion indicator
                    const indicator = document.createElement('div');
                    indicator.className = 'completion-indicator';
                    indicator.innerHTML = 'âœ“';
                    indicator.title = 'Game completed!';
                    
                    // Make sure the square has relative positioning
                    destinationSquare.style.position = 'relative';
                    
                    // Add the indicator to the destination square
                    destinationSquare.appendChild(indicator);
                }
            }
        }

        // Remove completion indicator
        function removeCompletionIndicator() {
            const existingIndicator = document.querySelector('.completion-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
        }

        // Show green check indicator when the last move is completed (for all modes except test mode)
        function showLastMoveCheck() {
            // Don't show check in test mode
            if (isChallengeMode) return;
            
            // Only show when on the last move
            if (!currentGame || currentMoveIndex < currentGame.moves_detailed.length) return;
            
            // Get the last move to find which piece moved
            const lastMove = currentGame.moves_detailed[currentGame.moves_detailed.length - 1];
            const moveNotation = lastMove.white || lastMove.black;
            const isWhiteMove = !!lastMove.white;
            
            // Parse the move to get the destination square
            const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
            if (parsedMove) {
                const destinationSquare = document.querySelector(`[data-square="${parsedMove.target}"]`);
                if (destinationSquare) {
                    // Remove any existing check indicator
                    const existingCheck = document.querySelector('.last-move-check');
                    if (existingCheck) {
                        existingCheck.remove();
                    }
                    
                    // Create new check indicator with the green check image
                    const checkIndicator = document.createElement('div');
                    checkIndicator.className = 'last-move-check';
                    checkIndicator.style.position = 'absolute';
                    checkIndicator.style.top = '2px';
                    checkIndicator.style.right = '2px';
                    checkIndicator.style.width = '20px';
                    checkIndicator.style.height = '20px';
                    checkIndicator.style.backgroundImage = 'url(images/checked.png)';
                    checkIndicator.style.backgroundSize = 'contain';
                    checkIndicator.style.backgroundRepeat = 'no-repeat';
                    checkIndicator.style.backgroundPosition = 'center';
                    checkIndicator.style.pointerEvents = 'none';
                    checkIndicator.style.zIndex = '9999';
                    checkIndicator.title = 'Final move completed!';
                    
                    // Make sure the square has relative positioning
                    destinationSquare.style.position = 'relative';
                    
                    // Add the indicator to the destination square
                    destinationSquare.appendChild(checkIndicator);
                }
            }
        }

        // Remove last move check indicator
        function removeLastMoveCheck() {
            const existingCheck = document.querySelector('.last-move-check');
            if (existingCheck) {
                existingCheck.remove();
            }
        }

        // Update hint button visibility
        function updateHintButtonVisibility() {
            const hintBtn = document.getElementById('hint-btn');
            if (!hintBtn) return;
            
            // Show hint button only if game is loaded, not in test mode, and not on the last move
            if (currentGame && !isChallengeMode && currentMoveIndex < currentGame.moves_detailed.length) {
                hintBtn.style.display = 'block';
            } else {
                hintBtn.style.display = 'none';
                // Clear any active state
                hintBtn.classList.remove('active');
                clearHighlights();
            }
        }

        // Unclick hint button after a move
        function unclickHintButton() {
            const hintBtn = document.getElementById('hint-btn');
            if (hintBtn) {
                hintBtn.classList.remove('active');
                clearHighlights();
            }
        }

        // Show hint for the next move
        function showHint() {
            const hintBtn = document.getElementById('hint-btn');
            
            if (!currentGame || currentMoveIndex >= currentGame.moves_detailed.length) {
                console.log('No hint available - game finished or no current game');
                return;
            }
            
            // Toggle active state
            if (hintBtn.classList.contains('active')) {
                // Clear hint
                clearHighlights();
                hintBtn.classList.remove('active');
            } else {
                // Show hint
                // Get the next move
                const nextMove = currentGame.moves_detailed[currentMoveIndex];
                const moveNotation = nextMove.white || nextMove.black;
                const isWhiteMove = !!nextMove.white;
                
                // Parse the move to get the source square
                const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
                if (parsedMove && parsedMove.source) {
                    const sourceSquare = document.querySelector(`[data-square="${parsedMove.source}"]`);
                    if (sourceSquare) {
                        // Clear any existing valid-move highlights
                        clearHighlights();
                        
                        // Add valid-move class to the source square to highlight it
                        sourceSquare.classList.add('valid-move');
                        hintBtn.classList.add('active');
                        
                        console.log('Showing hint - highlighting source square:', parsedMove.source);
                    } else {
                        console.log('Source square not found:', parsedMove.source);
                    }
                } else {
                    console.log('Failed to parse next move for hint');
                }
            }
        }

        // Convert chess piece letters to symbols
        function convertToChessSymbols(notation) {
            if (!notation) return notation;
            
            return notation
                .replace(/K/g, 'â™”')  // King
                .replace(/Q/g, 'â™•')  // Queen
                .replace(/R/g, 'â™–')  // Rook
                .replace(/B/g, 'â™—')  // Bishop
                .replace(/N/g, 'â™˜')  // Knight
                .replace(/P/g, 'â™™')  // Pawn
                .replace(/k/g, 'â™š')  // Black King
                .replace(/q/g, 'â™›')  // Black Queen
                .replace(/r/g, 'â™œ')  // Black Rook
                .replace(/b/g, 'â™')  // Black Bishop
                .replace(/n/g, 'â™ž')  // Black Knight
                .replace(/p/g, 'â™Ÿ')  // Black Pawn
                .replace(/x/g, 'Ã—')  // Capture symbol
                .replace(/\+/g, '+')  // Check symbol
                .replace(/#/g, '#');  // Checkmate symbol
        }

        // Add click event listener to moves toggle image
        document.addEventListener('DOMContentLoaded', function() {
            const toggleImg = document.getElementById('moves-toggle-img');
            if (toggleImg) {
                toggleImg.addEventListener('click', toggleMovesVisibility);
            }

        });

        // Function to highlight the current move in the moves list
        function highlightCurrentMove() {
            if (!currentGame) return;
            
            // Use setTimeout to ensure this runs after DOM updates
            setTimeout(() => {
                // Remove all existing highlights
                document.querySelectorAll('.clickable-move').forEach(span => {
                    span.classList.remove('active-move');
                });
                document.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                    section.classList.remove('clicked');
                });
                
                // If at initial position, don't highlight anything
                if (currentMoveIndex === 0) return;
                
                // Calculate which move to highlight
                const moveNumber = Math.ceil(currentMoveIndex / 2);
                const isWhiteMove = currentMoveIndex % 2 === 1;
                
                // Find all move rows
                const moveRows = document.querySelectorAll('.move-row');
                
                // Find the target move row (0-based indexing)
                const targetMoveRow = moveRows[moveNumber - 1];
                if (!targetMoveRow) return;
                
                let highlightedElement = null;
                
                // Highlight the appropriate move
                if (isWhiteMove) {
                    const whiteMoves = targetMoveRow.querySelector('.white-moves');
                    if (whiteMoves) {
                        const clickableMove = whiteMoves.querySelector('.clickable-move');
                        if (clickableMove) {
                            clickableMove.classList.add('active-move');
                        }
                        whiteMoves.classList.add('clicked');
                        highlightedElement = whiteMoves;
                    }
                } else {
                    const blackMoves = targetMoveRow.querySelector('.black-moves');
                    if (blackMoves) {
                        const clickableMove = blackMoves.querySelector('.clickable-move');
                        if (clickableMove) {
                            clickableMove.classList.add('active-move');
                        }
                        blackMoves.classList.add('clicked');
                        highlightedElement = blackMoves;
                    }
                }
                
                // Auto-scroll the highlighted move into view
                if (highlightedElement) {
                    // Use a slight delay to ensure highlighting is complete
                    setTimeout(() => {
                        highlightedElement.scrollIntoView({
                            behavior: 'smooth',
                            block: 'nearest',
                            inline: 'nearest'
                        });
                    }, 50);
                }
            }, 10);
        }

        // Move navigation functions
        function goToInitialPosition() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToFirstCustomMove();
                return;
            }
            
            clearSelection();
            currentMoveIndex = 0;
            
            // Reset the move parser's position tracking
            moveParser.resetBoard();
            
            setupInitialPosition();
            updateMoveButtons();
            highlightCurrentMove();
            
            // Remove completion and check indicators when going to initial position
            removeCompletionIndicator();
            removeLastMoveCheck();
            
            // Unclick hint button when going to initial position
            unclickHintButton();
            
            // Clear comment section at initial position
            const commentContent = document.getElementById('comment-content');
            const commentSection = document.getElementById('comment-section');
            if (commentContent) {
                commentContent.innerHTML = 'Click on any move to see detailed commentary';
            }
            // Hide comment section at initial position
            if (commentSection) {
                commentSection.style.display = 'none';
            }
            
            // Play sound for user feedback
            playSound(false);
        }

        function goToPreviousMove() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToPreviousCustomMove();
                return;
            }
            
            if (currentMoveIndex > 0) {
                clearSelection();
                currentMoveIndex--;
                updateBoardPosition();
                updateMoveButtons();
                highlightCurrentMove();
                
                // Remove completion and check indicators when moving away from final position
                removeCompletionIndicator();
                removeLastMoveCheck();
                
                // Unclick hint button when navigating moves
                unclickHintButton();
                
                // Update hint button visibility
                updateHintButtonVisibility();
                
                // Update comment section with current move info only if moves are visible
                const movesList = document.getElementById('moves-list');
                if (movesList.style.display !== 'none') {
                    if (currentMoveIndex === 0) {
                        // Clear comment section if at initial position
                        const commentContent = document.getElementById('comment-content');
                        if (commentContent) {
                            commentContent.innerHTML = 'Click on any move to see detailed commentary';
                        }
                    } else if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                        // Show commentary for the move we just went back to
                        const move = currentGame.moves_detailed[currentMoveIndex - 1];
                        const moveNotation = move.white || move.black;
                        showMoveCommentary(move.description, moveNotation, move);
                    }
                }
            }
        }

        function goToNextMove() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToNextCustomMove();
                return;
            }
            
            console.log('goToNextMove called - currentMoveIndex:', currentMoveIndex, 'total moves:', currentGame ? currentGame.moves_detailed.length : 'no game');
            
            if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                // Check if we should autoplay this move
                const move = currentGame.moves_detailed[currentMoveIndex];
                const isWhiteMove = !!move.white;
                const selectedColor = window.selectedPlayColor || 'both';
                
                console.log('Move analysis - isWhiteMove:', isWhiteMove, 'selectedColor:', selectedColor);
                
                // Determine if this move should be autoplayed
                let shouldAutoplay = false;
                if (selectedColor === 'white' && !isWhiteMove) {
                    // Playing as white, autoplay black moves
                    shouldAutoplay = true;
                } else if (selectedColor === 'black' && isWhiteMove) {
                    // Playing as black, autoplay white moves
                    shouldAutoplay = true;
                } else if (selectedColor === 'both') {
                    // Playing as both, no autoplay
                    shouldAutoplay = false;
                }
                
                console.log('Should autoplay:', shouldAutoplay);
                
                if (shouldAutoplay) {
                    // Autoplay this move (opponent's move)
                    executeMove();
                    return;
                } else {
                    // Normal move execution for player moves
                    executeMove();
                    
                    // After executing a player move, check if the next move should autoplay
                    const selectedColor = window.selectedPlayColor || 'both';
                    if (selectedColor !== 'both' && currentMoveIndex < currentGame.moves_detailed.length) {
                        const nextMove = currentGame.moves_detailed[currentMoveIndex];
                        const isNextWhiteMove = !!nextMove.white;
                        const shouldAutoplayNext = (selectedColor === 'white' && !isNextWhiteMove) || 
                                                 (selectedColor === 'black' && isNextWhiteMove);
                        
                        if (shouldAutoplayNext) {
                            console.log('Auto-playing next move after player move');
                            setTimeout(() => {
                                goToNextMove();
                            }, 300); // Short delay after player move
                        }
                    }
                }
            } else {
                // Game completed - show completion badge (only in test mode)
                if (isChallengeMode && currentGame && currentMoveIndex >= currentGame.moves_detailed.length) {
                    console.log('Game completed! Showing completion badge');
                    showCompletionBadge();
                }
            }
        }
        
        function executeMove() {
            if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                clearSelection();
                const move = currentGame.moves_detailed[currentMoveIndex];
                const moveNotation = move.white || move.black;
                const isWhiteMove = !!move.white;
                
                console.log('Move data:', move);
                console.log('Move notation:', moveNotation);
                console.log('Is white move:', isWhiteMove);
                
                // Use JSON coordinates if available, otherwise parse the move notation
                let sourceSquare, destinationSquare, pieceImage;
                
                if (move.white_from && move.white_to) {
                    // Use coordinates from JSON for white moves
                    sourceSquare = getSquareByNotation(move.white_from);
                    destinationSquare = getSquareByNotation(move.white_to);
                    
                    // Extract piece type from notation - handle different formats
                    let piece = 'P'; // Default to pawn
                    if (moveNotation.length > 0) {
                        const firstChar = moveNotation.charAt(0).toUpperCase();
                        if (['K', 'Q', 'R', 'B', 'N'].includes(firstChar)) {
                            piece = firstChar;
                        }
                    }
                    console.log('White move - piece from notation:', piece, 'notation:', moveNotation);
                    pieceImage = moveParser.getPieceImage(piece, isWhiteMove);
                } else if (move.black_from && move.black_to) {
                    // Use coordinates from JSON for black moves
                    sourceSquare = getSquareByNotation(move.black_from);
                    destinationSquare = getSquareByNotation(move.black_to);
                    
                    // Extract piece type from notation - handle different formats
                    let piece = 'P'; // Default to pawn
                    if (moveNotation.length > 0) {
                        const firstChar = moveNotation.charAt(0).toUpperCase();
                        if (['K', 'Q', 'R', 'B', 'N'].includes(firstChar)) {
                            piece = firstChar;
                        }
                    }
                    console.log('Black move - piece from notation:', piece, 'notation:', moveNotation);
                    pieceImage = moveParser.getPieceImage(piece, isWhiteMove);
                } else {
                    // Fallback to parsing move notation
                    const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
                    console.log('Parsed move:', parsedMove);
                    pieceImage = moveParser.getPieceImage(parsedMove.piece, isWhiteMove);
                    sourceSquare = getSquareByNotation(parsedMove.source);
                    destinationSquare = getSquareByNotation(parsedMove.target);
                }
                
                console.log('Using coordinates:', { source: move.white_from || move.black_from, target: move.white_to || move.black_to });
                
                if (moveNotation.includes('O-O')) {
                    // Handle castling
                    const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
                    applyCastling(parsedMove, true, true);
                } else if (sourceSquare && destinationSquare && pieceImage) {
                    // Handle en passant capture - check both saved data and parsed move
                    const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
                    const isEnPassant = (move.isEnPassant && move.enPassantCapturedSquare) || parsedMove.isEnPassant;
                    let enPassantCapturedSquare = move.enPassantCapturedSquare;
                    
                    // If parsed move detected en passant but we don't have the captured square, calculate it
                    if (parsedMove.isEnPassant && !enPassantCapturedSquare) {
                        // For en passant, the captured pawn is on the same file as target, one rank back
                        const targetFile = parsedMove.target[0];
                        const targetRank = parseInt(parsedMove.target[1]);
                        const capturedRank = isWhiteMove ? targetRank - 1 : targetRank + 1;
                        enPassantCapturedSquare = targetFile + capturedRank;
                        console.log('executeMove: Calculated en passant captured square:', enPassantCapturedSquare);
                    }
                    
                    // Remove the captured pawn from parser's tracking BEFORE moving the piece
                    if (isEnPassant && enPassantCapturedSquare) {
                        const capturedIsWhite = !isWhiteMove;
                        if (typeof moveParser.removePiece === 'function') {
                            moveParser.removePiece('P', enPassantCapturedSquare, capturedIsWhite);
                            console.log('executeMove: Removed captured pawn from parser tracking:', enPassantCapturedSquare);
                        }
                    }
                    
                    // Use the proper animation for existing pieces
                    animateExistingPiece(sourceSquare, destinationSquare, pieceImage);
                    
                    // Remove the captured pawn from DOM after animation completes
                    if (isEnPassant && enPassantCapturedSquare) {
                        setTimeout(() => {
                            const enPassantSquareElement = document.querySelector(`[data-square="${enPassantCapturedSquare}"]`);
                            if (enPassantSquareElement) {
                                enPassantSquareElement.innerHTML = '';
                                console.log('executeMove: Removed en passant captured pawn from DOM:', enPassantCapturedSquare);
                            }
                        }, 350); // Wait for animation to complete
                    }
                    
                    // Update piece positions in the parser - use the piece from notation
                    const piece = moveNotation.charAt(0).toUpperCase();
                    const sourceNotation = move.white_from || move.black_from;
                    const targetNotation = move.white_to || move.black_to;
                    moveParser.updatePiecePosition(piece, sourceNotation, targetNotation, isWhiteMove);
                }
                    
                    currentMoveIndex++;
                    updateMoveButtons();
                    highlightCurrentMove();
                    
                    // Unclick hint button after move
                    unclickHintButton();
                    
                    // Update hint button visibility (hide if on last move)
                    updateHintButtonVisibility();
                    
                    // Call updateBoardPosition to ensure check indicator is properly displayed
                    // Use longer delay (400ms) to ensure animation completes before showing check indicator
                    if (currentMoveIndex >= currentGame.moves_detailed.length) {
                        setTimeout(() => {
                            removeLastMoveCheck();
                            showLastMoveCheck();
                        }, 400);
                    }
                    
                    // Check if this is the final move and trigger completion indicator after animation (only in test mode)
                    if (isChallengeMode && currentMoveIndex >= currentGame.moves_detailed.length) {
                        console.log('Game completed! Showing completion badge');
                        showCompletionBadge();
                        // Wait for animation to complete (300ms + buffer)
                        setTimeout(() => {
                            showCompletionIndicator();
                        }, 400);
                    }
                    
                    // Update challenge progress in test mode
                    if (isChallengeMode) {
                        checkChallengeProgress();
                    }
                    
                    // Update comment section with current move info only if moves are visible
                    const movesList = document.getElementById('moves-list');
                    if (move && movesList.style.display !== 'none') {
                        showMoveCommentary(move.description, moveNotation, move);
                }
            }
        }

        function goToFinalPosition() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToLastCustomMove();
                return;
            }
            
            if (currentGame) {
                clearSelection();
                currentMoveIndex = currentGame.moves_detailed.length;
                updateBoardPosition();
                updateMoveButtons();
                highlightCurrentMove();
                
                // Unclick hint button when going to final position
                unclickHintButton();
                
                // Hide hint button when going to final position
                const hintBtn = document.getElementById('hint-btn');
                if (hintBtn) {
                    hintBtn.style.display = 'none';
                }
                
                // Show green check indicator when jumping to final position (for all modes except test mode)
                removeLastMoveCheck();
                setTimeout(() => {
                    showLastMoveCheck();
                }, 50);
                
                // Trigger completion indicator for reaching final position (only in test mode)
                if (isChallengeMode) {
                    setTimeout(() => {
                        showCompletionIndicator();
                    }, 200);
                }
                
                // Update comment section with the last move info only if moves are visible
                const movesList = document.getElementById('moves-list');
                if (movesList.style.display !== 'none' && currentGame.moves_detailed.length > 0) {
                    const lastMove = currentGame.moves_detailed[currentGame.moves_detailed.length - 1];
                    const moveNotation = lastMove.white || lastMove.black;
                    showMoveCommentary(lastMove.commentary, moveNotation, lastMove);
                }
            }
        }

        function updateBoardPosition() {
            if (!currentGame) return;
            
            console.log('Updating board position to move index:', currentMoveIndex);
            
            // Store completion indicator state before clearing
            const wasAtFinalPosition = currentMoveIndex >= currentGame.moves_detailed.length;
            
            // Clear the board completely
            const board = document.getElementById('chess-board');
            const squares = board.querySelectorAll('.chess-square');
            squares.forEach(square => {
                square.innerHTML = '';
            });

            // Reset the move parser's position tracking
            moveParser.resetBoard();

            // Set up initial position
            setupInitialPosition();

            // Apply moves up to current position
            const enPassantCaptures = []; // Track en passant captures to clean up after all moves
            for (let i = 0; i < currentMoveIndex && i < currentGame.moves_detailed.length; i++) {
                const move = currentGame.moves_detailed[i];
                console.log(`Applying move ${i + 1}:`, move.white || move.black);
                applyMove(move, false, false);
                
                // Track en passant captures for final cleanup
                if (move.isEnPassant && move.enPassantCapturedSquare) {
                    enPassantCaptures.push(move.enPassantCapturedSquare);
                }
            }
            
            // Final cleanup: Ensure all en passant captured pawns are removed
            // This is a safeguard in case something restored them during move application
            enPassantCaptures.forEach(capturedSquare => {
                const enPassantSquareElement = document.querySelector(`[data-square="${capturedSquare}"]`);
                if (enPassantSquareElement && enPassantSquareElement.innerHTML.trim() !== '') {
                    // Check if there's actually a piece there (might be the capturing pawn on the target square)
                    const piece = enPassantSquareElement.querySelector('.chess-piece, .piece');
                    if (piece) {
                        // Only remove if it's a pawn (en passant only captures pawns)
                        const pieceImg = piece.querySelector('img');
                        if (pieceImg && (pieceImg.src.includes('pdt45') || pieceImg.src.includes('plt45'))) {
                            // Double-check: this should be the captured square, not the target square
                            // For en passant, the captured pawn is on a different square than the target
                            const isOnCapturedSquare = piece.dataset.square === capturedSquare || 
                                                       enPassantSquareElement.dataset.square === capturedSquare;
                            if (isOnCapturedSquare) {
                                enPassantSquareElement.innerHTML = '';
                                console.log('Final cleanup: Removed en passant captured pawn from', capturedSquare);
                            }
                        }
                    }
                }
            });
            
            // Play sound only for the current (last applied) move
            if (currentMoveIndex > 0 && currentMoveIndex <= currentGame.moves_detailed.length) {
                const lastMove = currentGame.moves_detailed[currentMoveIndex - 1];
                if (lastMove) {
                    // Check if it's a capture by looking for 'x' in the move notation
                    const moveNotation = lastMove.white || lastMove.black;
                    const isCapture = moveNotation && moveNotation.includes('x');
                    playSound(isCapture);
                }
            }

            // Re-initialize drag and drop for all pieces
            reinitializeDragAndDrop();
            
            // Final cleanup AFTER reinitializeDragAndDrop: Ensure all en passant captured pawns are removed
            // This is critical because reinitializeDragAndDrop might restore pieces
            enPassantCaptures.forEach(capturedSquare => {
                const enPassantSquareElement = document.querySelector(`[data-square="${capturedSquare}"]`);
                if (enPassantSquareElement) {
                    const piece = enPassantSquareElement.querySelector('.chess-piece, .piece');
                    if (piece) {
                        // Remove the piece - it should have been captured
                        enPassantSquareElement.innerHTML = '';
                        console.log('Post-reinitialize cleanup: Removed en passant captured pawn from', capturedSquare);
                    }
                }
            });
            
            // Make pieces invisible if in test mode
            // This must happen after reinitializeDragAndDrop() to ensure pieces are found
            if (isChallengeMode) {
                const pieces = document.querySelectorAll('.chess-piece');
                pieces.forEach(piece => {
                    piece.style.opacity = '0';
                });
                console.log('Test mode: Made pieces invisible after updateBoardPosition');
            }
            
            // Update comment section with current move info
            if (currentMoveIndex > 0 && currentMoveIndex <= currentGame.moves_detailed.length) {
                const currentMove = currentGame.moves_detailed[currentMoveIndex - 1];
                const moveNotation = currentMove.white || currentMove.black;
                showMoveCommentary(currentMove.commentary, moveNotation, currentMove);
            } else if (currentMoveIndex === 0) {
                // Clear comment section at initial position
                const commentContent = document.getElementById('comment-content');
                if (commentContent) {
                    commentContent.innerHTML = 'Click on any move to see detailed commentary';
                }
            }
            
            // Update move highlighting
            highlightCurrentMove();
            
            // Show green check indicator if on the final position (for all modes except test mode)
            if (!isChallengeMode && currentMoveIndex >= currentGame.moves_detailed.length) {
                // Only add the check indicator if it doesn't already exist
                const existingCheck = document.querySelector('.last-move-check');
                if (!existingCheck) {
                    setTimeout(() => {
                        showLastMoveCheck();
                    }, 100);
                }
            } else {
                // Remove check indicator if not on final position
                removeLastMoveCheck();
            }
        }

        // Animate piece movement
        function animateMove(fromSquare, toSquare, pieceImage) {
            // Create a temporary piece for animation with exact same styling
            const tempPiece = document.createElement('div');
            tempPiece.className = 'chess-piece';
            tempPiece.style.backgroundImage = `url('pieces/${pieceImage}')`;
            tempPiece.style.backgroundSize = 'contain';
            tempPiece.style.backgroundRepeat = 'no-repeat';
            tempPiece.style.backgroundPosition = 'center';
            tempPiece.style.position = 'absolute';
            tempPiece.style.zIndex = '1000';
            tempPiece.style.pointerEvents = 'none';
            tempPiece.style.width = '60px';
            tempPiece.style.height = '60px';
            tempPiece.style.transition = 'all 0.3s ease-in-out';
            
            // Get the chess board container
            const board = document.getElementById('chess-board');
            const boardRect = board.getBoundingClientRect();
            
            // Get positions relative to the board
            const fromRect = fromSquare.getBoundingClientRect();
            const toRect = toSquare.getBoundingClientRect();
            
            // Position the temp piece at the source (relative to board)
            tempPiece.style.left = (fromRect.left - boardRect.left) + 'px';
            tempPiece.style.top = (fromRect.top - boardRect.top) + 'px';
            
            // Add to board with relative positioning
            board.style.position = 'relative';
            board.appendChild(tempPiece);
            
            // Animate to destination
            requestAnimationFrame(() => {
                tempPiece.style.left = (toRect.left - boardRect.left) + 'px';
                tempPiece.style.top = (toRect.top - boardRect.top) + 'px';
            });
            
            // Clean up after animation
            setTimeout(() => {
                if (tempPiece.parentNode) {
                    tempPiece.parentNode.removeChild(tempPiece);
                }
            }, 350);
        }

        function applyMove(move, animate = false, enableSound = true) {
            if (!move.white && !move.black) return;

            const moveNotation = move.white || move.black;
            const isWhiteMove = !!move.white;
            
            console.log('Applying move:', moveNotation, 'isWhite:', isWhiteMove);
            
            // Parse the move using the universal parser
            const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
            console.log('Parsed move:', parsedMove);
            
            if (parsedMove.isCastling) {
                applyCastling(parsedMove, animate, enableSound);
                } else {
                const pieceImage = moveParser.getPieceImage(parsedMove.piece, isWhiteMove);
                
                // Handle en passant capture - check both saved data and parsed move
                const isEnPassant = (move.isEnPassant && move.enPassantCapturedSquare) || parsedMove.isEnPassant;
                let enPassantCapturedSquare = move.enPassantCapturedSquare;
                
                // If parsed move detected en passant but we don't have the captured square, calculate it
                if (parsedMove.isEnPassant && !enPassantCapturedSquare) {
                    // For en passant, the captured pawn is on the same file as target, one rank back
                    const targetFile = parsedMove.target[0];
                    const targetRank = parseInt(parsedMove.target[1]);
                    const capturedRank = isWhiteMove ? targetRank - 1 : targetRank + 1;
                    enPassantCapturedSquare = targetFile + capturedRank;
                    console.log('Calculated en passant captured square:', enPassantCapturedSquare);
                }
                
                // Remove the captured pawn from parser's tracking BEFORE moving the piece
                if (isEnPassant && enPassantCapturedSquare) {
                    const capturedIsWhite = !isWhiteMove;
                    if (typeof moveParser.removePiece === 'function') {
                        moveParser.removePiece('P', enPassantCapturedSquare, capturedIsWhite);
                        console.log('En passant: Removed captured pawn from parser tracking:', enPassantCapturedSquare);
                    }
                }
                
                movePiece(parsedMove.source, parsedMove.target, pieceImage, animate, enableSound);
                
                // Remove the captured pawn from DOM immediately
                if (isEnPassant && enPassantCapturedSquare) {
                    // Remove immediately (synchronously) since movePiece is synchronous when animate=false
                    const enPassantSquareElement = document.querySelector(`[data-square="${enPassantCapturedSquare}"]`);
                    if (enPassantSquareElement) {
                        enPassantSquareElement.innerHTML = '';
                        console.log('En passant: Removed captured pawn from DOM:', enPassantCapturedSquare, 'when replaying move');
                    } else {
                        // If element not found immediately, try again after a short delay
                        setTimeout(() => {
                            const enPassantSquareElement = document.querySelector(`[data-square="${enPassantCapturedSquare}"]`);
                            if (enPassantSquareElement) {
                                enPassantSquareElement.innerHTML = '';
                                console.log('En passant: Removed captured pawn from DOM (delayed):', enPassantCapturedSquare);
                            }
                        }, animate ? 350 : 50);
                    }
                }
                
                // Update piece positions in the parser
                moveParser.updatePiecePosition(parsedMove.piece, parsedMove.source, parsedMove.target, isWhiteMove);
            }
        }
        
        function applyCastling(parsedMove, animate = false, enableSound = true) {
            const { source, target, isWhite, isLong } = parsedMove;
            
            // Move the king
            const kingImage = moveParser.getPieceImage('K', isWhite);
            movePiece(source, target, kingImage, animate, enableSound);
            
            // Move the rook
            const rookSource = isLong ? (isWhite ? 'a1' : 'a8') : (isWhite ? 'h1' : 'h8');
            const rookTarget = isLong ? (isWhite ? 'd1' : 'd8') : (isWhite ? 'f1' : 'f8');
            const rookImage = moveParser.getPieceImage('R', isWhite);
            movePiece(rookSource, rookTarget, rookImage, animate, enableSound);
            
            // Update piece positions
            moveParser.updatePiecePosition('K', source, target, isWhite);
            moveParser.updatePiecePosition('R', rookSource, rookTarget, isWhite);
        }

        function movePiece(from, to, piece, animate = false, enableSound = true) {
            // Start training timer on piece movement
            progressTracker.startTrainingTimer();
            
            const fromSquare = getSquareByNotation(from);
            const toSquare = getSquareByNotation(to);
            
            if (fromSquare && toSquare) {
                // Check if there's a piece being captured
                const isCapture = toSquare.innerHTML.trim() !== '';
                
                if (animate) {
                    // Animate the move
                    animateMove(fromSquare, toSquare, piece);
                    // Update the board after animation
                    setTimeout(() => {
                        // Ensure board is in dragging state to disable transitions
                        const board = document.getElementById('chess-board');
                        board.classList.add('dragging');
                        
                        fromSquare.innerHTML = '';
                        toSquare.innerHTML = ''; // Clear destination square
                        const pieceElement = createDraggablePiece(piece, to);
                        toSquare.appendChild(pieceElement);
                        
                        // Remove dragging class after a short delay to re-enable transitions
                        setTimeout(() => {
                            board.classList.remove('dragging');
                        }, 50);
                        
                        // Play sound after animation completes
                        if (enableSound) playSound(isCapture);
                    }, 300);
                } else {
                    // Ensure board is in dragging state to disable transitions
                    const board = document.getElementById('chess-board');
                    board.classList.add('dragging');
                    
                    // Direct move without animation
                    fromSquare.innerHTML = '';
                    toSquare.innerHTML = ''; // Clear destination square
                    const pieceElement = createDraggablePiece(piece, to);
                    toSquare.appendChild(pieceElement);
                    
                    // Remove dragging class after a short delay to re-enable transitions
                    setTimeout(() => {
                        board.classList.remove('dragging');
                    }, 50);
                    
                    // Play sound immediately
                    if (enableSound) playSound(isCapture);
                }
            }
        }

        function getSquareByNotation(notation) {
            const board = document.getElementById('chess-board');
            
            // Use data-square attribute to find the correct square
            // This works regardless of board orientation since squares are labeled correctly
            return board.querySelector(`[data-square="${notation}"]`);
        }

        function updateMoveButtons() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                updateCustomMoveButtons();
                return;
            }
            
            const btnInitial = document.getElementById('btn-initial');
            const btnBack = document.getElementById('btn-back');
            const btnForward = document.getElementById('btn-forward');
            const btnFinal = document.getElementById('btn-final');

            if (!currentGame) {
                btnInitial.classList.add('disabled');
                btnBack.classList.add('disabled');
                btnForward.classList.add('disabled');
                btnFinal.classList.add('disabled');
                return;
            }

            // Update disabled states
            if (currentMoveIndex === 0) {
                btnInitial.classList.add('disabled');
                btnBack.classList.add('disabled');
            } else {
                btnInitial.classList.remove('disabled');
                btnBack.classList.remove('disabled');
            }

            if (currentMoveIndex >= currentGame.moves_detailed.length) {
                btnForward.classList.add('disabled');
                btnFinal.classList.add('disabled');
            } else {
                btnForward.classList.remove('disabled');
                btnFinal.classList.remove('disabled');
            }
        }

        // Visual mode functions (placeholder - no functionality yet)
        function switchVisualMode(mode) {
            currentVisualMode = mode;
            
            // Update active option
            const options = document.querySelectorAll('.mode-option');
            options.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.mode === mode) {
                    option.classList.add('active');
                }
            });
            
            // Apply visual effects
            applyVisualMode(mode);
        }

        // Flip notation function
        function flipNotation() {
            // Flip the letters (a-h)
            const letters = document.querySelectorAll('.notation-letter');
            const letterTexts = Array.from(letters).map(letter => letter.textContent);
            const reversedLetters = letterTexts.reverse();
            
            letters.forEach((letter, index) => {
                letter.textContent = reversedLetters[index];
            });
            
            // Flip the numbers (1-8)
            const numbers = document.querySelectorAll('.notation-number');
            const numberTexts = Array.from(numbers).map(number => number.textContent);
            const reversedNumbers = numberTexts.reverse();
            
            numbers.forEach((number, index) => {
                number.textContent = reversedNumbers[index];
            });
        }

        // Flip board function
        function flipBoard() {
            boardFlipped = !boardFlipped;
            
            // Unclick hint button when board is flipped
            unclickHintButton();
            
            // Update button appearance
            const flipBtn = document.getElementById('flip-board-btn');
            if (boardFlipped) {
                flipBtn.classList.add('flipped');
            } else {
                flipBtn.classList.remove('flipped');
            }
            
            // Flip the notation
            flipNotation();
            
            // Reinitialize the board with the new orientation
            initializeChessBoard();
            
            // If there's a current game, update the board position
            if (currentGame) {
                updateBoardPosition();
            } else {
                setupInitialPosition();
            }
            
            // Reinitialize drag and drop functionality
            reinitializeDragAndDrop();
        }

        function applyVisualMode(mode) {
            const pieces = document.querySelectorAll('.chess-piece');
            
            pieces.forEach(piece => {
                applyVisualModeToPiece(piece, mode);
            });
        }

        function applyVisualModeToPiece(piece, mode) {
            const currentPiece = piece.dataset.piece;
            
            // Store original piece type if not already stored
            if (!piece.dataset.originalPiece) {
                piece.dataset.originalPiece = currentPiece;
            }
            
            const originalPiece = piece.dataset.originalPiece;
            let newPiece = originalPiece; // Start with original piece
            
            switch(mode) {
                case 'grey':
                    // Switch all white pieces to black pieces
                    if (originalPiece && originalPiece.includes('lt45')) {
                        // White piece -> Black piece
                        newPiece = originalPiece.replace('lt45', 'dt45');
                    } else {
                        // Keep black pieces as black
                        newPiece = originalPiece;
                    }
                    piece.style.backgroundImage = `url('pieces/${newPiece}')`;
                    piece.style.opacity = '1';
                    // Reset background size to default
                    piece.style.backgroundSize = '';
                    piece.style.backgroundRepeat = '';
                    piece.style.backgroundPosition = '';
                    break;
                 case 'checkers':
                     // For checkers mode, use dot for all pieces
                     newPiece = 'images/dot.png';
                     piece.style.backgroundImage = `url('${newPiece}')`;
                     piece.style.opacity = '1';
                     piece.style.backgroundSize = '80%';
                     piece.style.backgroundRepeat = 'no-repeat';
                     piece.style.backgroundPosition = 'center';
                     break;
                case 'empty':
                    // Make pieces completely invisible
                    newPiece = originalPiece;
                    piece.style.backgroundImage = `url('pieces/${newPiece}')`;
                    piece.style.opacity = '0';
                    // Reset background size to default
                    piece.style.backgroundSize = '';
                    piece.style.backgroundRepeat = '';
                    piece.style.backgroundPosition = '';
                    break;
                case 'normal':
                default:
                    // Reset to original pieces with original colors
                    newPiece = originalPiece;
                    piece.style.backgroundImage = `url('pieces/${newPiece}')`;
                    piece.style.opacity = '1';
                    // Reset background size to default
                    piece.style.backgroundSize = '';
                    piece.style.backgroundRepeat = '';
                    piece.style.backgroundPosition = '';
                    break;
            }
            
            // Update the piece image if it changed
            if (newPiece !== currentPiece) {
                piece.dataset.piece = newPiece;
                // Handle both full paths and piece filenames
                if (newPiece.startsWith('images/') || newPiece.startsWith('pieces/')) {
                    piece.style.backgroundImage = `url('${newPiece}')`;
                } else {
                    piece.style.backgroundImage = `url('pieces/${newPiece}')`;
                }
            }
         }

         // Challenge mode functions
         function toggleChallengeMode() {
             const challengeBtn = document.getElementById('challenge-btn');
             const modeOptions = document.querySelectorAll('.mode-option');
             const moveControls = document.querySelector('.move-controls');
             const movesList = document.getElementById('moves-list');
             const commentSection = document.getElementById('comment-section');
             
             if (!isChallengeMode && !currentGame) {
                 return;
             }
             
             if (!isChallengeMode) {
                 // Start challenge mode
                 isChallengeMode = true;
                 challengeBtn.textContent = 'Exit';
                 challengeBtn.classList.add('active');
                 
                 // Update hint button visibility
                 updateHintButtonVisibility();
                 
                 // Hide visual mode options and navigation buttons
                 modeOptions.forEach(option => {
                     option.style.display = 'none';
                 });
                 if (moveControls) {
                 moveControls.style.display = 'none';
                 }
                 if (movesList) {
                     movesList.style.display = 'block';
                 }
                 if (commentSection) {
                     commentSection.style.display = 'none';
                 }
                 
                // Reset to initial position
                currentMoveIndex = 0;
                setupInitialPosition();
                updateMoveButtons();
                
                // Reset play color selection to "Both"
                const playColorSection = document.getElementById('play-color-section');
                if (playColorSection) {
                    const bothRadio = playColorSection.querySelector('input[value="both"]');
                    const whiteRadio = playColorSection.querySelector('input[value="white"]');
                    const blackRadio = playColorSection.querySelector('input[value="black"]');
                    
                    if (bothRadio) bothRadio.checked = true;
                    if (whiteRadio) whiteRadio.checked = false;
                    if (blackRadio) blackRadio.checked = false;
                    
                    // Reset selected play color
                    window.selectedPlayColor = 'both';
                }
                
                // Update moves display to show only completed moves (none initially)
                updateChallengeMovesDisplay();
                 
                // Make all pieces invisible
                const pieces = document.querySelectorAll('.chess-piece');
                pieces.forEach(piece => {
                    piece.style.opacity = '0';
                });
                 
                 console.log('Challenge mode started! Replay the game from memory.');
             } else {
                 // Exit challenge mode
                 isChallengeMode = false;
                 challengeBtn.textContent = 'Test';
                 challengeBtn.classList.remove('active');
                 
                 // Update hint button visibility
                 updateHintButtonVisibility();
                 
                 // Show visual mode options and navigation buttons
                 modeOptions.forEach(option => {
                     option.style.display = 'flex';
                 });
                 if (moveControls) {
                 moveControls.style.display = 'flex';
                 }
                 if (movesList) {
                     movesList.style.display = 'block';
                 }
                 if (commentSection) {
                     commentSection.style.display = 'block';
                 }
                 
                 // Restore full moves display
                 displayGameMoves(currentGame);
                 
                 // Restore current visual mode
                 applyVisualMode(currentVisualMode);
                 
                 console.log('Challenge mode ended!');
             }
         }
         
         function updateChallengeMovesDisplay() {
             if (!isChallengeMode || !currentGame) return;
             
             const movesList = document.getElementById('moves-list');
             if (!movesList) return;
             
             // Clear existing moves
             movesList.innerHTML = '';
             
            // Group moves by move number, show completed moves plus current move
            const moveGroups = {};
            const completedMoves = Math.floor(currentMoveIndex / 2);
            const isWhiteMoveCompleted = currentMoveIndex % 2 === 1;
            
            // Show only moves that have been played (not the current move being made)
            for (let i = 0; i < currentMoveIndex && i < currentGame.moves_detailed.length; i++) {
                 const move = currentGame.moves_detailed[i];
                 const moveNumber = Math.floor(i / 2) + 1;
                 
                 if (!moveGroups[moveNumber]) {
                     moveGroups[moveNumber] = {};
                 }
                 
                 if (i % 2 === 0) {
                     moveGroups[moveNumber].white = move.white || move.black;
                 } else {
                     moveGroups[moveNumber].black = move.white || move.black;
                 }
             }
             
            // Create the moves display (only completed moves)
            if (Object.keys(moveGroups).length > 0 && currentMoveIndex > 0) {
                // Show the moves list only if moves have been played
                movesList.style.display = 'block';
                
                const moveItem = document.createElement('div');
                moveItem.className = 'move-item';
                
                Object.keys(moveGroups).forEach((moveNumber, moveIndex) => {
                    const group = moveGroups[moveNumber];
                    
                    const moveRow = document.createElement('div');
                    moveRow.className = 'move-row';
                    
                    const moveNumberSpan = document.createElement('span');
                    moveNumberSpan.textContent = moveNumber + '.';
                    moveNumberSpan.className = 'move-number';
                    moveRow.appendChild(moveNumberSpan);
                    
                    const whiteMoves = document.createElement('div');
                    whiteMoves.className = 'white-moves';
                    
                    const blackMoves = document.createElement('div');
                    blackMoves.className = 'black-moves';
                    
                    if (group.white) {
                        const whiteMoveSpan = document.createElement('span');
                        whiteMoveSpan.textContent = convertToChessSymbols(group.white);
                        whiteMoveSpan.className = 'clickable-move';
                        whiteMoves.appendChild(whiteMoveSpan);
                    }
                    
                    if (group.black) {
                        const blackMoveSpan = document.createElement('span');
                        blackMoveSpan.textContent = convertToChessSymbols(group.black);
                        blackMoveSpan.className = 'clickable-move';
                        blackMoves.appendChild(blackMoveSpan);
                    }
                    
                    moveRow.appendChild(whiteMoves);
                    moveRow.appendChild(blackMoves);
                    moveItem.appendChild(moveRow);
                });
                
                movesList.appendChild(moveItem);
            } else {
                // Hide the moves list when no moves have been played yet
                movesList.style.display = 'none';
            }
         }
         
         function checkChallengeProgress() {
             if (!isChallengeMode || !currentGame) return;
             
             // Update the moves display to show progress
             updateChallengeMovesDisplay();
             
             // Check if user completed the entire game
             if (currentMoveIndex >= currentGame.moves_detailed.length) {
                 showCompletionBadge();
             }
         }

         function showCompletionBadge() {
             const badge = document.getElementById('completion-badge');
             const overlay = document.getElementById('badge-overlay');
             
             // Mark this game as completed
             if (currentGame) {
                 completedChallenges.add(currentGame.id);
                 
                // Record completion in progress tracker based on type
                // Pass isChallengeMode to track if completed in test mode
                const difficulty = currentGame.difficulty || 'intermediate';
                if (currentGame.type === 'game') {
                    progressTracker.recordGameCompletion(difficulty, currentGame.id, 'game', isChallengeMode);
                }
                 
                 // End the current training session
                 progressTracker.endSession();
                 
                 console.log('Game completed! Progress updated:', progressTracker.getProgressSummary());
             }
             
             // Update badges in games list
             updateGameListBadges();
            
            // Trigger confetti celebration
            createConfetti();
             
             // Show overlay and badge with animation
             overlay.classList.add('show');
             setTimeout(() => {
                 badge.classList.add('show');
             }, 100);
         }

         function hideBadge() {
             const badge = document.getElementById('completion-badge');
             const overlay = document.getElementById('badge-overlay');
             
             // Switch to normal mode to reveal all pieces
             currentVisualMode = 'normal';
             switchVisualMode('normal');
             
             // Hide badge and overlay
             badge.classList.remove('show');
             setTimeout(() => {
                 overlay.classList.remove('show');
                 // Exit challenge mode after hiding badge
                 toggleChallengeMode();
             }, 300);
         }


        async function updateGameListBadges() {
            // CRITICAL: Always fetch fresh from Supabase (no cache, no fallback to progressTracker)
            if (typeof window.getUserProgress === 'function') {
                try {
                    console.log('ðŸ”„ Fetching fresh progress from Supabase for badges update');
                    const supabaseProgress = await window.getUserProgress();
                    if (supabaseProgress) {
                        // Build completedChallenges Set directly from Supabase data
                        completedChallenges = new Set();
                        if (supabaseProgress.completed_games && Array.isArray(supabaseProgress.completed_games)) {
                            supabaseProgress.completed_games.forEach(gameId => completedChallenges.add(gameId));
                        }
                        if (supabaseProgress.completed_puzzles && Array.isArray(supabaseProgress.completed_puzzles)) {
                            supabaseProgress.completed_puzzles.forEach(puzzleId => completedChallenges.add(puzzleId));
                        }
                    } else {
                        // No data - clear completed challenges
                        completedChallenges = new Set();
                    }
                } catch (error) {
                    console.error('âŒ Error loading progress for badges:', error);
                    // On error, clear completed challenges (no fallback)
                    completedChallenges = new Set();
                }
            } else {
                // getUserProgress not available - clear completed challenges
                completedChallenges = new Set();
            }
            
            console.log('Updating badges with completed challenges:', completedChallenges);
            
            // Update badges in the games list sidebar
            const badges = document.querySelectorAll('.game-completion-badge');
            console.log('Found badges:', badges.length);
            badges.forEach(badge => {
                const gameId = badge.dataset.game;
                const isCompleted = completedChallenges.has(gameId);
                console.log(`Game ${gameId}: completed = ${isCompleted}`);
                if (isCompleted) {
                    badge.classList.add('show');
                } else {
                    badge.classList.remove('show');
                }
            });
        }

         document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing...');

            // Initialize chess board (empty board, no pieces)
            initializeChessBoard();
            // Don't call setupStartingPosition() - board should be empty until game is selected
            
            // Hide custom game elements on initial load
            if (typeof hideCustomGameInfo === 'function') {
                hideCustomGameInfo();
            }
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }

            // Set up submenu toggles for all tabs
            const gameButtonIds = [
                'short-games-btn', 'my-games-short-games-btn', 'gm-games-fischer-games-btn',
                'medium-games-btn', 'my-games-medium-games-btn',
                'long-games-btn', 'my-games-long-games-btn',
                'epic-games-btn', 'my-games-epic-games-btn',
                'my-games-my-games-btn'
            ];
            
            const submenuIds = [
                'short-games-submenu', 'my-games-short-games-submenu', 'gm-games-fischer-games-submenu',
                'medium-games-submenu', 'my-games-medium-games-submenu',
                'long-games-submenu', 'my-games-long-games-submenu',
                'epic-games-submenu', 'my-games-epic-games-submenu',
                'my-games-my-games-submenu'
            ];
            
            gameButtonIds.forEach((buttonId, index) => {
                const button = document.getElementById(buttonId);
                const submenu = document.getElementById(submenuIds[index]);
                
                if (button && submenu) {
                    button.addEventListener('click', function(e) {
                        e.preventDefault();
                        console.log('Game button clicked:', buttonId);
                        
                        // Close all other submenus first
                        submenuIds.forEach((submenuId, submenuIndex) => {
                            if (submenuIndex !== index) {
                                const otherSubmenu = document.getElementById(submenuId);
                                const otherButton = document.getElementById(gameButtonIds[submenuIndex]);
                                if (otherSubmenu && otherButton) {
                                    otherSubmenu.classList.remove('show');
                                    otherButton.classList.remove('active');
                                }
                            }
                        });
                        
                        // Toggle the current submenu
                        if (submenu.classList.contains('show')) {
                            submenu.classList.remove('show');
                            button.classList.remove('active');
                        } else {
                            submenu.classList.add('show');
                            button.classList.add('active');
                        }
                    });
                }
            });

            // Game submenu button clicks
            const submenuButtons = document.querySelectorAll('.submenu-button');
            console.log('Found submenu buttons:', submenuButtons.length);
            
            submenuButtons.forEach(button => {
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    const gameId = this.getAttribute('href').substring(1);
                    console.log('Button clicked, gameId:', gameId);
                    displayGame(gameId);
                });
            });

            // Game header click to expand/collapse details - use event delegation
            document.addEventListener('click', function(e) {
                // Only handle clicks on the main game header, not the custom game header
                if (e.target.closest('#game-header') && !e.target.closest('#custom-game-header')) {
                    const gameHeader = document.getElementById('game-header');
                    const gameDetails = document.getElementById('game-details');
                    
                    if (gameHeader && gameDetails && gameHeader.style.display !== 'none') {
                        gameHeader.classList.toggle('expanded');
                        gameDetails.classList.toggle('show');
                        
                        // Remove any inline display style that might be overriding the CSS
                        if (gameDetails.classList.contains('show')) {
                            gameDetails.style.display = '';
                        } else {
                            gameDetails.style.display = 'none';
                        }
                    }
                }
            });

            // Move navigation button event listeners
            document.getElementById('btn-initial').addEventListener('click', goToInitialPosition);
            document.getElementById('btn-back').addEventListener('click', goToPreviousMove);
            document.getElementById('btn-forward').addEventListener('click', goToNextMove);
            document.getElementById('btn-final').addEventListener('click', goToFinalPosition);
            
            // Hint button event listener
            const hintBtn = document.getElementById('hint-btn');
            if (hintBtn) {
                hintBtn.addEventListener('click', showHint);
            }

            // Visual mode option event listeners
            const modeOptions = document.querySelectorAll('.mode-option');
            modeOptions.forEach(option => {
                option.addEventListener('click', function() {
                    const mode = this.dataset.mode;
                    switchVisualMode(mode);
                });
            });

            // Flip board button event listener
            document.getElementById('flip-board-btn').addEventListener('click', flipBoard);

            // Challenge button event listener
            const challengeBtn = document.getElementById('challenge-btn');
            challengeBtn.addEventListener('click', function() {
                toggleChallengeMode();
            });


            // Initialize move buttons as disabled
            updateMoveButtons();
            
            // Initialize game list badges
            updateGameListBadges();
        });
    </script>

    <!-- Sign In Modal -->
    <div id="signInModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Sign In</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <form id="signInForm" onsubmit="handleSignIn(event)">
                <div class="form-group">
                    <label class="form-label" for="signInEmail">Email</label>
                    <input type="email" id="signInEmail" class="form-input" placeholder="Enter your email" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="signInPassword">Password</label>
                    <input type="password" id="signInPassword" class="form-input" placeholder="Enter your password" required>
                </div>
            <div class="modal-buttons">
                <button type="submit" class="btn-modal btn-primary">Sign In</button>
                <button type="button" class="btn-modal btn-secondary" onclick="closeModal()">Cancel</button>
            </div>
        </form>
        <div class="google-signup">
            <button type="button" class="btn-modal btn-google" onclick="handleGoogleSignIn()">
                <div class="google-icon"></div>
                Sign in with Google
            </button>
        </div>
        <div class="register-link">
            <p>Don't have an account yet? <a href="#" onclick="showRegisterModal()">Register here</a></p>
        </div>
        </div>
    </div>

    <!-- Register Modal -->
    <div id="registerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Create Account</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <form id="registerForm" onsubmit="handleRegister(event)">
                <div class="form-group">
                    <label class="form-label" for="registerEmail">Email</label>
                    <input type="email" id="registerEmail" class="form-input" placeholder="Enter your email" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="registerPassword">Password</label>
                    <input type="password" id="registerPassword" class="form-input" placeholder="Create a password" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="registerName">Full Name</label>
                    <input type="text" id="registerName" class="form-input" placeholder="Enter your full name" required>
                </div>
                <div class="modal-buttons">
                    <button type="submit" class="btn-modal btn-primary">Create Account</button>
                    <button type="button" class="btn-modal btn-secondary" onclick="closeModal()">Cancel</button>
                </div>
            </form>
            <div class="google-signup">
                <button type="button" class="btn-modal btn-google" onclick="registerWithGoogle()">
                    <div class="google-icon"></div>
                    Register with Google
                </button>
            </div>
        </div>
    </div>

    <!-- Logout Confirmation Modal -->
    <div id="logoutConfirmModal" class="logout-confirm-modal">
        <div class="logout-confirm-content">
            <div class="logout-confirm-header">
                <h2>Confirm Logout</h2>
            </div>
            <div class="logout-confirm-message">
                Are you sure you want to log out? You'll need to sign in again to access your account.
            </div>
            <div class="logout-confirm-buttons">
                <button class="btn-logout-confirm btn-logout-yes" onclick="confirmLogout()">Yes, Logout</button>
                <button class="btn-logout-confirm btn-logout-no" onclick="cancelLogout()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Subscription Required Modal -->
    <div id="subscriptionRequiredModal" class="subscription-required-modal">
        <div class="subscription-required-content">
            <div class="subscription-required-header">
                <h2>ðŸ”’ Subscription Required</h2>
            </div>
            <div class="subscription-required-message">
                This content is locked and requires a premium subscription to access. Upgrade your account to unlock all games.
            </div>
            <div class="subscription-required-buttons">
                <button class="btn-subscription-required btn-subscription-yes" onclick="goToSubscription()">Get Subscription</button>
                <button class="btn-subscription-required btn-subscription-no" onclick="closeSubscriptionModal()">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Supabase JavaScript Library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2" onerror="console.error('Failed to load Supabase library')"></script>
    
    <!-- Supabase Configuration -->
    <script src="supabase-config.js" onerror="console.error('Failed to load supabase-config.js')"></script>
    
    <!-- Supabase Helper Functions -->
    <script src="supabase-helpers.js" onerror="console.error('Failed to load supabase-helpers.js')"></script>
    
    <!-- Supabase Authentication Functions -->
    <script src="supabase-auth.js" onerror="console.error('Failed to load supabase-auth.js')"></script>
    
    <!-- Auto-load games on page load - placed at end to ensure all scripts are loaded -->
    <script>
        console.log('ðŸ”´ FINAL SCRIPT BLOCK - Auto-loading games');
        (async function() {
            console.log('ðŸ”´ Auto-load function starting...');
            
            // Step 1: Wait for reloadGamesData to be available
            let attempts = 0;
            while (typeof reloadGamesData !== 'function' && attempts < 100) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
                if (attempts % 10 === 0) {
                    console.log('ðŸ”´ Waiting for reloadGamesData... attempt', attempts);
                }
            }
            
            if (typeof reloadGamesData !== 'function') {
                console.error('ðŸ”´ reloadGamesData never became available after', attempts, 'attempts');
                return;
            }
            
            console.log('ðŸ”´ reloadGamesData is available!');
            
            // Step 2: Initialize Supabase if needed
            if (typeof initSupabase === 'function') {
                console.log('ðŸ”´ Initializing Supabase...');
                await initSupabase();
            }
            
            // Step 3: Wait for Supabase to be ready (so isSignedIn() works correctly)
            console.log('ðŸ”´ Waiting for Supabase to be ready...');
            attempts = 0;
            while (attempts < 100) {
                const supabase = typeof window.getSupabase === 'function' ? window.getSupabase() : null;
                if (supabase && supabase.auth && typeof supabase.auth.getSession === 'function') {
                    // Test if we can actually get a session (Supabase is fully ready)
                    try {
                        const { data } = await supabase.auth.getSession();
                        console.log('ðŸ”´ Supabase is ready! Session check successful.');
                        break;
                    } catch (error) {
                        // Not ready yet, continue waiting
                    }
                }
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
                if (attempts % 10 === 0) {
                    console.log('ðŸ”´ Waiting for Supabase to be ready... attempt', attempts);
                }
            }
            
            // Step 4: Now call reloadGamesData() - Supabase should be ready
            console.log('ðŸ”´ Calling reloadGamesData()...');
            try {
                await reloadGamesData();
                console.log('ðŸ”´ reloadGamesData() completed successfully!');
            } catch (error) {
                console.error('ðŸ”´ Error calling reloadGamesData:', error);
            }
        })();
    </script>
    
    <script>
        // Initialize Supabase when page loads
        // CRITICAL: This runs independently - games should already be loaded
        document.addEventListener('DOMContentLoaded', async function() {
            // Wait a bit to ensure Supabase scripts are loaded
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
                // Initialize Supabase client
                if (typeof initSupabase === 'function') {
                    await initSupabase();
                } else {
                    console.warn('âš ï¸ initSupabase function not available - Supabase scripts may not be loaded');
                }
                
                // Handle OAuth callback if present (must happen after Supabase is initialized)
                if (typeof handleOAuthCallback === 'function') {
                    try {
                        await handleOAuthCallback();
                    } catch (error) {
                        console.error('Error handling OAuth callback:', error);
                    }
                }
                
                // Update navigation after OAuth callback
                if (typeof updateNavigation === 'function') {
                    try {
                        await updateNavigation();
                    } catch (error) {
                        console.error('Error updating navigation:', error);
                    }
                }
            } catch (error) {
                console.error('Error initializing Supabase:', error);
                console.error('Games should still work - Supabase is optional for games loading');
                // Page should still work even if Supabase fails
            }
        });
    </script>
</body>
</html>
