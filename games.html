<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blind Chess</title>
    <script>
        // Check subscription status immediately to prevent flashing
        (function() {
            const hasActiveSubscription = localStorage.getItem('hasActiveSubscription') === 'true';
            if (hasActiveSubscription) {
                // Add CSS to hide subscription tab for subscribers
                const style = document.createElement('style');
                style.textContent = '.subscription-tab-li { display: none !important; }';
                document.head.appendChild(style);
            }
        })();
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
        }

        .navbar {
            background-color: #2c3e50;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .logo {
            display: flex;
            align-items: center;
            color: #ecf0f1;
            font-size: 1.5rem;
            font-weight: bold;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        .logo:hover {
            color: #3498db;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            margin-right: 10px;
            background-color: #ecf0f1;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .nav-links {
            display: flex;
            list-style: none;
            gap: 2rem;
            align-items: center;
        }

        .nav-links a {
            color: #ecf0f1;
            text-decoration: none;
            font-weight: 500;
            font-size: 1.1rem;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
        }

        .nav-links a:hover {
            background-color: #34495e;
        }

        /* Profile Button Styles */
        .profile-button {
            color: #ecf0f1;
            text-decoration: none;
            font-weight: 500;
            font-size: 1.1rem;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
        }

        .profile-button:hover {
            background-color: #34495e;
        }

        /* Profile Dropdown Styles */
        .profile-dropdown {
            position: relative;
        }

        .profile-icon {
            display: flex;
            align-items: center;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-size: 1rem;
            font-weight: 500;
            position: relative;
        }


        .profile-icon:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .profile-avatar {
            font-size: 1.2rem;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
        }

        .profile-avatar img {
            border-radius: 50%;
            background: white;
        }


        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 180px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 1000;
            border: 1px solid #e9ecef;
        }

        .profile-dropdown:hover .dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            color: #1a1a1a;
            text-decoration: none;
            transition: all 0.2s ease;
            border-bottom: 1px solid #f8f9fa;
            width: 100%;
            box-sizing: border-box;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background-color: transparent !important;
            color: #1a1a1a !important;
            transform: translateX(2px);
        }
        
        /* Initially hide subscription tab only for users with active subscription */
        .subscription-tab-li {
            display: block; /* Show by default for free users */
        }
        
        /* Hide only if user has active subscription (set by JavaScript) */
        .subscription-tab-li.hidden-for-subscriber {
            display: none;
        }

        .dropdown-icon {
            font-size: 1rem;
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }

        .dropdown-text {
            font-size: 0.9rem;
            font-weight: 500;
            color: #1a1a1a;
        }

        .nav-links a.active {
            background-color: #3498db;
            color: #ffffff;
        }

        .main-layout {
            display: flex;
            flex-direction: column;
            min-height: calc(100vh - 60px);
            justify-content: center;
            align-items: center;
            padding: 0.5rem 0 2rem 0;
        }

        /* Games Tabs Styles */
        .games-tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 0;
            border-bottom: 2px solid transparent;
            width: 100%;
        }

        .games-tabs .tab {
            padding: 1rem 2rem;
            cursor: pointer;
            font-weight: 600;
            color: #7f8c8d;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            font-size: 1.1rem;
            flex: 1;
            text-align: center;
            max-width: 200px;
        }

        .games-tabs .tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
        }

        .games-tabs .tab:hover {
            color: #3498db;
        }

        /* Tab Content Styles */
        .tab-content {
            width: 100%;
            max-width: 400px;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        /* Simplified Tab Content Styles */
        .my-games-content, .gm-games-content {
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .my-games-header, .gm-games-header {
            text-align: center;
            margin-bottom: 1rem;
        }

        .my-games-header h3, .gm-games-header h3 {
            font-size: 1.3rem;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .my-games-header p, .gm-games-header p {
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .my-games-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .stat-card {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e0e0e0;
        }

        .stat-card .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: #3498db;
            margin-bottom: 0.25rem;
        }

        .stat-card .stat-label {
            color: #7f8c8d;
            font-weight: 500;
            font-size: 0.8rem;
        }

        .my-games-list {
            min-height: 100px;
        }

        .loading {
            text-align: center;
            padding: 1rem;
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .gm-categories {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .gm-category h4 {
            font-size: 1rem;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid #3498db;
        }

        .gm-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .gm-item {
            background: white;
            padding: 0.75rem;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .gm-item:hover {
            border-color: #3498db;
        }

        .gm-name {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .gm-games-count {
            color: #7f8c8d;
            font-size: 0.8rem;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 0.75rem;
        }

        .game-item {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            transition: all 0.3s ease;
        }

        .game-item.completed {
            border-color: #2ecc71;
            background: #f0f9f4;
        }

        .game-item:hover {
            border-color: #3498db;
        }

        .game-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }

        .game-info {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .game-moves, .game-difficulty {
            font-size: 0.8rem;
            color: #7f8c8d;
        }

        .game-status {
            font-weight: 600;
            color: #2ecc71;
            font-size: 0.8rem;
        }

        .empty-state {
            text-align: center;
            padding: 2rem;
            color: #7f8c8d;
        }

        .empty-state h4 {
            margin-bottom: 0.5rem;
            color: #2c3e50;
            font-size: 1rem;
        }

        .main-layout {
            display: flex;
            flex-direction: column;
            min-height: calc(100vh - 60px);
            justify-content: flex-start;
            align-items: center;
            padding: 0.5rem 0 2rem 0;
            position: relative;
        }

        .top-section {
            width: 100%;
            max-width: 800px;
            margin-top: 10px;
            margin-left: -95px;
            display: flex;
            justify-content: flex-start;
        }

        .bottom-section {
            display: flex;
            flex-direction: row;
            width: 100%;
            max-width: 1400px;
            gap: 1rem;
            align-items: flex-start;
            justify-content: center;
            margin-left: -20px;
        }

        .left-panel {
            flex: 0 0 310px;
            min-width: 350px;
            display: flex;
            flex-direction: column;
            margin-top: 30px;
            margin-left: 25px;
        }

        .right-panel {
            flex: 1;
            min-width: 600px;
            max-width: 1000px;
            display: flex;
            flex-direction: column;
            margin-left: -10px;
        }

        .main-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .game-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 1.25rem;
            width: 280px;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border: none;
        }

        .game-button {
            background-color: #ffffff;
            border: 2px solid #bdc3c7;
            border-radius: 12px;
            padding: 1rem;
            text-decoration: none;
            color: #2c3e50;
            text-align: center;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            width: 100%;
        }

        .game-button:hover {
            border-color: #3498db;
            background-color: #f8f9fa;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .submenu-button.locked {
            position: relative;
            cursor: not-allowed;
        }

        .submenu-button.locked:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            background-color: #ffffff;
            margin: 5% auto;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            position: relative;
            animation: slideIn 0.3s ease;
        }

        .modal-header {
            margin-bottom: 1.5rem;
            position: relative;
        }

        .modal-header h2 {
            margin: 0;
            color: #2c3e50;
            font-size: 1.25rem;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            color: #2c3e50;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1rem;
            box-sizing: border-box;
        }

        .form-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .btn-modal {
            flex: 1;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background-color: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background-color: #2980b9;
        }

        .btn-secondary {
            background-color: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #7f8c8d;
        }

        .account-info {
            padding: 1rem 0;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid #f8f9fa;
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .info-item label {
            font-weight: 600;
            color: #2c3e50 !important;
            min-width: 100px;
        }

        .info-item span {
            color: #7f8c8d !important;
            text-align: right;
        }

        .register-link {
            text-align: center;
            margin-top: 1rem;
        }

        .register-link a {
            color: #3498db;
            text-decoration: none;
        }

        .register-link a:hover {
            text-decoration: underline;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
        }

        .close:hover {
            color: #000;
        }

        .btn-google {
            background-color: #ffffff;
            color: #333;
            border: 1px solid #dadce0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: box-shadow 0.2s;
            width: 100%;
        }

        .btn-google:hover {
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .google-icon {
            width: 20px;
            height: 20px;
            background: url('images/google.png') no-repeat center;
            background-size: contain;
        }

        .google-signup {
            margin-top: 1rem;
            text-align: center;
        }

        /* Logout Confirmation Modal */
        .logout-confirm-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s ease;
        }

        .logout-confirm-content {
            background-color: #ffffff;
            margin: 15% auto;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            position: relative;
            animation: slideIn 0.3s ease;
            text-align: center;
        }

        .logout-confirm-header {
            margin-bottom: 1.5rem;
        }

        .logout-confirm-header h2 {
            margin: 0;
            color: #2c3e50;
            font-size: 1.25rem;
            font-weight: 600;
        }

        .logout-confirm-message {
            color: #7f8c8d;
            margin-bottom: 2rem;
            line-height: 1.5;
        }

        .logout-confirm-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .btn-logout-confirm {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .btn-logout-yes {
            background-color: #e74c3c;
            color: white;
        }

        .btn-logout-yes:hover {
            background-color: #c0392b;
        }

        .btn-logout-no {
            background-color: #95a5a6;
            color: white;
        }

        .btn-logout-no:hover {
            background-color: #7f8c8d;
        }

        /* Subscription Required Modal */
        .subscription-required-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s ease;
        }

        .subscription-required-content {
            background-color: #ffffff;
            margin: 15% auto;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 450px;
            position: relative;
            animation: slideIn 0.3s ease;
        }

        .subscription-required-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .subscription-required-header h2 {
            color: #2c3e50;
            margin: 0;
            font-size: 1.5rem;
        }

        .subscription-required-message {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .subscription-required-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .btn-subscription-required {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .btn-subscription-yes {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .btn-subscription-yes:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        .btn-subscription-no {
            background: #95a5a6;
            color: white;
        }

        .btn-subscription-no:hover {
            background: #7f8c8d;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .lock-overlay {
            position: absolute;
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #7f8c8d;
            font-weight: bold;
            z-index: 10;
        }

        .lock-icon {
            font-size: 1.5rem;
            margin-bottom: 0.25rem;
        }

        .lock-text {
            font-size: 0.7rem;
            text-align: center;
        }

        .game-button.active {
            border-color: #3498db;
            background-color: #e3f2fd;
            color: #2980b9;
        }

        .game-button .description {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-top: 0.5rem;
            font-weight: 400;
        }

        .game-button-container {
            display: flex;
            flex-direction: column;
        }

        .game-button-container .game-button {
            background-color: #ffffff;
            border: 2px solid #bdc3c7;
            border-radius: 12px;
            padding: 1rem;
            text-decoration: none;
            color: #2c3e50;
            text-align: center;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            width: 100%;
        }

        .game-button-container .game-button:hover {
            border-color: #3498db;
            background-color: #f8f9fa;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .game-button-container .game-button.active {
            border-color: #3498db;
            background-color: #e3f2fd;
            color: #2980b9;
        }

        .submenu {
            display: none;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
            padding-left: 1rem;
            animation: slideDown 0.3s ease-out;
        }

        .submenu.show {
            display: flex;
        }

        .submenu-button {
            background-color: #e9ecef;
            border: 1px solid #ced4da;
            border-radius: 8px;
            padding: 0.75rem;
            text-decoration: none;
            color: #495057;
            text-align: center;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .submenu-button:hover {
            background-color: #dee2e6;
            border-color: #adb5bd;
            transform: translateX(5px);
        }

        .submenu-button.selected {
            transform: translateX(6px) !important;
            background-color: #e3f2fd !important;
            border: 1px solid #2196f3 !important;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2) !important;
            font-weight: normal !important;
            color: #1976d2 !important;
        }

        .submenu-button.selected:hover {
            background-color: #e3f2fd !important;
            border-color: #2196f3 !important;
            transform: translateX(6px) !important;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2) !important;
        }

        .game-completion-badge {
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%) scale(0);
            opacity: 0;
            transition: all 0.15s ease;
            z-index: 10;
        }

        .game-completion-badge.show {
            opacity: 1;
            transform: translateY(-50%) scale(1);
        }

        .game-completion-badge:hover::after {
            content: "Memory challenge completed";
            position: absolute;
            bottom: 100%;
            right: 0;
            background-color: #333;
            color: white;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            margin-bottom: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .game-completion-badge:hover::before {
            content: "";
            position: absolute;
            bottom: 100%;
            right: 8px;
            border: 4px solid transparent;
            border-top-color: #333;
            z-index: 1000;
            margin-bottom: -4px;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .game-display {
            display: block;
            padding: 1rem 2rem;
        }

        .game-display.show {
            display: block;
        }

        .game-content {
            display: flex;
            gap: 3.5rem;
            align-items: flex-start;
            justify-content: center;
            width: 100%;
            max-width: 1000px;
        }

        .board-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
        }

         .visual-modes {
             display: flex;
             flex-direction: row;
             gap: 1rem;
             justify-content: center;
             align-items: center;
             padding: 1rem;
             background-color: #f8f9fa;
             border-radius: 12px;
             border: 2px solid #dee2e6;
             box-shadow: 0 4px 12px rgba(0,0,0,0.1);
             width: 520px;
         }


        .mode-option {
            background-color: #ffffff;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            color: #495057;
            transition: all 0.2s ease;
            text-align: center;
            min-height: 40px;
            min-width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mode-option:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-1px);
        }

        .mode-option.active {
            background-color: #3498db;
            border-color: #2980b9;
            color: white;
        }

        .mode-option.active:hover {
            background-color: #2980b9;
            transform: translateY(-1px);
        }


        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 520px;
            height: 520px;
            border: 3px solid #2c3e50;
            border-radius: 10px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.25);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 6px;
            position: relative;
        }

        .chess-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            border-radius: 4px;
        }
        
        .chess-board.dragging .chess-square {
            transition: none !important;
        }

        /* Board coordinates styles */
        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .board-coordinates {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .board-notation {
            display: flex;
            width: 502px;
            margin: 5px auto 0 auto;
            justify-content: space-between;
        }
        
        .notation-letter {
            width: 62.75px;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            color: #000000;
            padding: 5px 0;
            box-sizing: border-box;
        }
        
        .rank-notation {
            display: flex;
            flex-direction: column;
            width: 47.5px;
            height: 502px;
            position: absolute;
            right: -40.5px;
            top: 7px;
            justify-content: space-between;
        }
        
        .notation-number {
            height: 62.75px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: #000000;
            box-sizing: border-box;
        }

        .coordinate-labels-bottom {
            grid-area: bottom;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            height: 20px;
        }

        .coordinate-labels-right {
            grid-area: right;
            display: grid;
            grid-template-rows: repeat(8, 1fr);
            width: 20px;
        }

        .coordinate-label {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #2c3e50;
            user-select: none;
        }

        .coordinate-label.letter {
            color: #34495e;
        }

        .coordinate-label.number {
            color: #34495e;
        }

        .chess-square.light {
            background: linear-gradient(135deg, #f0d9b5 0%, #e8d5b7 100%);
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
        }

        .chess-square.dark {
            background: linear-gradient(135deg, #b58863 0%, #a67c52 100%);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .chess-square:hover {
            background: linear-gradient(135deg, #ffeb3b 0%, #ffc107 100%);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(255,235,59,0.4);
            z-index: 10;
        }

        .chess-piece {
            width: 60px;
            height: 60px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transition: all 0.2s ease;
            cursor: grab;
        }
        
        .chess-piece.dragging {
            transition: none !important;
        }

        .chess-piece:hover {
            transform: scale(1.1);
        }

        .chess-piece:active {
            cursor: grabbing;
        }

        .chess-square.valid-move {
            background-color: rgba(144, 238, 144, 0.3) !important;
            outline: 3px solid #32CD32;
            outline-offset: -3px;
        }

        .chess-square.valid-move:hover {
            background-color: rgba(152, 251, 152, 0.4) !important;
        }

        .chess-square.selected {
            background: #FFD700 !important;
            box-shadow: inset 0 2px 4px rgba(255, 215, 0, 0.5) !important;
        }

        .chess-square.selected.light {
            background: #FFD700 !important;
            box-shadow: inset 0 2px 4px rgba(255, 215, 0, 0.5) !important;
        }

        .chess-square.selected.dark {
            background: #FFD700 !important;
            box-shadow: inset 0 2px 4px rgba(255, 215, 0, 0.5) !important;
        }

        .moves-panel {
            width: 420px;
            background-color: #ffffff;
            margin-left: 30px;
            border: none;
            border-radius: 12px;
            padding: 1.25rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            max-height: 630px;
            overflow-y: auto;
            align-self: flex-start;
        }

        .game-header {
            background: #ffffff;
            color: #333333;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            border: 1px solid #e0e0e0;
            box-shadow: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .game-header:hover {
            background: #f5f5f5;
            border-color: #cccccc;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .game-header::after {
            content: 'â–¼';
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.2s ease;
            font-size: 0.8rem;
            color: #666666;
        }

        .game-header.expanded::after {
            transform: translateY(-50%) rotate(180deg);
        }


        .game-title-line {
            font-size: 1rem;
            font-weight: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333333;
            text-align: center;
        }

        .move-count {
            font-size: 0.85rem;
            color: #666666;
            background: #e9ecef;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-weight: 400;
        }

        .move-count-left {
            font-size: 0.8rem;
            color: #7f8c8d;
            font-weight: 400;
            font-style: italic;
        }

        .game-title {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .game-info {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .game-details {
            background-color: #f8f9fa;
            border: none;
            border-radius: 0 0 6px 6px;
            margin-top: 0;
            max-height: 0;
            overflow: hidden;
            padding: 0 1rem;
            transition: max-height 0.4s ease, padding 0.4s ease, margin 0.4s ease;
        }

        .game-details.show {
            max-height: 600px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e9ecef;
        }

        .detail-item:last-child {
            border-bottom: none;
        }

        .detail-label {
            font-weight: bold;
            color: #2c3e50;
            font-size: 0.9rem;
            flex-shrink: 0;
            margin-right: 1rem;
        }

        .detail-value {
            color: #495057;
            font-size: 0.9rem;
            text-align: right;
            line-height: 1.4;
            flex: 1;
        }

        .detail-facts {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #dee2e6;
        }

        .facts-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .facts-text {
            color: #495057;
            font-size: 0.85rem;
            line-height: 1.4;
        }


        .move-controls {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .move-btn {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            color: #495057;
            transition: all 0.2s ease;
            min-width: 40px;
            text-align: center;
        }

        .move-btn:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-1px);
        }

        .move-btn:active {
            transform: translateY(0);
        }

        .move-btn:disabled {
            background-color: #f8f9fa;
            color: #adb5bd;
            cursor: not-allowed;
            transform: none;
        }

        .move-btn:disabled:hover {
            background-color: #f8f9fa;
            border-color: #dee2e6;
            transform: none;
        }

        .move-icon {
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #495057;
            user-select: none;
            width: 40px;
            height: 40px;
            flex-shrink: 0;
        }

        .move-icon:hover {
            background-color: #e9ecef;
            transform: translateY(-1px);
        }

        .move-icon:active {
            transform: translateY(0);
        }

        .move-icon.disabled {
            color: #adb5bd;
            cursor: not-allowed;
            transform: none;
        }

        .move-icon.disabled:hover {
            background-color: transparent;
            transform: none;
        }

          .visual-modes {
              display: flex;
              align-items: center;
              margin-top: 5px;
          }

          .mode-title {
              margin-right: 10px;
              margin-top: 4px;
          }


          .challenge-title {
              font-weight: bold;
              color: #2c3e50;
              font-size: 0.9rem;
              margin-right: 10px;
          }

          .challenge-btn {
              background-color: #ffffff;
              border: 2px solid #dee2e6;
              border-radius: 8px;
              padding: 0.75rem 1.5rem;
              cursor: pointer;
              font-size: 0.85rem;
              font-weight: 500;
              color: #495057;
              transition: all 0.2s ease;
              min-width: 120px;
              text-align: center;
              display: flex;
              align-items: center;
              justify-content: center;
          }

          .challenge-btn:hover {
              background-color: #e9ecef;
              border-color: #adb5bd;
              transform: translateY(-1px);
          }

          .challenge-btn.active {
              background-color: #dc3545;
              border-color: #c82333;
              color: white;
          }

          .test-btn {
              background: linear-gradient(135deg, #ff6b6b, #ee5a24);
              border: 2px solid #ee5a24;
              border-radius: 8px;
              padding: 0.75rem 1.5rem;
              cursor: pointer;
              font-size: 0.85rem;
              font-weight: 600;
              color: white;
              transition: all 0.2s ease;
              min-width: 80px;
              text-align: center;
              display: flex;
              align-items: center;
              justify-content: center;
              box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
          }

          .test-btn:hover {
              background: linear-gradient(135deg, #ee5a24, #d63031);
              border-color: #d63031;
              transform: translateY(-1px);
              box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
          }

          .test-btn.active {
              background: linear-gradient(135deg, #d63031, #a71e2e);
              border-color: #a71e2e;
              box-shadow: 0 2px 8px rgba(214, 48, 49, 0.4);
          }

          .test-btn.active:hover {
              background: linear-gradient(135deg, #a71e2e, #8b1538);
              border-color: #8b1538;
              transform: translateY(-1px);
          }

          .flip-board-icon {
              display: flex;
              align-items: center;
              justify-content: center;
              transition: all 0.2s ease;
          }

          .flip-board-icon:hover {
              transform: scale(1.1);
          }

          .flip-board-icon.flipped {
              transform: rotate(180deg);
          }

          .flip-board-icon.flipped:hover {
              transform: rotate(180deg) scale(1.1);
          }


          .completion-badge {
              position: fixed;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%) scale(0);
              background: #ffffff;
              color: #2c3e50;
              padding: 2.5rem 3rem;
              border-radius: 12px;
              box-shadow: 0 12px 24px rgba(0,0,0,0.15), 0 0 0 1px rgba(0,0,0,0.05);
              text-align: center;
              z-index: 9999;
              font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
              border: 2px solid #e8f5e8;
              transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
              max-width: 400px;
              backdrop-filter: blur(20px);
          }

          .completion-badge.show {
              transform: translate(-50%, -50%) scale(1);
          }

          .completion-badge .badge-icon {
              margin-bottom: 1.5rem;
              text-align: center;
              animation: bounce 1s infinite;
              filter: drop-shadow(0 2px 4px rgba(40, 167, 69, 0.2));
          }

          .completion-badge .badge-title {
              font-size: 1.75rem;
              font-weight: 700;
              margin-bottom: 0.75rem;
              color: #2c3e50;
              letter-spacing: -0.5px;
          }

          .completion-badge .badge-subtitle {
              font-size: 1rem;
              color: #7f8c8d;
              margin-bottom: 2rem;
              line-height: 1.5;
              font-weight: 400;
          }

          .completion-badge .badge-close {
              background: linear-gradient(135deg, #3498db, #2980b9);
              border: 2px solid #3498db;
              color: white;
              padding: 0.75rem 2rem;
              border-radius: 8px;
              cursor: pointer;
              font-size: 0.95rem;
              font-weight: 600;
              transition: all 0.2s ease;
              font-family: inherit;
              box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
          }

          .completion-badge .badge-close:hover {
              background: linear-gradient(135deg, #2980b9, #21618c);
              border-color: #2980b9;
              transform: translateY(-1px);
              box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
          }

          .badge-overlay {
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: rgba(44, 62, 80, 0.85);
              backdrop-filter: blur(4px);
              z-index: 9998;
              opacity: 0;
              transition: all 0.3s ease;
              pointer-events: none;
          }

          .badge-overlay.show {
              opacity: 1;
              pointer-events: all;
          }

          @keyframes bounce {
              0%, 20%, 50%, 80%, 100% {
                  transform: translateY(0);
              }
              40% {
                  transform: translateY(-10px);
              }
              60% {
                  transform: translateY(-5px);
              }
          }

          .moves-title {
            font-size: 1.2rem;
            color: #2c3e50;
            margin-bottom: 1rem;
            text-align: center;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 0.5rem;
        }

        .move-item {
            padding: 0.25rem 0.5rem;
            background-color: #fff;
            border: none;
            margin-bottom: 0.1rem;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            color: #495057;
            transition: background-color 0.2s ease;
            user-select: none;
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
        }


        .move-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-height: 1rem;
            padding: 0.1rem 0;
        }

        .move-number {
            font-weight: bold;
            color: #6c757d;
            font-size: 0.9rem;
            min-width: 1.5rem;
            text-align: center;
        }

        .white-moves {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
            padding: 0.3rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .black-moves {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
            justify-content: flex-start;
            padding: 0.3rem 0.3rem 0.3rem 1.3rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .clickable-move {
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: background-color 0.2s ease;
            display: inline-block;
            font-size: 1rem;
            font-weight: normal;
        }

        .white-moves:hover .clickable-move {
            background-color: #f8f9fa;
        }

        .black-moves:hover .clickable-move {
            background-color: #f8f9fa;
        }

        .white-moves.clicked .clickable-move {
            background-color: #e3f2fd;
            color: #1976d2;
        }

        .black-moves.clicked .clickable-move {
            background-color: #e3f2fd;
            color: #1976d2;
        }

        .clickable-move.active-move {
            font-weight: bold;
        }


        .moves-container {
            padding: 0.5rem;
            background-color: #fff;
            border-radius: 4px;
            border: 1px solid #e9ecef;
            margin-top: 0.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.125rem;
        }


        .main-content {
            flex: 1;
            padding: 1rem 2rem;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 1200px;
            width: 100%;
        }

        .main-content h1 {
            color: #2c3e50;
            margin-bottom: 1rem;
        }

        .main-content p {
            color: #7f8c8d;
            font-size: 1.1rem;
        }

        @media (max-width: 768px) {
            .navbar {
                padding: 0.5rem 1rem;
                flex-direction: column;
                gap: 0.5rem;
            }

            .nav-links {
                gap: 1rem;
            }

            .nav-links a {
                padding: 0.4rem 0.8rem;
                font-size: 0.9rem;
            }

            .main-content {
                padding: 0.5rem 1rem;
            }

            .game-display {
                padding: 0.5rem 1rem;
            }

            .main-layout {
                flex-direction: column;
                align-items: center;
                padding: 0.25rem 0 1rem 0;
            }
            
            .bottom-section {
                flex-direction: column;
                gap: 1rem;
                align-items: center;
                padding: 0 1rem;
            }
            
            .left-panel {
                flex: none;
                width: 100%;
                max-width: 400px;
                margin-left: 40px;
            }
            
            .right-panel {
                flex: none;
                width: 100%;
                max-width: 500px;
                margin-left: 15px;
            }

            .game-buttons {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
                padding: 1.25rem;
                margin-left: 1rem;
                gap: 0.5rem;
            }

            .game-button {
                flex: 1;
                min-width: 120px;
                padding: 0.8rem 0.5rem;
                font-size: 0.9rem;
            }
        }
        
        /* Responsive styles for smaller laptops */
        @media (max-width: 1200px) {
            .bottom-section {
                gap: 1.5rem;
            }
            
            .left-panel {
                flex: 0 0 350px;
                min-width: 300px;
            }
            
            .right-panel {
                min-width: 500px;
            }
            
            .game-buttons {
                width: 240px;
                padding: 1.25rem;
            }
            
            .game-content {
                gap: 2rem;
            }
            
            .chess-board {
                width: 440px;
                height: 440px;
            }
            
            .board-coordinates {
                grid-template-columns: 440px 20px;
                grid-template-rows: 440px 20px;
            }
            
            .visual-modes {
                width: 440px;
            }
            
            .moves-panel {
                width: 360px;
                max-height: 550px;
            }
            
            .chess-piece {
                width: 50px;
                height: 50px;
            }
        }

        /* Toggle Switch Styles */
        .toggle-switch {
            position: relative;
            display: inline-block;
        }

        .toggle-switch input[type="checkbox"] {
            display: none;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 2px 4px;
            background: transparent;
            border: none;
            border-radius: 6px;
            transition: all 0.3s ease;
            font-size: 12px;
            font-weight: 500;
            color: #495057;
        }

        .toggle-label::before {
            content: '';
            width: 24px;
            height: 12px;
            background: #dee2e6;
            border-radius: 12px;
            margin-right: 6px;
            position: relative;
            transition: all 0.3s ease;
        }

        .toggle-label::after {
            content: '';
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            position: absolute;
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
            transition: all 0.3s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .toggle-switch input:checked + .toggle-label {
            background: transparent;
            border: none;
            color: #495057;
        }

        .toggle-switch input:checked + .toggle-label::before {
            background: #28a745;
        }

        .toggle-switch input:checked + .toggle-label::after {
            left: 20px;
        }

        .toggle-label:hover {
            background: transparent;
        }

        .toggle-switch input:checked + .toggle-label:hover {
            background: transparent;
        }

        .moves-toggle-icon {
            padding: 0;
            background: transparent;
            border: none;
        }

        .toggle-icon {
            width: 36px;
            height: 36px;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s ease;
            background: transparent;
        }

        .toggle-icon:hover {
            background: #f0f0f0;
        }

        .moves-toggle-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            flex-shrink: 0;
        }

        /* Confetti styles */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #ff6b6b;
            animation: confetti-fall 3s linear infinite;
            z-index: 9999;
        }

        .confetti:nth-child(2n) {
            background: #4ecdc4;
            animation-delay: 0.1s;
        }

        .confetti:nth-child(3n) {
            background: #45b7d1;
            animation-delay: 0.2s;
        }

        .confetti:nth-child(4n) {
            background: #96ceb4;
            animation-delay: 0.3s;
        }

        .confetti:nth-child(5n) {
            background: #feca57;
            animation-delay: 0.4s;
        }

        .confetti:nth-child(6n) {
            background: #ff9ff3;
            animation-delay: 0.5s;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Game completion indicator */
        .completion-indicator {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #4CAF50;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            font-weight: bold;
            z-index: 10;
            animation: completionPulse 2s ease-in-out infinite;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
            opacity: 1;
        }

        @keyframes completionPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 4px 12px rgba(76, 175, 80, 0.6);
            }
        }

        /* Custom Game Valid Move Highlighting */
        .valid-move {
            background-color: rgba(0, 255, 0, 0.3) !important;
            outline: 2px solid #00ff00;
            outline-offset: -2px;
        }

        .valid-move:hover {
            background-color: rgba(0, 255, 0, 0.5) !important;
        }

        /* Delete Game Button - Subtle Version */
        .delete-game-btn-subtle {
            background: #f8f9fa;
            color: #6c757d;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .delete-game-btn-subtle:hover {
            background: #e9ecef;
            color: #495057;
            border-color: #adb5bd;
        }

        .delete-game-btn-subtle:active {
            transform: scale(0.98);
        }


        /* Custom Game Info Section Styles */
        .custom-game-info-section {
            margin-bottom: 15px;
        }

        .custom-game-info-section .game-header {
            background: #ffffff;
            color: #333333;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            border: 1px solid #e0e0e0;
            box-shadow: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .custom-game-info-section .game-header:hover {
            background: #f5f5f5;
            border-color: #cccccc;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .custom-game-info-section .game-header::after {
            content: 'â–¼';
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.2s ease;
            font-size: 0.8rem;
            color: #666666;
        }

        .custom-game-info-section .game-header.expanded::after {
            transform: translateY(-50%) rotate(180deg);
        }

        .custom-game-info-section .game-details {
            background-color: #f8f9fa;
            border: none;
            border-radius: 0 0 6px 6px;
            margin-top: 0;
            max-height: 0;
            overflow: hidden;
            padding: 0 1rem;
            transition: max-height 0.4s ease, padding 0.4s ease, margin 0.4s ease;
        }

        .custom-game-info-section .game-details.show {
            max-height: 600px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .custom-game-info-section #custom-game-title-input {
            background: none;
            border: none;
            text-align: center;
            font-size: inherit;
            font-weight: inherit;
            color: inherit;
            width: 100%;
            outline: none;
            font-family: inherit;
            padding: 0;
            margin: 0;
        }

        .custom-game-info-section #custom-game-title-input:focus {
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #3498db;
            border-radius: 4px;
            padding: 2px 6px;
        }

        .custom-game-info-section #custom-game-title-input::placeholder {
            color: #999;
            font-style: italic;
        }

        .custom-game-info-section #custom-game-title-input:invalid {
            border: 1px solid #e74c3c;
        }

        /* Custom Detail Input Styles */
        .custom-detail-input {
            background: #ffffff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 13px;
            font-family: inherit;
            color: #333;
            width: 100%;
            max-width: 200px;
            transition: border-color 0.2s ease;
        }

        .custom-detail-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .custom-detail-input[readonly] {
            background: #f8f9fa;
            color: #6c757d;
            cursor: not-allowed;
        }

        .custom-detail-select {
            background: #ffffff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 13px;
            font-family: inherit;
            color: #333;
            width: 100%;
            max-width: 200px;
            transition: border-color 0.2s ease;
            cursor: pointer;
        }

        .custom-detail-select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e9ecef;
        }

        .detail-item:last-child {
            border-bottom: none;
        }

        @media (max-width: 900px) {
            .bottom-section {
                flex-direction: column;
                gap: 1rem;
                align-items: center;
            }
            
            .left-panel {
                flex: none;
                width: 100%;
                max-width: 500px;
                margin-left: 40px;
            }
            
            .right-panel {
                flex: none;
                width: 100%;
                max-width: 600px;
                margin-left: 15px;
            }
            
            .game-buttons {
                padding: 1.25rem;
                margin-left: 1rem;
            }
            
            .game-content {
                flex-direction: column;
                align-items: center;
                gap: 2rem;
            }
            
            .chess-board {
                width: 400px;
                height: 400px;
            }
            
            .board-coordinates {
                grid-template-columns: 400px 20px;
                grid-template-rows: 400px 20px;
            }
            
            .visual-modes {
                width: 400px;
            }
            
            .moves-panel {
                width: 360px;
                max-height: 470px;
            }
            
            .chess-piece {
                width: 46px;
                height: 46px;
            }
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <a href="index.html" class="logo">
            <div class="logo-icon">â™Ÿï¸</div>
            <span>Blind Chess</span>
        </a>
                <ul class="nav-links">
                    <li><a href="index.html">Home</a></li>
                <li><a href="games.html" class="active">Games</a></li>
                <li><a href="puzzles.html">Puzzles</a></li>
                <li><a href="leaderboard.html">Leaderboard</a></li>
                <li class="subscription-tab-li"><a href="subscription.html" id="subscriptionTab">Subscription</a></li>
                    <li class="profile-dropdown">
                        <a href="#" id="profileLink" class="profile-button">Profile</a>
            <div class="dropdown-menu" id="profileDropdown">
                <a href="profile.html" class="dropdown-item" id="profileMenuItem">
                    <span class="dropdown-text">My Profile</span>
                </a>
                <a href="#" class="dropdown-item" id="accountInfoMenuItem" style="display: none;">
                    <span class="dropdown-text">Account Information</span>
                </a>
                <a href="#" class="dropdown-item" id="signInMenuItem">
                    <span class="dropdown-text">Sign In</span>
                </a>
                <a href="#" class="dropdown-item" id="logoutMenuItem" style="display: none;">
                    <span class="dropdown-text">Logout</span>
                </a>
            </div>
                    </li>
                </ul>
    </nav>

    <div class="main-layout">
        <!-- Top Section: Games Tabs -->
        <div class="top-section">
                <div class="games-tabs">
                    <div class="tab active" data-tab="difficulty">By Difficulty</div>
                    <div class="tab" data-tab="gm-games">By GMs</div>
                    <div class="tab" data-tab="my-games">My Games</div>
                </div>
        </div>

        <!-- Bottom Section: Left and Right Panels -->
        <div class="bottom-section">
            <!-- Left Side: Game Selection -->
            <div class="left-panel">
                <!-- Tab Content -->
                <div class="tab-content">
                <!-- Games by Difficulty Tab -->
                <div class="tab-panel active" id="difficulty-panel">
                    <div class="game-buttons">
            <div class="game-button-container">
                <a href="#short-games" class="game-button active" id="short-games-btn">
                    <div>Fundamental Games</div>
                    <div class="description">Essential chess patterns</div>
                </a>
                <div class="submenu" id="short-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            <div class="game-button-container">
                <a href="#medium-games" class="game-button" id="medium-games-btn">
                    <div>Tactical Games</div>
                    <div class="description">Combinations and tactics</div>
                </a>
                <div class="submenu" id="medium-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            <div class="game-button-container">
                <a href="#long-games" class="game-button" id="long-games-btn">
                <div>Strategic Games</div>
                <div class="description">Positional mastery</div>
            </a>
                <div class="submenu" id="long-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            <div class="game-button-container">
                <a href="#epic-games" class="game-button" id="epic-games-btn">
                    <div>Master Games</div>
                    <div class="description">Legendary masterpieces</div>
                </a>
                <div class="submenu" id="epic-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            </div>
        </div>

        <!-- My Games Tab -->
        <div class="tab-panel" id="my-games-panel">
            <div class="game-buttons">
            <div class="game-button-container">
                <a href="#my-games" class="game-button active" id="my-games-my-games-btn">
                <div>Custom</div>
                <div class="description">Your saved games</div>
            </a>
                <div class="submenu" id="my-games-my-games-submenu">
                    <!-- Custom games will be populated dynamically -->
                </div>
            </div>
            </div>
        </div>

        <!-- Games by GM Tab -->
        <div class="tab-panel" id="gm-games-panel">
            <div class="game-buttons">
            <div class="game-button-container">
                <a href="#short-games" class="game-button active" id="gm-games-short-games-btn">
                    <div>Fundamental Games</div>
                    <div class="description">Essential chess patterns</div>
                </a>
                <div class="submenu" id="gm-games-short-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            <div class="game-button-container">
                <a href="#medium-games" class="game-button" id="gm-games-medium-games-btn">
                    <div>Tactical Games</div>
                    <div class="description">Combinations and tactics</div>
                </a>
                <div class="submenu" id="gm-games-medium-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            <div class="game-button-container">
                <a href="#long-games" class="game-button" id="gm-games-long-games-btn">
                <div>Strategic Games</div>
                <div class="description">Positional mastery</div>
            </a>
                <div class="submenu" id="gm-games-long-games-submenu">
                    <!-- Games will be populated dynamically -->
                </div>
            </div>
            <a href="#epic-games" class="game-button" id="gm-games-epic-games-btn">
                <div>Master Games</div>
                <div class="description">Legendary masterpieces</div>
            </a>
            <div class="game-button-container">
                <a href="#my-games" class="game-button" id="gm-games-my-games-btn">
                <div>My Games</div>
                <div class="description">Your saved games</div>
            </a>
                <div class="submenu" id="gm-games-my-games-submenu">
                    <!-- Custom games will be populated dynamically -->
                </div>
            </div>
            </div>
        </div>
        </div>
        </div>

            <!-- Right Side: Board and Moves -->
            <div class="right-panel">
            <main class="main-content">
            <div class="game-display" id="game-display">
                <div class="game-content">
                    <div class="board-section">
                        <div class="board-container">
                            <div class="board-coordinates">
                                <div class="chess-board" id="chess-board">
                                    <!-- Chess board will be generated by JavaScript -->
                                </div>
                                
                                <!-- Rank notation to the right of the board -->
                                <div class="rank-notation">
                                    <div class="notation-number">8</div>
                                    <div class="notation-number">7</div>
                                    <div class="notation-number">6</div>
                                    <div class="notation-number">5</div>
                                    <div class="notation-number">4</div>
                                    <div class="notation-number">3</div>
                                    <div class="notation-number">2</div>
                                    <div class="notation-number">1</div>
                                </div>
                            </div>
                            
                            <!-- Square notation below the board -->
                            <div class="board-notation">
                                <div class="notation-letter">a</div>
                                <div class="notation-letter">b</div>
                                <div class="notation-letter">c</div>
                                <div class="notation-letter">d</div>
                                <div class="notation-letter">e</div>
                                <div class="notation-letter">f</div>
                                <div class="notation-letter">g</div>
                                <div class="notation-letter">h</div>
                            </div>
                        </div>
                         <div class="visual-modes">
                             <div class="mode-option active" data-mode="normal">Normal</div>
                             <div class="mode-option" data-mode="grey">Black</div>
                             <div class="mode-option" data-mode="checkers">Checkers</div>
                             <div class="mode-option" data-mode="empty">Empty</div>
                             <button class="test-btn" id="challenge-btn">Test</button>
                         </div>
                     </div>
                    <div class="moves-panel" id="moves-panel">
                        <div class="game-header" id="game-header" style="display: none;">
                            <div class="game-title-line" id="game-title-line">Select a Game</div>
                        </div>
                        <div class="game-details" id="game-details">
                            <div class="detail-item">
                                <span class="detail-label">Description:</span>
                                <span class="detail-value" id="detail-description">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Moves:</span>
                                <span class="detail-value" id="detail-moves">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">White Player:</span>
                                <span class="detail-value" id="detail-white">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Black Player:</span>
                                <span class="detail-value" id="detail-black">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Opening:</span>
                                <span class="detail-value" id="detail-opening">-</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Difficulty:</span>
                                <span class="detail-value" id="detail-difficulty">-</span>
                            </div>
                            <div class="detail-facts">
                                <div class="facts-title">Interesting Facts:</div>
                                <div class="facts-text" id="detail-facts">-</div>
                            </div>
                        </div>
                        
                        <!-- Custom Game Information Tab (shown in Add Game mode) -->
                        <div id="custom-game-info" class="custom-game-info-section" style="display: none;">
                            <div class="game-header" id="custom-game-header">
                                <div class="game-title-line" id="custom-game-title-line">
                                    <input type="text" id="custom-game-title-input" value="" placeholder="Enter title" maxlength="25" required style="background: none; border: none; text-align: center; font-size: inherit; font-weight: inherit; color: inherit; width: 100%; outline: none;">
                                </div>
                            </div>
                            <div class="game-details" id="custom-game-details">
                                <div class="detail-item">
                                    <span class="detail-label">Description:</span>
                                    <input type="text" id="custom-detail-description" class="custom-detail-input" placeholder="Enter description..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Moves:</span>
                                    <input type="text" id="custom-detail-moves" class="custom-detail-input" value="0" readonly>
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">White Player:</span>
                                    <input type="text" id="custom-detail-white" class="custom-detail-input" placeholder="Enter white player name..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Black Player:</span>
                                    <input type="text" id="custom-detail-black" class="custom-detail-input" placeholder="Enter black player name..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Opening:</span>
                                    <input type="text" id="custom-detail-opening" class="custom-detail-input" placeholder="Enter opening name..." maxlength="25">
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Result:</span>
                                    <select id="custom-detail-result" class="custom-detail-select">
                                        <option value="In progress">In progress</option>
                                        <option value="1-0">1-0 (White wins)</option>
                                        <option value="0-1">0-1 (Black wins)</option>
                                        <option value="1/2-1/2">1/2-1/2 (Draw)</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        
                        <div class="move-controls">
                            <div class="move-icon flip-board-icon" id="flip-board-btn" title="Flip board perspective"><img src="images/switch-camera.png" alt="Flip Board" style="width: 20px; height: 20px;"></div>
                            <div class="move-icon" id="btn-initial" title="Go to initial position"><img src="images/fast-forward.png" alt="Initial" style="width: 20px; height: 20px; transform: scaleX(-1);"></div>
                            <div class="move-icon" id="btn-back" title="Previous move"><img src="images/next.png" alt="Back" style="width: 20px; height: 20px; transform: scaleX(-1);"></div>
                            <div class="move-icon" id="btn-forward" title="Next move"><img src="images/next.png" alt="Next" style="width: 20px; height: 20px;"></div>
                            <div class="move-icon" id="btn-final" title="Go to final position"><img src="images/fast-forward.png" alt="Last" style="width: 20px; height: 20px;"></div>
                            <div class="moves-toggle-icon" id="moves-toggle" style="display: none;">
                                <img src="images/hide.png" class="toggle-icon" id="moves-toggle-img" alt="Toggle moves visibility" title="Toggle moves visibility">
                        </div>
                        </div>
                        
                        <!-- Play Color Selection -->
                        <div id="play-color-section" style="display: none; margin: 10px 0; padding: 10px 0; text-align: center;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 15px; font-size: 14px; color: #34495e;">
                                <span style="font-weight: 500;">Play for:</span>
                                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                    <input type="radio" name="play-color" value="white" style="margin: 0;">
                                    <span>White</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                    <input type="radio" name="play-color" value="black" style="margin: 0;">
                                    <span>Black</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                    <input type="radio" name="play-color" value="both" checked style="margin: 0;">
                                    <span>Both</span>
                                </label>
                            </div>
                        </div>
                        
                        <div id="moves-list" style="max-height: 300px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 8px; padding: 10px; background: #fff;">
                            <p style="text-align: center; color: #7f8c8d;">Select a game to view moves</p>
                        </div>
                        
                        <!-- Comment Section -->
                        <div id="comment-section" style="display: none; margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #3498db;">
                            <div id="comment-content" style="color: #34495e; line-height: 1.4; font-size: 13px; text-align: left;">
                                Click on any move to see detailed commentary
                            </div>
                        </div>
                        
                    <!-- Delete Game Button (only for custom games) -->
                    <div id="delete-game-section" style="display: none; margin-top: 15px; text-align: center;">
                        <button id="delete-game-btn" class="delete-game-btn-subtle" title="Delete this custom game">
                            Delete Game
                        </button>
                    </div>


                    </div>
                </div>
            </div>
        </main>
        </div>
        </div>
    </div>

    <!-- Completion Badge -->
    <div class="badge-overlay" id="badge-overlay"></div>
    <div class="completion-badge" id="completion-badge">
        <div class="badge-icon"><img src="images/check.png" alt="Complete" style="width: 56px; height: 56px;"></div>
        <div class="badge-title">Challenge Complete!</div>
        <div class="badge-subtitle">You successfully completed the memory challenge</div>
        <button class="badge-close" onclick="hideBadge()">Continue</button>
    </div>

    <script src="chess-move-parser.js?v=2"></script>
    <script src="custom-games.js"></script>
    <script src="progress-tracker.js"></script>
    <script>
        // GameLoader class to handle loading games from files
        class GameLoader {
            static async loadGamesFromFiles() {
                try {
                    console.log('Loading games from files...');
                    
                    // Load both games.json and custom games from API
                    const isProduction = !window.location.hostname.includes('localhost') && !window.location.hostname.includes('127.0.0.1');
                    const customApiUrl = isProduction ? '/api/get-games' : 'http://localhost:3001/get-games';
                    const [gamesResponse, customGamesResponse] = await Promise.all([
                        fetch(`games/games.json?t=${Date.now()}`),
                        fetch(customApiUrl)
                    ]);
                    
                    let allGames = [];
                    
                    // Load main games
                    if (gamesResponse.ok) {
                        const gamesData = await gamesResponse.json();
                        if (gamesData.games && Array.isArray(gamesData.games)) {
                            allGames = allGames.concat(gamesData.games);
                            console.log(`Loaded ${gamesData.games.length} games from games.json`);
                        }
                    } else {
                        console.warn('Could not load games.json:', gamesResponse.status);
                    }
                    
                    // Load custom games
                    if (customGamesResponse.ok) {
                        const customGamesData = await customGamesResponse.json();
                        if (customGamesData.games && Array.isArray(customGamesData.games)) {
                            allGames = allGames.concat(customGamesData.games);
                            console.log(`Loaded ${customGamesData.games.length} custom games from custom-games.json`);
                        }
                    } else {
                        console.warn('Could not load custom-games.json:', customGamesResponse.status);
                    }
                    
                    console.log(`Total games loaded: ${allGames.length}`);
                    console.log('Games with locked status:', allGames.map(g => ({ name: g.name, locked: g.locked })));
                    return { games: allGames };
                    
                } catch (error) {
                    console.error('Error loading games:', error);
                    return { games: [] };
                }
            }
        }
    </script>
    <script>
        // Global variables for move navigation
        let currentGame = null;
         let currentMoveIndex = 0;
         let currentVisualMode = 'normal';
         let boardFlipped = false;
         let draggedPiece = null;
         let draggedFromSquare = null;
         let validMoves = [];
         let isChallengeMode = false;
         let completedChallenges = new Set(); // Track completed challenges
         
         // Load completed challenges from progress tracker
         function loadCompletedChallenges() {
             return progressTracker.getAllCompletedChallengesSet();
         }
         let selectedPiece = null; // Track clicked/selected piece
         let selectedSquare = null; // Track selected square
         
         // Initialize progress tracker
         let progressTracker = new ProgressTracker();
         
         // Initialize the move parser
         const moveParser = new ChessMoveParser();
        
        // Audio objects for sound effects - using your custom sound file
        const customSound = new Audio('sounds/click-21156.mp3');
        
        // Function to play sound effects - using your custom sound file
        function playSound(isCapture) {
            try {
                // Reset the sound to the beginning and play
                customSound.currentTime = 0;
                customSound.play().catch(error => {
                    console.log('Sound play failed:', error);
                });
            } catch (error) {
                console.log('Could not play sound:', error);
            }
        }

        // Load games data dynamically
        let gamesData = null;
        
        // Check login status and update navigation
        function updateNavigation() {
            const profileLink = document.getElementById('profileLink');
            const profileMenuItem = document.getElementById('profileMenuItem');
            const accountInfoMenuItem = document.getElementById('accountInfoMenuItem');
            const signInMenuItem = document.getElementById('signInMenuItem');
            const logoutMenuItem = document.getElementById('logoutMenuItem');
            const subscriptionTab = document.getElementById('subscriptionTab');
            const isLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
            const hasActiveSubscription = localStorage.getItem('hasActiveSubscription') === 'true';
            
            // Show/hide subscription tab based on subscription status
            const subscriptionLi = document.querySelector('.subscription-tab-li');
            if (hasActiveSubscription) {
                subscriptionLi.classList.add('hidden-for-subscriber');
            } else {
                subscriptionLi.classList.remove('hidden-for-subscriber');
            }
            
            if (isLoggedIn) {
                // User is logged in - show profile, account info, and logout options
                profileMenuItem.style.display = 'flex';
                accountInfoMenuItem.style.display = 'flex';
                logoutMenuItem.style.display = 'flex';
                signInMenuItem.style.display = 'none';
                
                // Set up profile menu item
                profileMenuItem.onclick = function(e) {
                    e.preventDefault();
                    window.location.href = 'profile.html';
                };
                
                // Set up account info menu item
                accountInfoMenuItem.onclick = function(e) {
                    e.preventDefault();
                    showAccountInfoModal();
                };
                
                // Set up logout menu item
                logoutMenuItem.onclick = function(e) {
                    e.preventDefault();
                    logout();
                };
                
                // Profile icon click - go to profile
                profileLink.onclick = function(e) {
                    e.preventDefault();
                    window.location.href = 'profile.html';
                };
            } else {
                // User is not logged in - show sign in option
                profileMenuItem.style.display = 'none';
                accountInfoMenuItem.style.display = 'none';
                logoutMenuItem.style.display = 'none';
                signInMenuItem.style.display = 'flex';
                
                // Set up sign in menu item
                signInMenuItem.onclick = function(e) {
                    e.preventDefault();
                    showSignInModal();
                };
                
                // Profile icon click - show sign in modal
                profileLink.onclick = function(e) {
                    e.preventDefault();
                    showSignInModal();
                };
            }
        }

        // Show account information modal
        function showAccountInfoModal() {
            const userName = localStorage.getItem('userName') || 'User';
            const userEmail = localStorage.getItem('userEmail') || 'No email provided';
            const subscriptionPlan = localStorage.getItem('subscriptionPlan') || 'free';
            
            // Format subscription display
            let subscriptionDisplay = 'Free Account';
            if (subscriptionPlan === 'monthly') {
                subscriptionDisplay = 'Premium Monthly';
            } else if (subscriptionPlan === 'quarterly') {
                subscriptionDisplay = 'Premium Quarterly';
            } else if (subscriptionPlan === 'monthly_cancelled') {
                subscriptionDisplay = 'Premium Monthly (Cancelled)';
            } else if (subscriptionPlan === 'quarterly_cancelled') {
                subscriptionDisplay = 'Premium Quarterly (Cancelled)';
            }
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Account Information</h2>
                        <span class="close" onclick="closeModal()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="account-info">
                            <div class="info-item">
                                <label>Name:</label>
                                <span>${userName}</span>
                            </div>
                            <div class="info-item">
                                <label>Email:</label>
                                <span>${userEmail}</span>
                            </div>
                            <div class="info-item">
                                <label>Subscription:</label>
                                <span>${subscriptionDisplay}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.style.display = 'block';
        }

        // Logout function - shows confirmation modal
        function logout() {
            document.getElementById('logoutConfirmModal').style.display = 'block';
        }

        // Confirm logout function
        function confirmLogout() {
            // Clear user data and localStorage
            localStorage.removeItem('isLoggedIn');
            localStorage.removeItem('userName');
            localStorage.removeItem('userEmail');
            localStorage.removeItem('subscriptionPlan');
            localStorage.removeItem('hasActiveSubscription');
            
            // Update navigation
            updateNavigation();
            
            // Hide modal
            document.getElementById('logoutConfirmModal').style.display = 'none';
            
            // Redirect to home page
            window.location.href = 'index.html';
        }

        // Cancel logout function
        function cancelLogout() {
            document.getElementById('logoutConfirmModal').style.display = 'none';
        }

        // Subscription Required Modal functions
        function showSubscriptionRequiredModal() {
            document.getElementById('subscriptionRequiredModal').style.display = 'block';
        }

        function closeSubscriptionModal() {
            document.getElementById('subscriptionRequiredModal').style.display = 'none';
        }

        function goToSubscription() {
            window.location.href = 'subscription.html';
        }

        // Modal functions
        function showSignInModal() {
            document.getElementById('signInModal').style.display = 'block';
            document.getElementById('registerModal').style.display = 'none';
        }

        function showRegisterModal() {
            document.getElementById('registerModal').style.display = 'block';
            document.getElementById('signInModal').style.display = 'none';
        }

        function closeModal() {
            // Close static modals
            const signInModal = document.getElementById('signInModal');
            const registerModal = document.getElementById('registerModal');
            const logoutConfirmModal = document.getElementById('logoutConfirmModal');
            const subscriptionRequiredModal = document.getElementById('subscriptionRequiredModal');
            if (signInModal) signInModal.style.display = 'none';
            if (registerModal) registerModal.style.display = 'none';
            if (logoutConfirmModal) logoutConfirmModal.style.display = 'none';
            if (subscriptionRequiredModal) subscriptionRequiredModal.style.display = 'none';
            
            // Close dynamically created modals
            const dynamicModals = document.querySelectorAll('.modal');
            dynamicModals.forEach(modal => {
                if (modal.id !== 'signInModal' && modal.id !== 'registerModal') {
                    modal.remove();
                }
            });
        }

        // Sign in form handler
        function handleSignIn(event) {
            event.preventDefault();
            const email = document.getElementById('signInEmail').value;
            const password = document.getElementById('signInPassword').value;
            
            // Check if user exists in localStorage
            const storedEmail = localStorage.getItem('userEmail');
            const storedPassword = localStorage.getItem('userPassword');
            
            if (email === storedEmail && password === storedPassword) {
                localStorage.setItem('isLoggedIn', 'true');
                updateNavigation();
                closeModal();
                window.location.href = 'profile.html';
            }
        }

        // Register form handler
        function handleRegister(event) {
            event.preventDefault();
            const email = document.getElementById('registerEmail').value;
            const password = document.getElementById('registerPassword').value;
            const name = document.getElementById('registerName').value;
            
            // Check if email already exists
            const existingEmail = localStorage.getItem('userEmail');
            if (existingEmail === email) {
                showSignInModal();
                return;
            }
            
            // Create new account
            localStorage.setItem('isLoggedIn', 'true');
            localStorage.setItem('userEmail', email);
            localStorage.setItem('userName', name);
            localStorage.setItem('userPassword', password);
            updateNavigation();
            closeModal();
            window.location.href = 'profile.html';
        }

        // Google sign-in handler
        function signInWithGoogle() {
            // Simulate Google OAuth flow (replace with actual Google OAuth implementation)
            const mockGoogleUser = {
                email: 'user@gmail.com',
                name: 'Google User',
                id: 'google_' + Math.random().toString(36).substr(2, 9)
            };
            
            // Check if user exists in localStorage
            const storedEmail = localStorage.getItem('userEmail');
            const storedPassword = localStorage.getItem('userPassword');
            
            if (storedEmail === mockGoogleUser.email && storedPassword === mockGoogleUser.id) {
                // User exists, sign them in
                localStorage.setItem('isLoggedIn', 'true');
                updateNavigation();
                closeModal();
                window.location.href = 'profile.html';
            } else {
                // User doesn't exist, create account
                localStorage.setItem('isLoggedIn', 'true');
                localStorage.setItem('userEmail', mockGoogleUser.email);
                localStorage.setItem('userName', mockGoogleUser.name);
                localStorage.setItem('userPassword', mockGoogleUser.id);
                localStorage.setItem('authProvider', 'google');
                updateNavigation();
                closeModal();
                window.location.href = 'profile.html';
            }
        }

        // Google registration handler
        function registerWithGoogle() {
            // Simulate Google OAuth flow (replace with actual Google OAuth implementation)
            const mockGoogleUser = {
                email: 'user@gmail.com',
                name: 'Google User',
                id: 'google_' + Math.random().toString(36).substr(2, 9)
            };
            
            // Check if user already exists
            const existingEmail = localStorage.getItem('userEmail');
            if (existingEmail === mockGoogleUser.email) {
                showSignInModal();
                return;
            }
            
            // Create account with Google data
            localStorage.setItem('isLoggedIn', 'true');
            localStorage.setItem('userEmail', mockGoogleUser.email);
            localStorage.setItem('userName', mockGoogleUser.name);
            localStorage.setItem('userPassword', mockGoogleUser.id); // Use Google ID as password
            localStorage.setItem('authProvider', 'google');
            updateNavigation();
            closeModal();
            window.location.href = 'profile.html';
        }
        
        // Initialize tabs functionality
        function initializeTabs() {
            console.log('Initializing tabs...');
            const tabs = document.querySelectorAll('.games-tabs .tab');
            const panels = document.querySelectorAll('.tab-panel');
            
            console.log('Found tabs:', tabs.length);
            console.log('Found panels:', panels.length);
            
            tabs.forEach((tab, index) => {
                console.log(`Setting up tab ${index}:`, tab.textContent, tab.dataset.tab);
                tab.addEventListener('click', (e) => {
                    console.log('Tab clicked:', tab.textContent, tab.dataset.tab);
                    e.preventDefault();
                    
                    // Remove active class from all tabs and panels
                    tabs.forEach(t => t.classList.remove('active'));
                    panels.forEach(p => p.classList.remove('active'));
                    
                    // Add active class to clicked tab
                    tab.classList.add('active');
                    
                    // Show corresponding panel
                    const tabId = tab.dataset.tab;
                    const panel = document.getElementById(`${tabId}-panel`);
                    console.log('Looking for panel:', `${tabId}-panel`, panel);
                    if (panel) {
                        panel.classList.add('active');
                        console.log('Panel activated:', panel.id);
                    } else {
                        console.error('Panel not found:', `${tabId}-panel`);
                    }
                    
                    // All tabs now use the same game functionality
                    // Games are loaded automatically by updateGameButtons()
                });
            });
        }

        // All tabs now use the same game functionality
        // The loadMyGamesContent and loadGMGamesContent functions are no longer needed
        // since all tabs display the same game categories

        // Initialize games data on page load
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('DOM loaded, loading games...');
            
            // Initialize tabs
            initializeTabs();
            
            try {
                gamesData = await GameLoader.loadGamesFromFiles();
                console.log('Loaded games:', gamesData);
                console.log('Number of games loaded:', gamesData ? gamesData.games.length : 0);
                
                // Custom games are now loaded through GameLoader.loadGamesFromFiles()
                // No need for direct fallback loading
            } catch (error) {
                console.error('Error loading games:', error);
                gamesData = { games: [] };
            }
            
            // Load completed challenges from progress tracker
            completedChallenges = loadCompletedChallenges();
            console.log('Loaded completed challenges:', completedChallenges);
            
            // Update the game buttons display
            updateGameButtons();
            updateNavigation();
            
            // Update completion badges after games are loaded
            updateGameListBadges();
            
            // Set up training timer click detection
            setupTrainingTimer();
            
            // Add event listeners for forms
            document.getElementById('signInForm').addEventListener('submit', handleSignIn);
            document.getElementById('registerForm').addEventListener('submit', handleRegister);
            
            // Add event listeners for close buttons
            document.querySelectorAll('.close').forEach(closeBtn => {
                closeBtn.addEventListener('click', closeModal);
            });
            
            // Close modal when clicking outside
            window.addEventListener('click', function(event) {
                const signInModal = document.getElementById('signInModal');
                const registerModal = document.getElementById('registerModal');
                const logoutConfirmModal = document.getElementById('logoutConfirmModal');
                const subscriptionRequiredModal = document.getElementById('subscriptionRequiredModal');
                if (event.target === signInModal) {
                    closeModal();
                }
                if (event.target === registerModal) {
                    closeModal();
                }
                if (event.target === logoutConfirmModal) {
                    closeModal();
                }
                if (event.target === subscriptionRequiredModal) {
                    closeModal();
                }
            });
        });
        
        // Set up training timer for piece movements
        function setupTrainingTimer() {
            // Training timer will be started when pieces are moved
            // (handled in movePiece and movePieceDirectly functions)
            
            // Reset idle timer on any user activity
            document.addEventListener('mousemove', function() {
                if (progressTracker.trainingTimer.isRunning) {
                    progressTracker.resetTrainingIdleTimer();
                }
            });
            
            document.addEventListener('keydown', function() {
                if (progressTracker.trainingTimer.isRunning) {
                    progressTracker.resetTrainingIdleTimer();
                }
            });
            
            // Stop training timer when leaving the page
            window.addEventListener('beforeunload', function() {
                progressTracker.stopTrainingTimer();
            });
        }

        // Function to reload games data
        async function reloadGamesData() {
            try {
                console.log('ðŸ”„ Reloading games data...');
                gamesData = await GameLoader.loadGamesFromFiles();
                console.log('ðŸ“Š Reloaded games:', gamesData);
                console.log('ðŸ“Š Total games loaded:', gamesData ? gamesData.games.length : 0);
                console.log('ðŸ“Š Custom games:', gamesData ? gamesData.games.filter(g => g.id.startsWith('custom-game-')).length : 0);
                updateGameButtons();
                console.log('âœ… Game buttons updated');
            } catch (error) {
                console.error('âŒ Error reloading games:', error);
            }
        }
        
        // Function to clear the chess board - remove all pieces
        function clearChessBoard() {
            console.log('Clearing chess board...');
            
            // Clear all squares on the board
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.querySelector(`[data-square="${String.fromCharCode(97 + j)}${8 - i}"]`);
                    if (square) {
                        square.innerHTML = '';
                    }
                }
            }
            
            // Clear any selection or highlights on the board
            document.querySelectorAll('.selected').forEach(element => {
                element.classList.remove('selected');
            });
            document.querySelectorAll('.valid-move').forEach(element => {
                element.classList.remove('valid-move');
            });
            document.querySelectorAll('.last-move').forEach(element => {
                element.classList.remove('last-move');
            });
            
            console.log('Chess board cleared');
        }

        // Function to clear only custom game elements (not the entire right section)
        function clearCustomGameElements() {
            console.log('Clearing custom game elements...');
            
            // Hide custom game info section
            const customGameInfo = document.getElementById('custom-game-info');
            if (customGameInfo) {
                customGameInfo.style.display = 'none';
            }
            
            // Hide custom commentary section
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            
            // Hide custom save button and message
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }
            
            // Clear the chess board - remove all pieces
            clearChessBoard();
            
            console.log('Custom game elements cleared');
        }

        // Function to clear the right section (moves section)
        function clearRightSection() {
            console.log('Clearing right section...');
            
            // Clear the moves list
            const movesList = document.getElementById('moves-list');
            if (movesList) {
                movesList.innerHTML = '';
                movesList.style.display = 'none';
            }
            
            // Hide game info sections
            const gameHeader = document.getElementById('game-header');
            const gameDetails = document.getElementById('game-details');
            if (gameHeader) {
                gameHeader.style.display = 'none';
            }
            if (gameDetails) {
                gameDetails.style.display = 'none';
            }
            
            // Hide custom game info section
            const customGameInfo = document.getElementById('custom-game-info');
            if (customGameInfo) {
                customGameInfo.style.display = 'none';
            }
            
            // Hide comment section
            const commentSection = document.getElementById('comment-section');
            if (commentSection) {
                commentSection.style.display = 'none';
            }
            
            // Hide delete game section
            const deleteGameSection = document.getElementById('delete-game-section');
            if (deleteGameSection) {
                deleteGameSection.style.display = 'none';
            }
            
            // Hide custom commentary section
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            
            // Hide custom save button and message
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }
            
            // Reset move buttons
            const btnInitial = document.getElementById('btn-initial');
            const btnBack = document.getElementById('btn-back');
            const btnForward = document.getElementById('btn-forward');
            const btnFinal = document.getElementById('btn-final');
            
            if (btnInitial) btnInitial.classList.add('disabled');
            if (btnBack) btnBack.classList.add('disabled');
            if (btnForward) btnForward.classList.add('disabled');
            if (btnFinal) btnFinal.classList.add('disabled');
            
            // Clear any highlights
            document.querySelectorAll('.clickable-move').forEach(span => {
                span.classList.remove('active-move');
            });
            document.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                section.classList.remove('clicked');
            });
            
            // Clear the chess board - remove all pieces
            clearChessBoard();
            
            console.log('Right section cleared');
        }

        // Function to delete a custom game
        async function deleteCustomGame(event, gameId) {
            event.stopPropagation(); // Prevent the game from being selected
            
            try {
                console.log('ðŸ—‘ï¸ Deleting custom game:', gameId);
                const isProduction = !window.location.hostname.includes('localhost') && !window.location.hostname.includes('127.0.0.1');
                const apiUrl = isProduction ? `/api/delete-game?id=${gameId}` : `http://localhost:3001/delete-game/${gameId}`;
                const response = await fetch(apiUrl, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const result = await response.json();
                console.log('ðŸ“¡ Delete response:', result);
                
                if (result.success) {
                    console.log('âœ… Game deleted successfully from server');
                    
                    // Clear the right section (moves section) after successful deletion
                    clearRightSection();
                    
                    console.log('ðŸ”„ Reloading games data...');
                    // Reload the games data to update the display
                    await reloadGamesData();
                    console.log('âœ… Games data reloaded');
                } else {
                    console.error('âŒ Failed to delete game:', result.message);
                }
            } catch (error) {
                console.error('âŒ Error deleting game:', error);
            }
        }


        // Make functions globally accessible
        window.reloadGamesData = reloadGamesData;
        window.updateGameButtons = updateGameButtons;
        window.deleteCustomGame = deleteCustomGame;

        // Function to update game buttons display
        function updateGameButtons() {
            console.log('Updating game buttons...');
            if (!gamesData || !gamesData.games) {
                console.log('No games data available');
                return;
            }
            
            // Group games by category
            const shortGames = gamesData.games.filter(g => g.moves <= 10 && !g.id.startsWith('custom-game-'));
            const mediumGames = gamesData.games.filter(g => g.moves > 10 && g.moves <= 30 && !g.id.startsWith('custom-game-'));
            const longGames = gamesData.games.filter(g => g.moves > 30 && !g.id.startsWith('custom-game-'));
            const customGames = gamesData.games.filter(g => g.id.startsWith('custom-game-'));
            
            console.log('=== GAME CATEGORIZATION DEBUG ===');
            console.log('Total games loaded:', gamesData.games.length);
            console.log('Short games:', shortGames.length, shortGames.map(g => ({ name: g.name, locked: g.locked })));
            console.log('Medium games:', mediumGames.length, mediumGames.map(g => ({ name: g.name, locked: g.locked })));
            console.log('Long games:', longGames.length, longGames.map(g => ({ name: g.name, locked: g.locked })));
            console.log('Custom games:', customGames.length);
            console.log('Custom games details:', customGames);
            console.log('All games IDs:', gamesData.games.map(g => g.id));
            console.log('Custom game IDs:', customGames.map(g => g.id));
            console.log('Custom games for My Games tab:', customGames.filter(g => g.id.startsWith('custom-game-')));
            
            // Update all tabs with the same game data
            const tabPrefixes = ['', 'my-games-', 'gm-games-'];
            
            tabPrefixes.forEach(prefix => {
                // Update short games
                updateGameCategory(prefix + 'short-games-submenu', shortGames);
                // Update medium games  
                updateGameCategory(prefix + 'medium-games-submenu', mediumGames);
                // Update long games
                updateGameCategory(prefix + 'long-games-submenu', longGames);
                // Update custom games
                updateGameCategory(prefix + 'my-games-submenu', customGames);
            });
            
            // Update the My Games tab's custom submenu specifically
            updateGameCategory('my-games-my-games-submenu', customGames);
        }
        
        function updateGameCategory(categoryId, games) {
            console.log(`Updating category ${categoryId} with ${games.length} games`);
            console.log(`Games for ${categoryId}:`, games.map(g => ({ id: g.id, name: g.name })));
            const categoryElement = document.getElementById(categoryId);
            if (!categoryElement) {
                console.error(`Category element not found: ${categoryId}`);
                return;
            }
            
            // Clear existing content
            categoryElement.innerHTML = '';
            
            games.forEach(game => {
                const gameButton = document.createElement('a');
                gameButton.href = '#';
                gameButton.className = 'submenu-button';
                gameButton.setAttribute('data-game-id', game.id);
                
                // Check if user has active subscription
                const hasActiveSubscription = localStorage.getItem('hasActiveSubscription') === 'true';
                const isGameLocked = game.locked && !hasActiveSubscription;
                
                // Add locked class if game is locked and user doesn't have subscription
                if (isGameLocked) {
                    gameButton.classList.add('locked');
                }
                
                gameButton.onclick = (e) => {
                    e.preventDefault();
                    if (isGameLocked) {
                        // Show subscription required modal
                        showSubscriptionRequiredModal();
                        return;
                    }
                    displayGame(game.id);
                };
                
                let buttonContent = `
                    <span>${game.name}</span>
                    <span class="game-completion-badge" data-game="${game.id}"><img src="images/check.png" alt="Complete" style="width: 20px; height: 20px;"></span>
                `;
                
                // Add lock overlay if game is locked and user doesn't have subscription
                if (isGameLocked) {
                    buttonContent += `
                        <div class="lock-overlay">
                            <div class="lock-icon">ðŸ”’</div>
                        </div>
                    `;
                }
                
                gameButton.innerHTML = buttonContent;
                
                categoryElement.appendChild(gameButton);
            });
            
            // Add "Add Game" button to short games submenu
            
            // Add "Add Game" button to my games submenu
            if (categoryId === 'my-games-submenu' || categoryId === 'my-games-my-games-submenu') {
                const addGameButton = document.createElement('a');
                addGameButton.href = '#';
                addGameButton.className = 'submenu-button';
                addGameButton.id = 'add-game-my-btn';
                
                // Check if user has active subscription
                const hasActiveSubscription = localStorage.getItem('hasActiveSubscription') === 'true';
                const isAddGameLocked = !hasActiveSubscription;
                
                // Add locked class if user doesn't have subscription
                if (isAddGameLocked) {
                    addGameButton.classList.add('locked');
                }
                
                addGameButton.onclick = (e) => {
                    e.preventDefault();
                    
                    if (isAddGameLocked) {
                        // Show subscription required modal
                        showSubscriptionRequiredModal();
                        return;
                    }
                    
                    initializeCustomGameMode();
                };
                
                let buttonContent = `
                    <span>+ Add Game</span>
                `;
                
                // Add lock overlay if add game is locked
                if (isAddGameLocked) {
                    buttonContent += `
                        <div class="lock-overlay">
                            <div class="lock-icon">ðŸ”’</div>
                        </div>
                    `;
                }
                
                addGameButton.innerHTML = buttonContent;
                
                categoryElement.appendChild(addGameButton);
            }
        }
        
        // Function to reset the board to starting position
        function resetBoard() {
            // Clear all squares
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.querySelector(`[data-square="${String.fromCharCode(97 + j)}${8 - i}"]`);
                    if (square) {
                        square.innerHTML = '';
                    }
                }
            }
            
            // Reset piece positions in parser
            moveParser.resetBoard();
            
            // Set up starting position
            setupStartingPosition();
        }
        
        function setupStartingPosition() {
            // White pieces
            const whitePieces = {
                'a1': 'Chess_rlt45.svg.png', 'b1': 'Chess_nlt45.svg.png', 'c1': 'Chess_blt45.svg.png', 'd1': 'Chess_qlt45.svg.png',
                'e1': 'Chess_klt45.svg.png', 'f1': 'Chess_blt45.svg.png', 'g1': 'Chess_nlt45.svg.png', 'h1': 'Chess_rlt45.svg.png',
                'a2': 'Chess_plt45.svg.png', 'b2': 'Chess_plt45.svg.png', 'c2': 'Chess_plt45.svg.png', 'd2': 'Chess_plt45.svg.png',
                'e2': 'Chess_plt45.svg.png', 'f2': 'Chess_plt45.svg.png', 'g2': 'Chess_plt45.svg.png', 'h2': 'Chess_plt45.svg.png'
            };
            
            // Black pieces
            const blackPieces = {
                'a8': 'Chess_rdt45.svg.png', 'b8': 'Chess_ndt45.svg.png', 'c8': 'Chess_bdt45.svg.png', 'd8': 'Chess_qdt45.svg.png',
                'e8': 'Chess_kdt45.svg.png', 'f8': 'Chess_bdt45.svg.png', 'g8': 'Chess_ndt45.svg.png', 'h8': 'Chess_rdt45.svg.png',
                'a7': 'Chess_pdt45.svg.png', 'b7': 'Chess_pdt45.svg.png', 'c7': 'Chess_pdt45.svg.png', 'd7': 'Chess_pdt45.svg.png',
                'e7': 'Chess_pdt45.svg.png', 'f7': 'Chess_pdt45.svg.png', 'g7': 'Chess_pdt45.svg.png', 'h7': 'Chess_pdt45.svg.png'
            };
            
            // Place white pieces
            Object.entries(whitePieces).forEach(([square, piece]) => {
                const squareElement = document.querySelector(`[data-square="${square}"]`);
                if (squareElement) {
                    const pieceElement = createDraggablePiece(piece, square);
                    squareElement.appendChild(pieceElement);
                }
            });
            
            // Place black pieces
            Object.entries(blackPieces).forEach(([square, piece]) => {
                const squareElement = document.querySelector(`[data-square="${square}"]`);
                if (squareElement) {
                    const pieceElement = createDraggablePiece(piece, square);
                    squareElement.appendChild(pieceElement);
                }
            });
        }
        

        // Initialize chess board
        function generateCoordinateLabels() {
            const bottomLabels = document.getElementById('coordinate-labels-bottom');
            const rightLabels = document.getElementById('coordinate-labels-right');
            
            // Clear existing labels
            bottomLabels.innerHTML = '';
            rightLabels.innerHTML = '';
            
            // Generate letter labels (a-h) for bottom
            const letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            
            for (let i = 0; i < 8; i++) {
                const bottomLabel = document.createElement('div');
                const displayLetter = boardFlipped ? letters[7 - i] : letters[i];
                
                bottomLabel.className = 'coordinate-label letter';
                bottomLabel.textContent = displayLetter;
                
                bottomLabels.appendChild(bottomLabel);
            }
            
            // Generate number labels (1-8) for right
            const numbers = ['8', '7', '6', '5', '4', '3', '2', '1'];
            
            for (let i = 0; i < 8; i++) {
                const rightLabel = document.createElement('div');
                const displayNumber = boardFlipped ? numbers[7 - i] : numbers[i];
                
                rightLabel.className = 'coordinate-label number';
                rightLabel.textContent = displayNumber;
                
                rightLabels.appendChild(rightLabel);
            }
        }

        function initializeChessBoard() {
            const board = document.getElementById('chess-board');
            board.innerHTML = '';
            
            // Create 64 squares (8x8)
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    
                    // Calculate square color based on actual chess position
                    let actualRow, actualCol;
                    if (boardFlipped) {
                        // When flipped, we want to show the board from black's perspective
                        actualRow = 7 - row;  // Flip rows
                        actualCol = 7 - col;  // Flip columns
                    } else {
                        actualRow = row;
                        actualCol = col;
                    }
                    
                    const isLight = (actualRow + actualCol) % 2 === 0;
                    square.className = `chess-square ${isLight ? 'light' : 'dark'}`;
                    
                    // Convert row/col to chess notation (a1, b1, etc.)
                    // When flipped, reverse the row and column order
                    let file, rank;
                    if (boardFlipped) {
                        file = String.fromCharCode(97 + (7 - col)); // h, g, f, etc. when flipped
                        rank = row + 1; // 1, 2, 3, etc. when flipped
                    } else {
                        file = String.fromCharCode(97 + col); // a, b, c, etc.
                        rank = 8 - row; // 8, 7, 6, etc.
                    }
                    square.dataset.square = file + rank;
                    
                    // Add drop event listeners
                    square.addEventListener('dragover', handleDragOver);
                    square.addEventListener('drop', handleDrop);
                    
                    // Add click event listener
                    square.addEventListener('click', handleSquareClick);
                    
                    board.appendChild(square);
                }
            }
        }

        // Set up initial board position
        function setupInitialPosition() {
            const board = document.getElementById('chess-board');
            const squares = board.querySelectorAll('.chess-square');
            
            // Clear all pieces
            squares.forEach(square => {
                square.innerHTML = '';
            });

            // Only set up pieces if a game is selected
            if (currentGame) {
                let initialPosition;
                
                // Check if the game has a custom initial position
                if (currentGame.initial_position) {
                    initialPosition = currentGame.initial_position;
                } else {
                    // Use standard starting position
                    initialPosition = {
                        // Black pieces
                        'a8': 'Chess_rdt45.svg.png', 'b8': 'Chess_ndt45.svg.png', 'c8': 'Chess_bdt45.svg.png', 'd8': 'Chess_qdt45.svg.png',
                        'e8': 'Chess_kdt45.svg.png', 'f8': 'Chess_bdt45.svg.png', 'g8': 'Chess_ndt45.svg.png', 'h8': 'Chess_rdt45.svg.png',
                        'a7': 'Chess_pdt45.svg.png', 'b7': 'Chess_pdt45.svg.png', 'c7': 'Chess_pdt45.svg.png', 'd7': 'Chess_pdt45.svg.png',
                        'e7': 'Chess_pdt45.svg.png', 'f7': 'Chess_pdt45.svg.png', 'g7': 'Chess_pdt45.svg.png', 'h7': 'Chess_pdt45.svg.png',
                        
                        // White pieces
                        'a1': 'Chess_rlt45.svg.png', 'b1': 'Chess_nlt45.svg.png', 'c1': 'Chess_blt45.svg.png', 'd1': 'Chess_qlt45.svg.png',
                        'e1': 'Chess_klt45.svg.png', 'f1': 'Chess_blt45.svg.png', 'g1': 'Chess_nlt45.svg.png', 'h1': 'Chess_rlt45.svg.png',
                        'a2': 'Chess_plt45.svg.png', 'b2': 'Chess_plt45.svg.png', 'c2': 'Chess_plt45.svg.png', 'd2': 'Chess_plt45.svg.png',
                        'e2': 'Chess_plt45.svg.png', 'f2': 'Chess_plt45.svg.png', 'g2': 'Chess_plt45.svg.png', 'h2': 'Chess_plt45.svg.png'
                    };
                }

                // Place pieces on their corresponding squares
                Object.entries(initialPosition).forEach(([squareNotation, pieceImage]) => {
                    if (pieceImage && pieceImage !== '') { // Only place pieces if there's an image and it's not empty
                        const square = board.querySelector(`[data-square="${squareNotation}"]`);
                        if (square) {
                            const pieceElement = createDraggablePiece(pieceImage, squareNotation);
                            square.appendChild(pieceElement);
                        }
                    }
                });
            }
        }

        // Helper function to get square notation from index
        function getSquareNotation(index) {
            const row = Math.floor(index / 8);
            const col = index % 8;
            
            // When flipped, we need to calculate notation differently
            if (boardFlipped) {
                const file = String.fromCharCode(97 + (7 - col));
                const rank = row + 1;
                return file + rank;
            } else {
                return String.fromCharCode(97 + col) + (8 - row);
            }
        }

        // Create a draggable piece element
        function createDraggablePiece(pieceImage, squareNotation) {
            const pieceElement = document.createElement('div');
            pieceElement.className = 'chess-piece';
            pieceElement.style.backgroundImage = `url('pieces/${pieceImage}')`;
            pieceElement.draggable = true;
            pieceElement.dataset.piece = pieceImage;
            pieceElement.dataset.square = squareNotation;
            
            // Add drag event listeners
            pieceElement.addEventListener('dragstart', handleDragStart);
            pieceElement.addEventListener('dragend', handleDragEnd);
            
            // Add click event listener
            pieceElement.addEventListener('click', handlePieceClick);
            
            // Apply current visual mode to the new piece
            applyVisualModeToPiece(pieceElement, currentVisualMode);
            
            // Make invisible if in challenge mode
            if (isChallengeMode) {
                pieceElement.style.opacity = '0';
            }
            
            return pieceElement;
        }

        // Update piece square notation when moved
        function updatePieceSquare(pieceElement, newSquare) {
            pieceElement.dataset.square = newSquare;
        }

        // Re-initialize drag and drop for all pieces on the board
        function reinitializeDragAndDrop() {
            const pieces = document.querySelectorAll('.chess-piece');
            pieces.forEach((piece, index) => {
                // Remove existing event listeners
                piece.removeEventListener('dragstart', handleDragStart);
                piece.removeEventListener('dragend', handleDragEnd);
                piece.removeEventListener('click', handlePieceClick);
                
                // Re-add event listeners
                piece.addEventListener('dragstart', handleDragStart);
                piece.addEventListener('dragend', handleDragEnd);
                piece.addEventListener('click', handlePieceClick);
                
                // Ensure piece is draggable
                piece.draggable = true;
            });
            
            // Also re-setup drop event listeners for squares
            const squares = document.querySelectorAll('.chess-square');
            squares.forEach(square => {
                // Remove existing event listeners
                square.removeEventListener('dragover', handleDragOver);
                square.removeEventListener('drop', handleDrop);
                square.removeEventListener('click', handleSquareClick);
                
                // Re-add event listeners
                square.addEventListener('dragover', handleDragOver);
                square.addEventListener('drop', handleDrop);
                square.addEventListener('click', handleSquareClick);
            });
        }

        // Handle drag start
        function handleDragStart(e) {
            console.log('Target:', e.target);
            console.log('Custom game mode:', typeof customGameMode !== 'undefined' ? customGameMode : 'undefined');
            console.log('Window custom game mode:', typeof window.customGameMode !== 'undefined' ? window.customGameMode : 'undefined');
            
            draggedPiece = e.target;
            draggedFromSquare = e.target.dataset.square;
            
            // Add dragging class to disable transitions on piece and board
            e.target.classList.add('dragging');
            const board = document.getElementById('chess-board');
            board.classList.add('dragging');
            console.log('Added dragging class to piece, classes now:', e.target.classList.toString());
            console.log('Added dragging class to board, classes now:', board.classList.toString());
            
            // Highlight valid moves
            highlightValidMoves();
            
            // Create a custom drag image with consistent size
            const dragImage = e.target.cloneNode(true);
            dragImage.style.width = '60px';
            dragImage.style.height = '60px';
            dragImage.style.position = 'absolute';
            dragImage.style.top = '-1000px';
            dragImage.style.left = '-1000px';
            
            // Apply current visual mode to drag image
            if (currentVisualMode === 'empty' || isChallengeMode) {
                dragImage.style.opacity = '0'; // Keep invisible in empty mode or challenge mode
            } else {
                dragImage.style.opacity = '1';
            }
            
            document.body.appendChild(dragImage);
            
            e.dataTransfer.setDragImage(dragImage, 30, 30);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
            
            // Clean up the drag image after a short delay
            setTimeout(() => {
                if (dragImage.parentNode) {
                    dragImage.parentNode.removeChild(dragImage);
                }
            }, 0);
            
            // Keep original piece invisible in empty mode or challenge mode, otherwise semi-transparent
            if (currentVisualMode === 'empty' || isChallengeMode) {
                e.target.style.opacity = '0';
            } else {
                e.target.style.opacity = '0.5';
            }
        }

        // Handle drag end
        function handleDragEnd(e) {
            console.log('Target:', e.target);
            console.log('Target current square:', e.target.dataset.square);
            console.log('Dragged from square:', draggedFromSquare);
            console.log('Custom game mode:', typeof customGameMode !== 'undefined' ? customGameMode : 'undefined');
            console.log('Window custom game mode:', typeof window.customGameMode !== 'undefined' ? window.customGameMode : 'undefined');
            console.log('Valid moves at drag end:', validMoves);
            
            // Check if the piece is still in the same position (hasn't been moved)
            const isStillInOriginalPosition = e.target.dataset.square === draggedFromSquare;
            console.log('Piece still in original position:', isStillInOriginalPosition);
            
            // Check if a move was actually completed by looking for a piece at the destination
            let moveWasCompleted = false;
            if (draggedFromSquare && validMoves.length > 0) {
                // Check if any of the valid move squares now have a piece
                validMoves.forEach(squareNotation => {
                    const square = getSquareByNotation(squareNotation);
                    if (square && square.querySelector('.chess-piece')) {
                        moveWasCompleted = true;
                        console.log('Move was completed - found piece at', squareNotation);
                    }
                });
            }
            console.log('Move was completed:', moveWasCompleted);
            
            // Remove dragging class to re-enable transitions
            e.target.classList.remove('dragging');
            const board = document.getElementById('chess-board');
            board.classList.remove('dragging');
            console.log('Removed dragging class from piece, classes now:', e.target.classList.toString());
            console.log('Removed dragging class from board, classes now:', board.classList.toString());
            
            // Clear highlights
            clearHighlights();
            
            // Only restore opacity if the piece is still in its original position AND no move was completed
            // If it was moved, the new piece already has the correct opacity
            if (isStillInOriginalPosition && !moveWasCompleted) {
                console.log('Restoring opacity for unmoved piece');
                // Restore piece opacity based on current visual mode or challenge mode
                if (currentVisualMode === 'empty' || isChallengeMode) {
                    e.target.style.opacity = '0';
                } else {
                    e.target.style.opacity = '1';
                }
            } else if (moveWasCompleted) {
                console.log('Move was completed - not restoring opacity for original piece');
                // Hide the original piece since it was moved
                e.target.style.opacity = '0';
                
                // Check if we should autoplay the next move after a manual move
                // Note: currentMoveIndex has already been incremented in the move validation logic
                const selectedColor = window.selectedPlayColor || 'both';
                if (selectedColor !== 'both' && currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                    const nextMove = currentGame.moves_detailed[currentMoveIndex];
                    const isNextWhiteMove = !!nextMove.white;
                    const shouldAutoplayNext = (selectedColor === 'white' && !isNextWhiteMove) || 
                                             (selectedColor === 'black' && isNextWhiteMove);
                    
                    console.log('Manual move completed - checking autoplay:', {
                        selectedColor,
                        currentMoveIndex,
                        nextMove: nextMove.white || nextMove.black,
                        isNextWhiteMove,
                        shouldAutoplayNext
                    });
                    
                    if (shouldAutoplayNext) {
                        console.log('Auto-playing next move after manual move');
                        setTimeout(() => {
                            goToNextMove();
                        }, 300); // Short delay after manual move
                    }
                }
            } else {
                console.log('Piece was moved, skipping opacity restoration');
            }
            
            // Reset drag variables
            draggedPiece = null;
            draggedFromSquare = null;
        }

        // Handle piece click (for click-to-select)
        function handlePieceClick(e) {
            e.stopPropagation(); // Prevent square click from firing
            
            const piece = e.target;
            const square = piece.parentElement;
            const squareNotation = getSquareNotationFromElement(square);
            
            console.log('Piece clicked on square:', squareNotation);
            
            // Clear previous selection
            clearSelection();
            
            // Select this piece
            selectedPiece = piece;
            selectedSquare = squareNotation;
            
            // Calculate valid moves for this piece
            draggedPiece = piece; // Temporarily set for move calculation
            draggedFromSquare = squareNotation;
            calculateValidMoves();
            
            // Show selection highlight (only in normal mode)
            if (!isChallengeMode) {
                console.log('Adding selected class to square:', square);
                square.classList.add('selected');
                console.log('Square classes after adding selected:', square.className);
                
                // Show valid move highlights too
                validMoves.forEach(moveSquare => {
                    const validSquare = getSquareByNotation(moveSquare);
                    if (validSquare) {
                        validSquare.classList.add('valid-move');
                    }
                });
            }
            
            console.log('Piece selected. Valid moves:', validMoves);
        }

        // Handle square click (for click-to-move)
        function handleSquareClick(e) {
            const clickedSquare = e.target;
            const clickedSquareNotation = getSquareNotationFromElement(clickedSquare);
            
            console.log('Square clicked:', clickedSquareNotation);
            const pieceOnSquare = clickedSquare.querySelector('.chess-piece');
            console.log('Square has piece:', pieceOnSquare !== null);
            
            // If there's a piece on this square and no piece is currently selected, select this piece
            if (pieceOnSquare && (!selectedPiece || !selectedSquare)) {
                console.log('Selecting piece on clicked square');
                handlePieceClick({ target: pieceOnSquare, stopPropagation: () => {} });
                return;
            }
            
            // If no piece is selected, do nothing
            if (!selectedPiece || !selectedSquare) {
                console.log('No piece selected');
                return;
            }
            
            // Check if this is a valid move
            if (validMoves.includes(clickedSquareNotation)) {
                console.log('Valid move! Moving from', selectedSquare, 'to', clickedSquareNotation);
                
                // Execute the move
                movePieceDirectly(selectedSquare, clickedSquareNotation, selectedPiece.dataset.piece);
                
                // Reset idle timer after move
                progressTracker.resetIdleTimer();
                
                // Update game state
                if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                    currentMoveIndex++;
                    updateMoveButtons();
                    highlightCurrentMove();
                    
                    // Check if this is the final move and trigger completion indicator
                    if (currentMoveIndex >= currentGame.moves_detailed.length) {
                        setTimeout(() => {
                            showCompletionIndicator();
                        }, 200);
                    }
                    
                    // Update comment section with current move info
                    const move = currentGame.moves_detailed[currentMoveIndex - 1];
                    const moveNotation = move.white || move.black;
                    showMoveCommentary(move.description, moveNotation, move);
                    
                    checkChallengeProgress();
                }
                
                // Clear selection
                clearSelection();
                
                // Reinitialize drag and drop
                setTimeout(() => {
                    reinitializeDragAndDrop();
                }, 100);
            } else {
                console.log('Invalid move to', clickedSquareNotation);
                // Clear selection on invalid move
                clearSelection();
            }
        }

        // Clear piece selection and highlights
        function clearSelection() {
            // Clear visual highlights
            const selectedSquares = document.querySelectorAll('.chess-square.selected');
            selectedSquares.forEach(square => square.classList.remove('selected'));
            
            clearHighlights();
            
            // Clear selection variables
            selectedPiece = null;
            selectedSquare = null;
            draggedPiece = null;
            draggedFromSquare = null;
            validMoves = [];
        }

        // Calculate valid moves for current piece
        function calculateValidMoves() {
            if (!currentGame || currentMoveIndex >= currentGame.moves_detailed.length) {
                validMoves = [];
                return;
            }
            
            const currentMove = currentGame.moves_detailed[currentMoveIndex];
            const isWhiteMove = !!currentMove.white;
            
            // Debug: Log all properties of the move object
            console.log('Move object keys:', Object.keys(currentMove));
            console.log('Move object values:', Object.values(currentMove));
            console.log('white_to field:', currentMove.white_to);
            console.log('black_to field:', currentMove.black_to);
            
            // Check if the dragged piece is the correct piece for this move
            const expectedFrom = isWhiteMove ? currentMove.white_from : currentMove.black_from;
            const expectedTo = isWhiteMove ? currentMove.white_to : currentMove.black_to;
            
            console.log('Move validation:', {
                gameId: currentGame.id,
                gameName: currentGame.name,
                totalMoves: currentGame.moves_detailed.length,
                moveIndex: currentMoveIndex,
                move: currentMove.white || currentMove.black,
                isWhiteMove,
                expectedFrom,
                expectedTo,
                draggedFrom: draggedFromSquare,
                rawMove: currentMove
            });
            
            if (draggedFromSquare !== expectedFrom) {
                console.log('Wrong piece! Expected on', expectedFrom, 'but dragged from', draggedFromSquare);
                validMoves = [];
                return;
            }
            
            // Set valid destination square
            validMoves = [expectedTo];
            console.log('Valid moves set to:', validMoves);
        }

        // Highlight valid moves for current piece (only in normal mode)
        function highlightValidMoves() {
            // Calculate valid moves first
            calculateValidMoves();
            
            // Don't highlight moves in challenge mode - pure memory test
            if (isChallengeMode) {
                console.log('Challenge mode active - no move highlighting');
                return;
            }
            
            // Highlight valid squares
            validMoves.forEach(squareNotation => {
                const square = getSquareByNotation(squareNotation);
                if (square) {
                    square.classList.add('valid-move');
                    console.log('Highlighted square:', squareNotation);
                }
            });
        }


        // Clear move highlights
        function clearHighlights() {
            const squares = document.querySelectorAll('.chess-square');
            squares.forEach(square => {
                square.classList.remove('valid-move');
            });
        }

        // Handle drag over
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation(); // Prevent event bubbling to avoid infinite loops
            e.dataTransfer.dropEffect = 'move';
            
            // Only process if we're dragging over a square, not a piece
            if (e.target.classList.contains('chess-piece')) {
                return; // Don't process dragover events on pieces
            }
            
            
            if (e.target.classList.contains('chess-square')) {
                const squareNotation = getSquareNotationFromElement(e.target);
            }
        }

        // Handle drop
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation(); // Prevent event bubbling
            
            
            if (!draggedPiece || !draggedFromSquare) {
                console.log('No dragged piece or from square');
                return;
            }
            
            // Find the square element (not the piece)
            let toSquare = e.target;
            console.log('Initial toSquare:', toSquare);
            
            // If we dropped on a piece, get its parent square
            if (toSquare.classList.contains('chess-piece')) {
                console.log('Dropped on piece, getting parent square');
                toSquare = toSquare.parentElement;
                console.log('Parent square:', toSquare);
            }
            
            // Make sure we have a square element
            if (!toSquare.classList.contains('chess-square')) {
                console.log('Not a valid square element:', toSquare);
                return;
            }
            
            const toSquareNotation = getSquareNotationFromElement(toSquare);
            console.log('Destination square notation:', toSquareNotation);
            console.log('Is valid move?', validMoves.includes(toSquareNotation));
            
            // Check if trying to drop on the same square
            if (toSquareNotation === draggedFromSquare) {
                console.log('Cannot drop on the same square!');
                return;
            }
            
            // Check if this is a valid move
            if (validMoves.includes(toSquareNotation)) {
                console.log('Valid move! Executing move from', draggedFromSquare, 'to', toSquareNotation);
                
                // Move the piece directly without animation since it's already being dragged
                movePieceDirectly(draggedFromSquare, toSquareNotation, draggedPiece.dataset.piece);
                
                // Reset idle timer after move
                progressTracker.resetIdleTimer();
                
                 // Advance to next move
                 if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                     currentMoveIndex++;
                     updateMoveButtons();
                     highlightCurrentMove();
                     
                     // Check if this is the final move and trigger completion indicator
                     if (currentMoveIndex >= currentGame.moves_detailed.length) {
                         setTimeout(() => {
                             showCompletionIndicator();
                         }, 200);
                     }
                     
                     // Update comment section with current move info
                     const move = currentGame.moves_detailed[currentMoveIndex - 1];
                     const moveNotation = move.white || move.black;
                     showMoveCommentary(move.description, moveNotation, move);
                     
                     // Check challenge progress
                     checkChallengeProgress();
                 }
                 
                 // Small delay to ensure the move is processed, then re-initialize
                 setTimeout(() => {
                     reinitializeDragAndDrop();
                 }, 100);
            } else {
                console.log('Invalid move! Cannot drop on', toSquareNotation);
            }
        }

        // Get square notation from element
        function getSquareNotationFromElement(squareElement) {
            // Get the notation directly from the data-square attribute
            return squareElement.dataset.square;
        }

        // Execute a move (either by drag or button)
        function executeMove(from, to, piece) {
            // Move the piece with animation
            movePiece(from, to, piece, true);
            
            // Advance to next move
            if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                currentMoveIndex++;
                updateMoveButtons();
            }
        }

        // Move piece directly without animation (for drag and drop)
        function movePieceDirectly(from, to, piece) {
            // Start training timer on piece movement
            progressTracker.startTrainingTimer();
            
            console.log('=== MOVE PIECE DIRECTLY DEBUG ===');
            console.log('Moving piece from', from, 'to', to);
            const fromSquare = getSquareByNotation(from);
            const toSquare = getSquareByNotation(to);
            
            if (fromSquare && toSquare) {
                // Debug square dimensions BEFORE any changes
                const fromRectBefore = fromSquare.getBoundingClientRect();
                const toRectBefore = toSquare.getBoundingClientRect();
                console.log('BEFORE CHANGES:');
                console.log('From square dimensions:', {
                    width: fromRectBefore.width,
                    height: fromRectBefore.height,
                    classes: fromSquare.classList.toString()
                });
                console.log('To square dimensions:', {
                    width: toRectBefore.width,
                    height: toRectBefore.height,
                    classes: toSquare.classList.toString()
                });
                
                // Ensure board is in dragging state to disable transitions
                const board = document.getElementById('chess-board');
                board.classList.add('dragging');
                console.log('Added dragging class to board');
                console.log('Board classes after adding dragging:', board.classList.toString());
                
                // Check if transitions are actually disabled
                const computedStyle = window.getComputedStyle(toSquare);
                const transition = computedStyle.transition;
                console.log('To square transition property:', transition);
                
                // Clear valid-move class from ALL squares BEFORE making changes
                // This prevents size changes during the move operation
                clearHighlights();
                console.log('Cleared all highlights');
                
                // Debug square dimensions AFTER clearing highlights
                const fromRectAfterHighlights = fromSquare.getBoundingClientRect();
                const toRectAfterHighlights = toSquare.getBoundingClientRect();
                console.log('AFTER CLEARING HIGHLIGHTS:');
                console.log('From square dimensions:', {
                    width: fromRectAfterHighlights.width,
                    height: fromRectAfterHighlights.height,
                    classes: fromSquare.classList.toString()
                });
                console.log('To square dimensions:', {
                    width: toRectAfterHighlights.width,
                    height: toRectAfterHighlights.height,
                    classes: toSquare.classList.toString()
                });
                
                // Clear source square completely
                fromSquare.innerHTML = '';
                console.log('Cleared source square');
                
                // Debug square dimensions AFTER clearing source
                const fromRectAfterClear = fromSquare.getBoundingClientRect();
                console.log('AFTER CLEARING SOURCE:');
                console.log('From square dimensions:', {
                    width: fromRectAfterClear.width,
                    height: fromRectAfterClear.height,
                    classes: fromSquare.classList.toString()
                });
                
                // Clear destination square (in case there's a piece to capture)
                toSquare.innerHTML = '';
                console.log('Cleared destination square');
                
                // Debug square dimensions AFTER clearing destination
                const toRectAfterClear = toSquare.getBoundingClientRect();
                console.log('AFTER CLEARING DESTINATION:');
                console.log('To square dimensions:', {
                    width: toRectAfterClear.width,
                    height: toRectAfterClear.height,
                    classes: toSquare.classList.toString()
                });
                
                // Create new piece at destination
                const pieceElement = createDraggablePiece(piece, to);
                toSquare.appendChild(pieceElement);
                console.log('Added piece to destination');
                
                // Debug square dimensions AFTER adding piece
                const toRectAfterPiece = toSquare.getBoundingClientRect();
                console.log('AFTER ADDING PIECE:');
                console.log('To square dimensions:', {
                    width: toRectAfterPiece.width,
                    height: toRectAfterPiece.height,
                    classes: toSquare.classList.toString()
                });
                
                // Remove dragging class after a short delay to re-enable transitions
                setTimeout(() => {
                    board.classList.remove('dragging');
                    console.log('Removed dragging class from board');
                    
                    // Final debug after removing dragging class
                    const toRectFinal = toSquare.getBoundingClientRect();
                    console.log('FINAL DIMENSIONS:');
                    console.log('To square dimensions:', {
                        width: toRectFinal.width,
                        height: toRectFinal.height,
                        classes: toSquare.classList.toString()
                    });
                }, 50);
                
                console.log('Move completed');
                
                // Play move sound effect
                playSound(false);
            } else {
                console.log('Invalid squares - from:', fromSquare, 'to:', toSquare);
            }
            console.log('=== END MOVE PIECE DIRECTLY ===');
        }



        // Animate existing piece from source to destination
        function animateExistingPiece(sourceSquare, destinationSquare, pieceImage) {
            // Get the existing piece from source square
            const existingPiece = sourceSquare.querySelector('.chess-piece');
            if (!existingPiece) return;

            // Get the chess board container
            const board = document.getElementById('chess-board');
            
            // Create a temporary piece for animation
            const tempPiece = existingPiece.cloneNode(true);
            tempPiece.style.position = 'absolute';
            tempPiece.style.zIndex = '1000';
            tempPiece.style.pointerEvents = 'none';
            tempPiece.style.width = '60px';
            tempPiece.style.height = '60px';
            tempPiece.style.transition = 'all 0.3s ease-in-out';

            // Get positions
            const sourceRect = sourceSquare.getBoundingClientRect();
            const destRect = destinationSquare.getBoundingClientRect();
            const boardRect = board.getBoundingClientRect();

            // Calculate positions relative to the board
            const sourceLeft = sourceRect.left - boardRect.left;
            const sourceTop = sourceRect.top - boardRect.top;
            const destLeft = destRect.left - boardRect.left;
            const destTop = destRect.top - boardRect.top;

            // Position the temp piece at source
            tempPiece.style.left = sourceLeft + 'px';
            tempPiece.style.top = sourceTop + 'px';

            // Add to board
            board.appendChild(tempPiece);

            // Remove the original piece immediately to prevent double pieces
            sourceSquare.innerHTML = '';

            // Animate to destination
            requestAnimationFrame(() => {
                tempPiece.style.left = destLeft + 'px';
                tempPiece.style.top = destTop + 'px';
            });

            // After animation, place piece in destination square and clean up
            setTimeout(() => {
                // Remove temp piece
                if (tempPiece.parentNode) {
                    tempPiece.parentNode.removeChild(tempPiece);
                }

                // Clear destination square completely before placing new piece
                destinationSquare.innerHTML = '';
                
                // Create a new draggable piece at destination
                const newPiece = createDraggablePiece(pieceImage, getSquareNotationFromElement(destinationSquare));
                destinationSquare.appendChild(newPiece);
                
                // Play sound after animation completes
                playSound(false);
                
                // Re-initialize drag and drop for all pieces
                reinitializeDragAndDrop();
            }, 300);
        }

        // Show move commentary
        function showMoveCommentary(commentary, move, moveData) {
            // Update the comment content
            const commentContent = document.getElementById('comment-content');
            
            if (commentContent && moveData) {
                const moveNumber = moveData.move_number;
                const player = moveData.white ? 'White' : 'Black';
                const annotation = moveData.annotation || '';
                // Use description first, fallback to commentary if description is empty
                const description = moveData.description || moveData.commentary || '';
                
                let content = `<strong>Move ${moveNumber} (${player}):</strong> ${convertToChessSymbols(move)} ${annotation}`;
                if (description) {
                    content += `<br>${description}`;
                }
                
                commentContent.innerHTML = content;
            } else if (commentContent) {
                commentContent.innerHTML = `<strong>Move ${convertToChessSymbols(move)}:</strong><br>${commentary}`;
            }
        }

        // Display game moves
        function displayGameMoves(game) {
            const movesList = document.getElementById('moves-list');
            movesList.innerHTML = '';
            
            // Reset comment section when displaying new game
            const commentContent = document.getElementById('comment-content');
            if (commentContent) {
                commentContent.innerHTML = 'Click on any move to see detailed commentary';
            }

            // Group moves by move number (white and black moves together)
            const moveGroups = {};
            game.moves_detailed.forEach(move => {
                if (!moveGroups[move.move_number]) {
                    moveGroups[move.move_number] = { white: null, black: null };
                }
                if (move.white) {
                    moveGroups[move.move_number].white = move.white;
                }
                if (move.black) {
                    moveGroups[move.move_number].black = move.black;
                }
            });

            // Display all moves in a structured layout
            const moveItem = document.createElement('div');
            moveItem.className = 'move-item';
            
            // Create move numbers and moves
            Object.keys(moveGroups).forEach((moveNumber, moveIndex) => {
                const group = moveGroups[moveNumber];
                
                // Create move row
                const moveRow = document.createElement('div');
                moveRow.className = 'move-row';
                
                // Add move number to the row
                const moveNumberSpan = document.createElement('span');
                moveNumberSpan.textContent = moveNumber + '.';
                moveNumberSpan.className = 'move-number';
                moveRow.appendChild(moveNumberSpan);
                
                // Create white moves container
                const whiteMoves = document.createElement('div');
                whiteMoves.className = 'white-moves';
                
                // Create black moves container
                const blackMoves = document.createElement('div');
                blackMoves.className = 'black-moves';
                
                // Add white move if it exists
                if (group.white) {
                    const whiteMoveSpan = document.createElement('span');
                    whiteMoveSpan.textContent = convertToChessSymbols(group.white);
                    whiteMoveSpan.className = 'clickable-move';
                    whiteMoveSpan.dataset.moveIndex = moveIndex * 2;
                    
                    // Find the move data for annotations
                    const whiteMoveData = game.moves_detailed.find(m => m.white === group.white && m.move_number == moveNumber);
                    if (whiteMoveData) {
                        // Add annotation if it exists
                        if (whiteMoveData.annotation) {
                            const annotationSpan = document.createElement('span');
                            annotationSpan.textContent = whiteMoveData.annotation;
                            annotationSpan.className = 'move-annotation';
                            annotationSpan.style.marginLeft = '4px';
                            annotationSpan.style.color = '#000000';
                            whiteMoveSpan.appendChild(annotationSpan);
                        }
                        
                    }
                    
                    whiteMoves.appendChild(whiteMoveSpan);
                }
                
                // Add click listener to entire white-moves div
                whiteMoves.addEventListener('click', function() {
                    if (group.white) {
                        currentMoveIndex = moveIndex * 2 + 1;
                        updateBoardPosition();
                        updateMoveButtons();
                        
                        // Check if this is the final move and trigger completion indicator
                        if (currentMoveIndex >= game.moves_detailed.length) {
                            setTimeout(() => {
                                showCompletionIndicator();
                            }, 200);
                        }
                        
                        // Remove highlight from all moves and sections
                        moveItem.querySelectorAll('.clickable-move').forEach(span => {
                            span.classList.remove('active-move');
                        });
                        moveItem.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                            section.classList.remove('clicked');
                        });
                        // Highlight current move and section
                        if (group.white) {
                            whiteMoves.querySelector('.clickable-move').classList.add('active-move');
                        }
                        whiteMoves.classList.add('clicked');
                        
                        // Show commentary if available
                        const whiteMoveData = game.moves_detailed.find(m => m.white === group.white && m.move_number == moveNumber);
                        if (whiteMoveData) {
                            showMoveCommentary(whiteMoveData.description, group.white, whiteMoveData);
                        }
                        
                        // Check if we should autoplay the next move after clicking a move
                        const selectedColor = window.selectedPlayColor || 'both';
                        if (selectedColor !== 'both' && currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                            const nextMove = currentGame.moves_detailed[currentMoveIndex];
                            const isNextWhiteMove = !!nextMove.white;
                            const shouldAutoplayNext = (selectedColor === 'white' && !isNextWhiteMove) || 
                                                     (selectedColor === 'black' && isNextWhiteMove);
                            
                            console.log('Move clicked - checking autoplay:', {
                                selectedColor,
                                currentMoveIndex,
                                nextMove: nextMove.white || nextMove.black,
                                isNextWhiteMove,
                                shouldAutoplayNext
                            });
                            
                            if (shouldAutoplayNext) {
                                console.log('Auto-playing next move after move click');
                                setTimeout(() => {
                                    goToNextMove();
                                }, 300); // Short delay after move click
                            }
                        }
                    }
                });
                
                // Add black move if it exists
                if (group.black) {
                    const blackMoveSpan = document.createElement('span');
                    blackMoveSpan.textContent = convertToChessSymbols(group.black);
                    blackMoveSpan.className = 'clickable-move';
                    blackMoveSpan.dataset.moveIndex = moveIndex * 2 + 1;
                    
                    // Find the move data for annotations
                    const blackMoveData = game.moves_detailed.find(m => m.black === group.black && m.move_number == moveNumber);
                    if (blackMoveData) {
                        // Add annotation if it exists
                        if (blackMoveData.annotation) {
                            const annotationSpan = document.createElement('span');
                            annotationSpan.textContent = blackMoveData.annotation;
                            annotationSpan.className = 'move-annotation';
                            annotationSpan.style.marginLeft = '4px';
                            annotationSpan.style.color = '#000000';
                            blackMoveSpan.appendChild(annotationSpan);
                        }
                        
                    }
                    
                    blackMoves.appendChild(blackMoveSpan);
                }
                
                // Add click listener to entire black-moves div
                blackMoves.addEventListener('click', function() {
                    if (group.black) {
                        currentMoveIndex = moveIndex * 2 + 2;
                        updateBoardPosition();
                        updateMoveButtons();
                        
                        // Check if this is the final move and trigger completion indicator
                        if (currentMoveIndex >= game.moves_detailed.length) {
                            setTimeout(() => {
                                showCompletionIndicator();
                            }, 200);
                        }
                        
                        // Remove highlight from all moves and sections
                        moveItem.querySelectorAll('.clickable-move').forEach(span => {
                            span.classList.remove('active-move');
                        });
                        moveItem.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                            section.classList.remove('clicked');
                        });
                        // Highlight current move and section
                        if (group.black) {
                            blackMoves.querySelector('.clickable-move').classList.add('active-move');
                        }
                        blackMoves.classList.add('clicked');
                        
                        // Show commentary if available
                        const blackMoveData = game.moves_detailed.find(m => m.black === group.black && m.move_number == moveNumber);
                        if (blackMoveData) {
                            showMoveCommentary(blackMoveData.description, group.black, blackMoveData);
                        }
                        
                        // Check if we should autoplay the next move after clicking a move
                        const selectedColor = window.selectedPlayColor || 'both';
                        if (selectedColor !== 'both' && currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                            const nextMove = currentGame.moves_detailed[currentMoveIndex];
                            const isNextWhiteMove = !!nextMove.white;
                            const shouldAutoplayNext = (selectedColor === 'white' && !isNextWhiteMove) || 
                                                     (selectedColor === 'black' && isNextWhiteMove);
                            
                            console.log('Move clicked - checking autoplay:', {
                                selectedColor,
                                currentMoveIndex,
                                nextMove: nextMove.white || nextMove.black,
                                isNextWhiteMove,
                                shouldAutoplayNext
                            });
                            
                            if (shouldAutoplayNext) {
                                console.log('Auto-playing next move after move click');
                                setTimeout(() => {
                                    goToNextMove();
                                }, 300); // Short delay after move click
                            }
                        }
                    }
                });
                
                // Add moves to row
                moveRow.appendChild(whiteMoves);
                moveRow.appendChild(blackMoves);
                moveItem.appendChild(moveRow);
            });
            
            movesList.appendChild(moveItem);
            
            // Add result notation if the game ends in checkmate
            if (game.result && (game.result.includes('wins') || game.result.includes('White wins') || game.result.includes('Black wins'))) {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'game-result';
                resultDiv.style.cssText = 'text-align: center; font-weight: bold; font-size: 16px; margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px; border: 2px solid #dee2e6;';
                
                // Determine the result notation
                let resultNotation = '';
                if (game.result.includes('White wins')) {
                    resultNotation = '1-0';
                } else if (game.result.includes('Black wins')) {
                    resultNotation = '0-1';
                }
                
                if (resultNotation) {
                    resultDiv.textContent = resultNotation;
                    movesList.appendChild(resultDiv);
                }
            }

        }

        // Function to attach event listeners for game header dropdown
        function attachGameHeaderEventListeners() {
            const gameHeader = document.getElementById('game-header');
            const gameDetails = document.getElementById('game-details');
            
            if (gameHeader && gameDetails) {
                // Remove any existing event listeners by cloning the element
                const newGameHeader = gameHeader.cloneNode(true);
                gameHeader.parentNode.replaceChild(newGameHeader, gameHeader);
                
                // Re-attach the event listener
                newGameHeader.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Game header clicked');
                    newGameHeader.classList.toggle('expanded');
                    gameDetails.classList.toggle('show');
                });
                
                console.log('Game header event listeners attached');
            } else {
                console.log('Game header or game details not found');
            }
        }

        // Function to restore main game event listeners
        function restoreMainGameEventListeners() {
            console.log('=== RESTORING MAIN GAME EVENT LISTENERS ===');
            const pieces = document.querySelectorAll('.piece');
            console.log('Found pieces:', pieces.length);
            pieces.forEach((piece, index) => {
                console.log(`Piece ${index}:`, piece);
                // Remove custom game event listeners
                piece.removeEventListener('click', handleCustomPieceClick);
                piece.removeEventListener('dragstart', handleCustomDragStart);
                piece.removeEventListener('dragend', handleCustomDragEnd);
                
                // Restore main game event listeners
                piece.addEventListener('dragstart', handleDragStart);
                piece.addEventListener('dragend', handleDragEnd);
                piece.addEventListener('click', handlePieceClick);
                console.log(`Restored event listeners for piece ${index}`);
            });
        }

        // Function to completely exit custom game mode
        function exitCustomGameMode() {
            // Reset custom game variables
            if (typeof customGameMode !== 'undefined') {
                customGameMode = false;
                window.customGameMode = false;
            }
            
            // Clear custom game elements
            clearCustomGameElements();
            
            // Hide custom game info section
            if (typeof hideCustomGameInfo === 'function') {
                hideCustomGameInfo();
            }
            
            // Hide custom save button
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            
            // Hide custom commentary section
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            
            // Hide custom save message
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }
            
            // Restore main game event listeners
            restoreMainGameEventListeners();
        }

        // Display selected game
        function displayGame(gameId) {
            console.log('Displaying game:', gameId);
            console.log('Games data:', gamesData);
            
            // Always exit custom game mode when displaying any game
            exitCustomGameMode();
            
            // Exit test mode if switching to a different game
            if (isChallengeMode && currentGame && currentGame.id !== gameId) {
                toggleChallengeMode();
            }
            
            if (!gamesData) {
                console.error('No games data available');
                return;
            }
            
            const game = gamesData.games.find(g => g.id === gameId);
            console.log('Found game:', game);
            
            if (!game) {
                console.error('Game not found:', gameId);
                return;
            }

            // Set current game and reset move index
            currentGame = game;
            // Check if game has a custom initial move index, otherwise start at 0
            currentMoveIndex = game.initial_move_index || 0;
            
            // Start training session tracking based on type
            const sessionType = 'game';
            progressTracker.startSession(sessionType);
            
            // Update selected state for game buttons
            document.querySelectorAll('.submenu-button').forEach(btn => {
                btn.classList.remove('selected');
            });
            const selectedButton = document.querySelector(`[data-game-id="${gameId}"]`);
            if (selectedButton) {
                selectedButton.classList.add('selected');
            }
            
            // Reset the board to starting position
            resetBoard();
            
            // Clear any piece selection
            clearSelection();
            
            // Reset to normal visual mode when switching games
            currentVisualMode = 'normal';
            switchVisualMode('normal');

            // Show game display
            const gameDisplay = document.getElementById('game-display');
            gameDisplay.classList.add('show');

            // Show and update game header in moves panel
            const gameHeader = document.getElementById('game-header');
            gameHeader.style.display = 'block';
            document.getElementById('game-title-line').innerHTML = `<span>${game.name}</span>`;
            
            // Event listeners are handled via delegation, no need to reattach

            // Show moves toggle
            const movesToggle = document.getElementById('moves-toggle');
            movesToggle.style.display = 'block';

            // Show play color selection
            const playColorSection = document.getElementById('play-color-section');
            if (playColorSection) {
                playColorSection.style.display = 'block';
                
                // Add click-to-deselect functionality for radio buttons
                const radioButtons = playColorSection.querySelectorAll('input[type="radio"]');
                radioButtons.forEach(radio => {
                    let lastChecked = false;
                    
                    radio.addEventListener('click', function(e) {
                        // If this radio was already checked before this click, uncheck it
                        if (lastChecked) {
                            e.preventDefault();
                            this.checked = false;
                            lastChecked = false;
                        } else {
                            // If it wasn't checked, let it be checked and update our tracking
                            lastChecked = true;
                        }
                    });
                    
                    // Track when this radio becomes checked (from other radios)
                    radio.addEventListener('change', function() {
                        if (this.checked) {
                            lastChecked = true;
                        } else {
                            lastChecked = false;
                        }
                    });
                });
                
                // Add autoplay functionality based on selected color
                radioButtons.forEach(radio => {
                    radio.addEventListener('change', function() {
                        if (this.checked) {
                            const selectedColor = this.value;
                            console.log('Play color changed to:', selectedColor);
                            
                            // Reset to initial position when changing play color
                            if (currentGame) {
                                resetBoard();
                                currentMoveIndex = currentGame.initial_move_index || 0;
                                updateMoveButtons();
                                highlightCurrentMove();
                            }
                            
            // Store the selected color for use in move navigation
            window.selectedPlayColor = selectedColor;
            
            // If a game is loaded and we're switching to autoplay mode, start autoplay
            if (currentGame && selectedColor !== 'both') {
                // Check if the first move should be autoplayed
                const firstMove = currentGame.moves_detailed[0];
                if (firstMove) {
                    const isWhiteMove = !!firstMove.white;
                    const shouldAutoplayFirst = (selectedColor === 'white' && !isWhiteMove) || 
                                             (selectedColor === 'black' && isWhiteMove);
                    
                    if (shouldAutoplayFirst) {
                        console.log('Starting autoplay from first move');
                        setTimeout(() => {
                            goToNextMove();
                        }, 500);
                    }
                }
            }
                        }
                    });
                });
            }

            // Show comment section for games with commentary
            const commentSection = document.getElementById('comment-section');
            if (commentSection) {
                if (game.id.startsWith('custom-game-')) {
                    // For custom games, show comment section if they have commentary
                    const hasCommentary = game.moves_detailed && game.moves_detailed.some(move => move.commentary && move.commentary.trim() !== '');
                    commentSection.style.display = hasCommentary ? 'block' : 'none';
                } else {
                    commentSection.style.display = 'block';
                }
            }
            
            // Handle custom game elements visibility
            if (game.id.startsWith('custom-game-')) {
                // Show custom game elements for custom games
                // Ensure moves list is visible for saved custom games
                const movesList = document.getElementById('moves-list');
                if (movesList) {
                    movesList.style.display = 'block';
                }
            } else {
                // Hide custom game elements for preprogrammed games
                if (typeof hideCustomGameInfo === 'function') {
                    hideCustomGameInfo();
                }
                if (typeof hideCustomSaveButton === 'function') {
                    hideCustomSaveButton();
                }
                if (typeof hideCustomCommentarySection === 'function') {
                    hideCustomCommentarySection();
                }
                if (typeof hideCustomSaveMessage === 'function') {
                    hideCustomSaveMessage();
                }
            }

            // Populate game details
            populateGameDetails(game);

            // Setup board and display moves
            setupInitialPosition();
            reinitializeDragAndDrop(); // Ensure click handlers are attached
            displayGameMoves(game);
            updateMoveButtons();
            
            // Check if we should start autoplay based on selected color
            const selectedColor = window.selectedPlayColor || 'both';
            if (selectedColor !== 'both' && game.moves_detailed.length > 0) {
                const firstMove = game.moves_detailed[0];
                const isWhiteMove = !!firstMove.white;
                const shouldAutoplayFirst = (selectedColor === 'white' && !isWhiteMove) || 
                                         (selectedColor === 'black' && isWhiteMove);
                
                if (shouldAutoplayFirst) {
                    console.log('Starting autoplay from first move on game load');
                    setTimeout(() => {
                        goToNextMove();
                    }, 1000); // Longer delay for initial load
                }
            }
            
            // If game has a custom initial move index, update board to that position
            if (game.initial_move_index && game.initial_move_index > 0) {
                updateBoardPosition();
            }
             highlightCurrentMove();
             
            // Show/hide delete button for custom games (only when viewing saved custom games, not in Add Game mode)
            const deleteGameSection = document.getElementById('delete-game-section');
            const deleteGameBtn = document.getElementById('delete-game-btn');
            if (game.id.startsWith('custom-game-') && !window.customGameMode) {
                deleteGameSection.style.display = 'block';
                deleteGameBtn.onclick = (e) => deleteCustomGame(e, game.id);
                 
                 // Hide custom commentary section and save button when viewing saved custom games
                 if (typeof hideCustomCommentarySection === 'function') {
                     hideCustomCommentarySection();
                 }
                 if (typeof hideCustomSaveButton === 'function') {
                     hideCustomSaveButton();
                 }
             } else {
                 deleteGameSection.style.display = 'none';
             }
             
             // Update game list badges
             updateGameListBadges();
             
             // Visual mode placeholder - no effects applied yet
        }

        // Populate game details
        function populateGameDetails(game) {
            document.getElementById('detail-description').textContent = game.description;
            document.getElementById('detail-moves').textContent = `${game.moves} moves`;
            document.getElementById('detail-white').textContent = game.white_player;
            document.getElementById('detail-black').textContent = game.black_player;
            document.getElementById('detail-opening').textContent = game.opening;
            document.getElementById('detail-difficulty').textContent = game.difficulty;
            
            // Use facts from JSON data (single source of truth)
            const facts = game.facts || 'No interesting facts available for this game.';
            document.getElementById('detail-facts').textContent = facts;
        }

        // Toggle moves visibility
        function toggleMovesVisibility() {
            const movesList = document.getElementById('moves-list');
            const commentSection = document.getElementById('comment-section');
            const toggleImg = document.getElementById('moves-toggle-img');
            
            if (movesList.style.display === 'none') {
                movesList.style.display = 'block';
                // Show comment section for games with commentary
                if (currentGame) {
                    if (currentGame.id.startsWith('custom-game-')) {
                        // For custom games, show comment section if they have commentary
                        const hasCommentary = currentGame.moves_detailed && currentGame.moves_detailed.some(move => move.commentary && move.commentary.trim() !== '');
                        commentSection.style.display = hasCommentary ? 'block' : 'none';
                    } else {
                        commentSection.style.display = 'block';
                    }
                }
                toggleImg.src = 'images/hide.png';
            } else {
                movesList.style.display = 'none';
                commentSection.style.display = 'none';
                toggleImg.src = 'images/view.png';
            }
        }

        // Create confetti effect
        function createConfetti() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.position = 'fixed';
                confetti.style.width = '10px';
                confetti.style.height = '10px';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.top = '-10px';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.zIndex = '9999';
                confetti.style.pointerEvents = 'none';
                confetti.style.animation = 'confetti-fall 3s linear forwards';
                confetti.style.animationDelay = Math.random() * 2 + 's';
                
                document.body.appendChild(confetti);
                
                // Remove confetti after animation
                setTimeout(() => {
                    if (confetti.parentNode) {
                        confetti.parentNode.removeChild(confetti);
                    }
                }, 5000);
            }
        }

        // Show completion indicator on the piece that made the final move
        function showCompletionIndicator() {
            if (!currentGame || currentMoveIndex < currentGame.moves_detailed.length) return;
            
            // Get the last move to find which piece moved
            const lastMove = currentGame.moves_detailed[currentGame.moves_detailed.length - 1];
            const moveNotation = lastMove.white || lastMove.black;
            const isWhiteMove = !!lastMove.white;
            
            // Parse the move to get the destination square
            const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
            if (parsedMove) {
                const destinationSquare = document.querySelector(`[data-square="${parsedMove.target}"]`);
                if (destinationSquare) {
                    // Remove any existing completion indicator
                    const existingIndicator = document.querySelector('.completion-indicator');
                    if (existingIndicator) {
                        existingIndicator.remove();
                    }
                    
                    // Create new completion indicator
                    const indicator = document.createElement('div');
                    indicator.className = 'completion-indicator';
                    indicator.innerHTML = 'âœ“';
                    indicator.title = 'Game completed!';
                    
                    // Make sure the square has relative positioning
                    destinationSquare.style.position = 'relative';
                    
                    // Add the indicator to the destination square
                    destinationSquare.appendChild(indicator);
                }
            }
        }

        // Remove completion indicator
        function removeCompletionIndicator() {
            const existingIndicator = document.querySelector('.completion-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
        }

        // Convert chess piece letters to symbols
        function convertToChessSymbols(notation) {
            if (!notation) return notation;
            
            return notation
                .replace(/K/g, 'â™”')  // King
                .replace(/Q/g, 'â™•')  // Queen
                .replace(/R/g, 'â™–')  // Rook
                .replace(/B/g, 'â™—')  // Bishop
                .replace(/N/g, 'â™˜')  // Knight
                .replace(/P/g, 'â™™')  // Pawn
                .replace(/k/g, 'â™š')  // Black King
                .replace(/q/g, 'â™›')  // Black Queen
                .replace(/r/g, 'â™œ')  // Black Rook
                .replace(/b/g, 'â™')  // Black Bishop
                .replace(/n/g, 'â™ž')  // Black Knight
                .replace(/p/g, 'â™Ÿ')  // Black Pawn
                .replace(/x/g, 'Ã—')  // Capture symbol
                .replace(/\+/g, '+')  // Check symbol
                .replace(/#/g, '#');  // Checkmate symbol
        }

        // Add click event listener to moves toggle image
        document.addEventListener('DOMContentLoaded', function() {
            const toggleImg = document.getElementById('moves-toggle-img');
            if (toggleImg) {
                toggleImg.addEventListener('click', toggleMovesVisibility);
            }

        });

        // Function to highlight the current move in the moves list
        function highlightCurrentMove() {
            if (!currentGame) return;
            
            // Use setTimeout to ensure this runs after DOM updates
            setTimeout(() => {
                // Remove all existing highlights
                document.querySelectorAll('.clickable-move').forEach(span => {
                    span.classList.remove('active-move');
                });
                document.querySelectorAll('.white-moves, .black-moves').forEach(section => {
                    section.classList.remove('clicked');
                });
                
                // If at initial position, don't highlight anything
                if (currentMoveIndex === 0) return;
                
                // Calculate which move to highlight
                const moveNumber = Math.ceil(currentMoveIndex / 2);
                const isWhiteMove = currentMoveIndex % 2 === 1;
                
                // Find all move rows
                const moveRows = document.querySelectorAll('.move-row');
                
                // Find the target move row (0-based indexing)
                const targetMoveRow = moveRows[moveNumber - 1];
                if (!targetMoveRow) return;
                
                let highlightedElement = null;
                
                // Highlight the appropriate move
                if (isWhiteMove) {
                    const whiteMoves = targetMoveRow.querySelector('.white-moves');
                    if (whiteMoves) {
                        const clickableMove = whiteMoves.querySelector('.clickable-move');
                        if (clickableMove) {
                            clickableMove.classList.add('active-move');
                        }
                        whiteMoves.classList.add('clicked');
                        highlightedElement = whiteMoves;
                    }
                } else {
                    const blackMoves = targetMoveRow.querySelector('.black-moves');
                    if (blackMoves) {
                        const clickableMove = blackMoves.querySelector('.clickable-move');
                        if (clickableMove) {
                            clickableMove.classList.add('active-move');
                        }
                        blackMoves.classList.add('clicked');
                        highlightedElement = blackMoves;
                    }
                }
                
                // Auto-scroll the highlighted move into view
                if (highlightedElement) {
                    // Use a slight delay to ensure highlighting is complete
                    setTimeout(() => {
                        highlightedElement.scrollIntoView({
                            behavior: 'smooth',
                            block: 'nearest',
                            inline: 'nearest'
                        });
                    }, 50);
                }
            }, 10);
        }

        // Move navigation functions
        function goToInitialPosition() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToFirstCustomMove();
                return;
            }
            
            clearSelection();
            currentMoveIndex = 0;
            
            // Reset the move parser's position tracking
            moveParser.resetBoard();
            
            setupInitialPosition();
            updateMoveButtons();
            highlightCurrentMove();
            
            // Remove completion indicator when going to initial position
            removeCompletionIndicator();
            
            // Clear comment section at initial position
            const commentContent = document.getElementById('comment-content');
            if (commentContent) {
                commentContent.innerHTML = 'Click on any move to see detailed commentary';
            }
            
            // Play sound for user feedback
            playSound(false);
        }

        function goToPreviousMove() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToPreviousCustomMove();
                return;
            }
            
            if (currentMoveIndex > 0) {
                clearSelection();
                currentMoveIndex--;
                updateBoardPosition();
                updateMoveButtons();
                highlightCurrentMove();
                
                // Remove completion indicator when moving away from final position
                removeCompletionIndicator();
                
                // Update comment section with current move info only if moves are visible
                const movesList = document.getElementById('moves-list');
                if (movesList.style.display !== 'none') {
                    if (currentMoveIndex === 0) {
                        // Clear comment section if at initial position
                        const commentContent = document.getElementById('comment-content');
                        if (commentContent) {
                            commentContent.innerHTML = 'Click on any move to see detailed commentary';
                        }
                    } else if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                        // Show commentary for the move we just went back to
                        const move = currentGame.moves_detailed[currentMoveIndex - 1];
                        const moveNotation = move.white || move.black;
                        showMoveCommentary(move.description, moveNotation, move);
                    }
                }
            }
        }

        function goToNextMove() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToNextCustomMove();
                return;
            }
            
            console.log('goToNextMove called - currentMoveIndex:', currentMoveIndex, 'total moves:', currentGame ? currentGame.moves_detailed.length : 'no game');
            
            if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                // Check if we should autoplay this move
                const move = currentGame.moves_detailed[currentMoveIndex];
                const isWhiteMove = !!move.white;
                const selectedColor = window.selectedPlayColor || 'both';
                
                console.log('Move analysis - isWhiteMove:', isWhiteMove, 'selectedColor:', selectedColor);
                
                // Determine if this move should be autoplayed
                let shouldAutoplay = false;
                if (selectedColor === 'white' && !isWhiteMove) {
                    // Playing as white, autoplay black moves
                    shouldAutoplay = true;
                } else if (selectedColor === 'black' && isWhiteMove) {
                    // Playing as black, autoplay white moves
                    shouldAutoplay = true;
                } else if (selectedColor === 'both') {
                    // Playing as both, no autoplay
                    shouldAutoplay = false;
                }
                
                console.log('Should autoplay:', shouldAutoplay);
                
                if (shouldAutoplay) {
                    // Autoplay this move (opponent's move)
                    executeMove();
                    return;
                } else {
                    // Normal move execution for player moves
                    executeMove();
                    
                    // After executing a player move, check if the next move should autoplay
                    const selectedColor = window.selectedPlayColor || 'both';
                    if (selectedColor !== 'both' && currentMoveIndex < currentGame.moves_detailed.length) {
                        const nextMove = currentGame.moves_detailed[currentMoveIndex];
                        const isNextWhiteMove = !!nextMove.white;
                        const shouldAutoplayNext = (selectedColor === 'white' && !isNextWhiteMove) || 
                                                 (selectedColor === 'black' && isNextWhiteMove);
                        
                        if (shouldAutoplayNext) {
                            console.log('Auto-playing next move after player move');
                            setTimeout(() => {
                                goToNextMove();
                            }, 300); // Short delay after player move
                        }
                    }
                }
            }
        }
        
        function executeMove() {
            if (currentGame && currentMoveIndex < currentGame.moves_detailed.length) {
                clearSelection();
                const move = currentGame.moves_detailed[currentMoveIndex];
                const moveNotation = move.white || move.black;
                const isWhiteMove = !!move.white;
                
                console.log('Move data:', move);
                console.log('Move notation:', moveNotation);
                console.log('Is white move:', isWhiteMove);
                
                // Use JSON coordinates if available, otherwise parse the move notation
                let sourceSquare, destinationSquare, pieceImage;
                
                if (move.white_from && move.white_to) {
                    // Use coordinates from JSON for white moves
                    sourceSquare = getSquareByNotation(move.white_from);
                    destinationSquare = getSquareByNotation(move.white_to);
                    
                    // Extract piece type from notation - handle different formats
                    let piece = 'P'; // Default to pawn
                    if (moveNotation.length > 0) {
                        const firstChar = moveNotation.charAt(0).toUpperCase();
                        if (['K', 'Q', 'R', 'B', 'N'].includes(firstChar)) {
                            piece = firstChar;
                        }
                    }
                    console.log('White move - piece from notation:', piece, 'notation:', moveNotation);
                    pieceImage = moveParser.getPieceImage(piece, isWhiteMove);
                } else if (move.black_from && move.black_to) {
                    // Use coordinates from JSON for black moves
                    sourceSquare = getSquareByNotation(move.black_from);
                    destinationSquare = getSquareByNotation(move.black_to);
                    
                    // Extract piece type from notation - handle different formats
                    let piece = 'P'; // Default to pawn
                    if (moveNotation.length > 0) {
                        const firstChar = moveNotation.charAt(0).toUpperCase();
                        if (['K', 'Q', 'R', 'B', 'N'].includes(firstChar)) {
                            piece = firstChar;
                        }
                    }
                    console.log('Black move - piece from notation:', piece, 'notation:', moveNotation);
                    pieceImage = moveParser.getPieceImage(piece, isWhiteMove);
                } else {
                    // Fallback to parsing move notation
                    const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
                    console.log('Parsed move:', parsedMove);
                    pieceImage = moveParser.getPieceImage(parsedMove.piece, isWhiteMove);
                    sourceSquare = getSquareByNotation(parsedMove.source);
                    destinationSquare = getSquareByNotation(parsedMove.target);
                }
                
                console.log('Using coordinates:', { source: move.white_from || move.black_from, target: move.white_to || move.black_to });
                
                if (moveNotation.includes('O-O')) {
                    // Handle castling
                    const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
                    applyCastling(parsedMove, true, true);
                } else if (sourceSquare && destinationSquare && pieceImage) {
                    // Use the proper animation for existing pieces
                    animateExistingPiece(sourceSquare, destinationSquare, pieceImage);
                    
                    // Update piece positions in the parser - use the piece from notation
                    const piece = moveNotation.charAt(0).toUpperCase();
                    const sourceNotation = move.white_from || move.black_from;
                    const targetNotation = move.white_to || move.black_to;
                    moveParser.updatePiecePosition(piece, sourceNotation, targetNotation, isWhiteMove);
                }
                    
                    currentMoveIndex++;
                    updateMoveButtons();
                    highlightCurrentMove();
                    
                    // Check if this is the final move and trigger completion indicator after animation
                    if (currentMoveIndex >= currentGame.moves_detailed.length) {
                        // Wait for animation to complete (300ms + buffer)
                        setTimeout(() => {
                            showCompletionIndicator();
                        }, 400);
                    }
                    
                    // Update comment section with current move info only if moves are visible
                    const movesList = document.getElementById('moves-list');
                    if (move && movesList.style.display !== 'none') {
                        showMoveCommentary(move.description, moveNotation, move);
                }
            }
        }

        function goToFinalPosition() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                goToLastCustomMove();
                return;
            }
            
            if (currentGame) {
                clearSelection();
                currentMoveIndex = currentGame.moves_detailed.length;
                updateBoardPosition();
                updateMoveButtons();
                highlightCurrentMove();
                
                // Trigger completion indicator for reaching final position
                setTimeout(() => {
                    showCompletionIndicator();
                }, 200);
                
                // Update comment section with the last move info only if moves are visible
                const movesList = document.getElementById('moves-list');
                if (movesList.style.display !== 'none' && currentGame.moves_detailed.length > 0) {
                    const lastMove = currentGame.moves_detailed[currentGame.moves_detailed.length - 1];
                    const moveNotation = lastMove.white || lastMove.black;
                    showMoveCommentary(lastMove.commentary, moveNotation, lastMove);
                }
            }
        }

        function updateBoardPosition() {
            if (!currentGame) return;
            
            console.log('Updating board position to move index:', currentMoveIndex);
            
            // Store completion indicator state before clearing
            const wasAtFinalPosition = currentMoveIndex >= currentGame.moves_detailed.length;
            
            // Clear the board completely
            const board = document.getElementById('chess-board');
            const squares = board.querySelectorAll('.chess-square');
            squares.forEach(square => {
                square.innerHTML = '';
            });

            // Reset the move parser's position tracking
            moveParser.resetBoard();

            // Set up initial position
            setupInitialPosition();

            // Apply moves up to current position
            for (let i = 0; i < currentMoveIndex && i < currentGame.moves_detailed.length; i++) {
                const move = currentGame.moves_detailed[i];
                console.log(`Applying move ${i + 1}:`, move.white || move.black);
                applyMove(move, false, false);
            }
            
            // Play sound only for the current (last applied) move
            if (currentMoveIndex > 0 && currentMoveIndex <= currentGame.moves_detailed.length) {
                const lastMove = currentGame.moves_detailed[currentMoveIndex - 1];
                if (lastMove) {
                    // Check if it's a capture by looking for 'x' in the move notation
                    const moveNotation = lastMove.white || lastMove.black;
                    const isCapture = moveNotation && moveNotation.includes('x');
                    playSound(isCapture);
                }
            }

            // Re-initialize drag and drop for all pieces
            reinitializeDragAndDrop();
            
            // Update comment section with current move info
            if (currentMoveIndex > 0 && currentMoveIndex <= currentGame.moves_detailed.length) {
                const currentMove = currentGame.moves_detailed[currentMoveIndex - 1];
                const moveNotation = currentMove.white || currentMove.black;
                showMoveCommentary(currentMove.commentary, moveNotation, currentMove);
            } else if (currentMoveIndex === 0) {
                // Clear comment section at initial position
                const commentContent = document.getElementById('comment-content');
                if (commentContent) {
                    commentContent.innerHTML = 'Click on any move to see detailed commentary';
                }
            }
            
            // Update move highlighting
            highlightCurrentMove();
        }

        // Animate piece movement
        function animateMove(fromSquare, toSquare, pieceImage) {
            // Create a temporary piece for animation with exact same styling
            const tempPiece = document.createElement('div');
            tempPiece.className = 'chess-piece';
            tempPiece.style.backgroundImage = `url('pieces/${pieceImage}')`;
            tempPiece.style.backgroundSize = 'contain';
            tempPiece.style.backgroundRepeat = 'no-repeat';
            tempPiece.style.backgroundPosition = 'center';
            tempPiece.style.position = 'absolute';
            tempPiece.style.zIndex = '1000';
            tempPiece.style.pointerEvents = 'none';
            tempPiece.style.width = '60px';
            tempPiece.style.height = '60px';
            tempPiece.style.transition = 'all 0.3s ease-in-out';
            
            // Get the chess board container
            const board = document.getElementById('chess-board');
            const boardRect = board.getBoundingClientRect();
            
            // Get positions relative to the board
            const fromRect = fromSquare.getBoundingClientRect();
            const toRect = toSquare.getBoundingClientRect();
            
            // Position the temp piece at the source (relative to board)
            tempPiece.style.left = (fromRect.left - boardRect.left) + 'px';
            tempPiece.style.top = (fromRect.top - boardRect.top) + 'px';
            
            // Add to board with relative positioning
            board.style.position = 'relative';
            board.appendChild(tempPiece);
            
            // Animate to destination
            requestAnimationFrame(() => {
                tempPiece.style.left = (toRect.left - boardRect.left) + 'px';
                tempPiece.style.top = (toRect.top - boardRect.top) + 'px';
            });
            
            // Clean up after animation
            setTimeout(() => {
                if (tempPiece.parentNode) {
                    tempPiece.parentNode.removeChild(tempPiece);
                }
            }, 350);
        }

        function applyMove(move, animate = false, enableSound = true) {
            if (!move.white && !move.black) return;

            const moveNotation = move.white || move.black;
            const isWhiteMove = !!move.white;
            
            console.log('Applying move:', moveNotation, 'isWhite:', isWhiteMove);
            
            // Parse the move using the universal parser
            const parsedMove = moveParser.parseMove(moveNotation, isWhiteMove);
            console.log('Parsed move:', parsedMove);
            
            if (parsedMove.isCastling) {
                applyCastling(parsedMove, animate, enableSound);
                } else {
                const pieceImage = moveParser.getPieceImage(parsedMove.piece, isWhiteMove);
                movePiece(parsedMove.source, parsedMove.target, pieceImage, animate, enableSound);
                
                // Update piece positions in the parser
                moveParser.updatePiecePosition(parsedMove.piece, parsedMove.source, parsedMove.target, isWhiteMove);
            }
        }
        
        function applyCastling(parsedMove, animate = false, enableSound = true) {
            const { source, target, isWhite, isLong } = parsedMove;
            
            // Move the king
            const kingImage = moveParser.getPieceImage('K', isWhite);
            movePiece(source, target, kingImage, animate, enableSound);
            
            // Move the rook
            const rookSource = isLong ? (isWhite ? 'a1' : 'a8') : (isWhite ? 'h1' : 'h8');
            const rookTarget = isLong ? (isWhite ? 'd1' : 'd8') : (isWhite ? 'f1' : 'f8');
            const rookImage = moveParser.getPieceImage('R', isWhite);
            movePiece(rookSource, rookTarget, rookImage, animate, enableSound);
            
            // Update piece positions
            moveParser.updatePiecePosition('K', source, target, isWhite);
            moveParser.updatePiecePosition('R', rookSource, rookTarget, isWhite);
        }

        function movePiece(from, to, piece, animate = false, enableSound = true) {
            // Start training timer on piece movement
            progressTracker.startTrainingTimer();
            
            const fromSquare = getSquareByNotation(from);
            const toSquare = getSquareByNotation(to);
            
            if (fromSquare && toSquare) {
                // Check if there's a piece being captured
                const isCapture = toSquare.innerHTML.trim() !== '';
                
                if (animate) {
                    // Animate the move
                    animateMove(fromSquare, toSquare, piece);
                    // Update the board after animation
                    setTimeout(() => {
                        // Ensure board is in dragging state to disable transitions
                        const board = document.getElementById('chess-board');
                        board.classList.add('dragging');
                        
                        fromSquare.innerHTML = '';
                        toSquare.innerHTML = ''; // Clear destination square
                        const pieceElement = createDraggablePiece(piece, to);
                        toSquare.appendChild(pieceElement);
                        
                        // Remove dragging class after a short delay to re-enable transitions
                        setTimeout(() => {
                            board.classList.remove('dragging');
                        }, 50);
                        
                        // Play sound after animation completes
                        if (enableSound) playSound(isCapture);
                    }, 300);
                } else {
                    // Ensure board is in dragging state to disable transitions
                    const board = document.getElementById('chess-board');
                    board.classList.add('dragging');
                    
                    // Direct move without animation
                    fromSquare.innerHTML = '';
                    toSquare.innerHTML = ''; // Clear destination square
                    const pieceElement = createDraggablePiece(piece, to);
                    toSquare.appendChild(pieceElement);
                    
                    // Remove dragging class after a short delay to re-enable transitions
                    setTimeout(() => {
                        board.classList.remove('dragging');
                    }, 50);
                    
                    // Play sound immediately
                    if (enableSound) playSound(isCapture);
                }
            }
        }

        function getSquareByNotation(notation) {
            const board = document.getElementById('chess-board');
            
            // Use data-square attribute to find the correct square
            // This works regardless of board orientation since squares are labeled correctly
            return board.querySelector(`[data-square="${notation}"]`);
        }

        function updateMoveButtons() {
            // Check if in custom game mode
            if (typeof customGameMode !== 'undefined' && customGameMode) {
                updateCustomMoveButtons();
                return;
            }
            
            const btnInitial = document.getElementById('btn-initial');
            const btnBack = document.getElementById('btn-back');
            const btnForward = document.getElementById('btn-forward');
            const btnFinal = document.getElementById('btn-final');

            if (!currentGame) {
                btnInitial.classList.add('disabled');
                btnBack.classList.add('disabled');
                btnForward.classList.add('disabled');
                btnFinal.classList.add('disabled');
                return;
            }

            // Update disabled states
            if (currentMoveIndex === 0) {
                btnInitial.classList.add('disabled');
                btnBack.classList.add('disabled');
            } else {
                btnInitial.classList.remove('disabled');
                btnBack.classList.remove('disabled');
            }

            if (currentMoveIndex >= currentGame.moves_detailed.length) {
                btnForward.classList.add('disabled');
                btnFinal.classList.add('disabled');
            } else {
                btnForward.classList.remove('disabled');
                btnFinal.classList.remove('disabled');
            }
        }

        // Visual mode functions (placeholder - no functionality yet)
        function switchVisualMode(mode) {
            currentVisualMode = mode;
            
            // Update active option
            const options = document.querySelectorAll('.mode-option');
            options.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.mode === mode) {
                    option.classList.add('active');
                }
            });
            
            // Apply visual effects
            applyVisualMode(mode);
        }

        // Flip notation function
        function flipNotation() {
            // Flip the letters (a-h)
            const letters = document.querySelectorAll('.notation-letter');
            const letterTexts = Array.from(letters).map(letter => letter.textContent);
            const reversedLetters = letterTexts.reverse();
            
            letters.forEach((letter, index) => {
                letter.textContent = reversedLetters[index];
            });
            
            // Flip the numbers (1-8)
            const numbers = document.querySelectorAll('.notation-number');
            const numberTexts = Array.from(numbers).map(number => number.textContent);
            const reversedNumbers = numberTexts.reverse();
            
            numbers.forEach((number, index) => {
                number.textContent = reversedNumbers[index];
            });
        }

        // Flip board function
        function flipBoard() {
            boardFlipped = !boardFlipped;
            
            // Update button appearance
            const flipBtn = document.getElementById('flip-board-btn');
            if (boardFlipped) {
                flipBtn.classList.add('flipped');
            } else {
                flipBtn.classList.remove('flipped');
            }
            
            // Flip the notation
            flipNotation();
            
            // Reinitialize the board with the new orientation
            initializeChessBoard();
            
            // If there's a current game, update the board position
            if (currentGame) {
                updateBoardPosition();
            } else {
                setupInitialPosition();
            }
            
            // Reinitialize drag and drop functionality
            reinitializeDragAndDrop();
        }

        function applyVisualMode(mode) {
            const pieces = document.querySelectorAll('.chess-piece');
            
            pieces.forEach(piece => {
                applyVisualModeToPiece(piece, mode);
            });
        }

        function applyVisualModeToPiece(piece, mode) {
            const currentPiece = piece.dataset.piece;
            
            // Store original piece type if not already stored
            if (!piece.dataset.originalPiece) {
                piece.dataset.originalPiece = currentPiece;
            }
            
            const originalPiece = piece.dataset.originalPiece;
            let newPiece = originalPiece; // Start with original piece
            
            switch(mode) {
                case 'grey':
                    // Switch all white pieces to black pieces
                    if (originalPiece.includes('lt45')) {
                        // White piece -> Black piece
                        newPiece = originalPiece.replace('lt45', 'dt45');
                    } else {
                        // Keep black pieces as black
                        newPiece = originalPiece;
                    }
                    piece.style.opacity = '1';
                    break;
                 case 'checkers':
                     // For checkers mode, use black plate for all pieces
                     newPiece = 'black-plate-for-your-kitchen-png.webp';
                     piece.style.opacity = '1';
                     break;
                case 'empty':
                    // Make pieces completely invisible
                    newPiece = originalPiece;
                    piece.style.opacity = '0';
                    break;
                case 'normal':
                default:
                    // Reset to original pieces with original colors
                    newPiece = originalPiece;
                    piece.style.opacity = '1';
                    break;
            }
            
            // Update the piece image if it changed
            if (newPiece !== currentPiece) {
                piece.dataset.piece = newPiece;
                piece.style.backgroundImage = `url('pieces/${newPiece}')`;
            }
         }

         // Challenge mode functions
         function toggleChallengeMode() {
             const challengeBtn = document.getElementById('challenge-btn');
             const modeOptions = document.querySelectorAll('.mode-option');
             const moveControls = document.querySelector('.move-controls');
             const movesList = document.getElementById('moves-list');
             const commentSection = document.getElementById('comment-section');
             
             if (!isChallengeMode && !currentGame) {
                 return;
             }
             
             if (!isChallengeMode) {
                 // Start challenge mode
                 isChallengeMode = true;
                 challengeBtn.textContent = 'Exit';
                 challengeBtn.classList.add('active');
                 
                 // Hide visual mode options and navigation buttons
                 modeOptions.forEach(option => {
                     option.style.display = 'none';
                 });
                 if (moveControls) {
                 moveControls.style.display = 'none';
                 }
                 if (movesList) {
                     movesList.style.display = 'block';
                 }
                 if (commentSection) {
                     commentSection.style.display = 'none';
                 }
                 
                 // Reset to initial position
                 currentMoveIndex = 0;
                 setupInitialPosition();
                 updateMoveButtons();
                 
                 // Update moves display to show only completed moves (none initially)
                 updateChallengeMovesDisplay();
                 
                // Make all pieces invisible
                const pieces = document.querySelectorAll('.chess-piece');
                pieces.forEach(piece => {
                    piece.style.opacity = '0';
                });
                 
                 console.log('Challenge mode started! Replay the game from memory.');
             } else {
                 // Exit challenge mode
                 isChallengeMode = false;
                 challengeBtn.textContent = 'Test';
                 challengeBtn.classList.remove('active');
                 
                 // Show visual mode options and navigation buttons
                 modeOptions.forEach(option => {
                     option.style.display = 'flex';
                 });
                 if (moveControls) {
                 moveControls.style.display = 'flex';
                 }
                 if (movesList) {
                     movesList.style.display = 'block';
                 }
                 if (commentSection) {
                     commentSection.style.display = 'block';
                 }
                 
                 // Restore full moves display
                 displayGameMoves(currentGame);
                 
                 // Restore current visual mode
                 applyVisualMode(currentVisualMode);
                 
                 console.log('Challenge mode ended!');
             }
         }
         
         function updateChallengeMovesDisplay() {
             if (!isChallengeMode || !currentGame) return;
             
             const movesList = document.getElementById('moves-list');
             if (!movesList) return;
             
             // Clear existing moves
             movesList.innerHTML = '';
             
             // Group moves by move number, but only show completed moves
             const moveGroups = {};
             const completedMoves = Math.floor(currentMoveIndex / 2);
             const isWhiteMoveCompleted = currentMoveIndex % 2 === 1;
             
             for (let i = 0; i < currentMoveIndex; i++) {
                 const move = currentGame.moves_detailed[i];
                 const moveNumber = Math.floor(i / 2) + 1;
                 
                 if (!moveGroups[moveNumber]) {
                     moveGroups[moveNumber] = {};
                 }
                 
                 if (i % 2 === 0) {
                     moveGroups[moveNumber].white = move.white || move.black;
                 } else {
                     moveGroups[moveNumber].black = move.white || move.black;
                 }
             }
             
             // Create the moves display (only completed moves)
             if (Object.keys(moveGroups).length > 0) {
                 const moveItem = document.createElement('div');
                 moveItem.className = 'move-item';
                 
                 Object.keys(moveGroups).forEach((moveNumber, moveIndex) => {
                     const group = moveGroups[moveNumber];
                     
                     const moveRow = document.createElement('div');
                     moveRow.className = 'move-row';
                     
                     const moveNumberSpan = document.createElement('span');
                     moveNumberSpan.textContent = moveNumber + '.';
                     moveNumberSpan.className = 'move-number';
                     moveRow.appendChild(moveNumberSpan);
                     
                     const whiteMoves = document.createElement('div');
                     whiteMoves.className = 'white-moves';
                     
                     const blackMoves = document.createElement('div');
                     blackMoves.className = 'black-moves';
                     
                     if (group.white) {
                         const whiteMoveSpan = document.createElement('span');
                         whiteMoveSpan.textContent = convertToChessSymbols(group.white);
                         whiteMoveSpan.className = 'clickable-move';
                         whiteMoves.appendChild(whiteMoveSpan);
                     }
                     
                     if (group.black) {
                         const blackMoveSpan = document.createElement('span');
                         blackMoveSpan.textContent = convertToChessSymbols(group.black);
                         blackMoveSpan.className = 'clickable-move';
                         blackMoves.appendChild(blackMoveSpan);
                     }
                     
                     moveRow.appendChild(whiteMoves);
                     moveRow.appendChild(blackMoves);
                     moveItem.appendChild(moveRow);
                 });
                 
                 movesList.appendChild(moveItem);
             } else {
                 // Show placeholder when no moves completed yet
                 const placeholder = document.createElement('div');
                 placeholder.className = 'move-item';
                 placeholder.style.textAlign = 'center';
                 placeholder.style.color = '#7f8c8d';
                 placeholder.style.fontStyle = 'italic';
                 placeholder.textContent = '';
                 movesList.appendChild(placeholder);
             }
         }
         
         function checkChallengeProgress() {
             if (!isChallengeMode || !currentGame) return;
             
             // Update the moves display to show progress
             updateChallengeMovesDisplay();
             
             // Check if user completed the entire game
             if (currentMoveIndex >= currentGame.moves_detailed.length) {
                 showCompletionBadge();
             }
         }

         function showCompletionBadge() {
             const badge = document.getElementById('completion-badge');
             const overlay = document.getElementById('badge-overlay');
             
             // Mark this game as completed
             if (currentGame) {
                 completedChallenges.add(currentGame.id);
                 
                 // Record completion in progress tracker based on type
                 const difficulty = currentGame.difficulty || 'intermediate';
                 if (currentGame.type === 'game') {
                     progressTracker.recordGameCompletion(difficulty, currentGame.id);
                 }
                 
                 // End the current training session
                 progressTracker.endSession();
                 
                 console.log('Game completed! Progress updated:', progressTracker.getProgressSummary());
             }
             
             // Update badges in games list
             updateGameListBadges();
            
            // Trigger confetti celebration
            createConfetti();
             
             // Show overlay and badge with animation
             overlay.classList.add('show');
             setTimeout(() => {
                 badge.classList.add('show');
             }, 100);
         }

         function hideBadge() {
             const badge = document.getElementById('completion-badge');
             const overlay = document.getElementById('badge-overlay');
             
             // Hide badge and overlay
             badge.classList.remove('show');
             setTimeout(() => {
                 overlay.classList.remove('show');
                 // Exit challenge mode after hiding badge
                 toggleChallengeMode();
             }, 300);
         }


         function updateGameListBadges() {
             // Refresh completed challenges from progress tracker
             completedChallenges = loadCompletedChallenges();
             console.log('Updating badges with completed challenges:', completedChallenges);
             
             // Update badges in the games list sidebar
             const badges = document.querySelectorAll('.game-completion-badge');
             console.log('Found badges:', badges.length);
             badges.forEach(badge => {
                 const gameId = badge.dataset.game;
                 const isCompleted = completedChallenges.has(gameId);
                 console.log(`Game ${gameId}: completed = ${isCompleted}`);
                 if (isCompleted) {
                     badge.classList.add('show');
                 } else {
                     badge.classList.remove('show');
                 }
             });
         }

         document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing...');

            // Initialize chess board
            initializeChessBoard();
            setupInitialPosition();
            reinitializeDragAndDrop(); // Ensure click handlers are attached to initial pieces
            
            // Hide custom game elements on initial load
            if (typeof hideCustomGameInfo === 'function') {
                hideCustomGameInfo();
            }
            if (typeof hideCustomSaveButton === 'function') {
                hideCustomSaveButton();
            }
            if (typeof hideCustomCommentarySection === 'function') {
                hideCustomCommentarySection();
            }
            if (typeof hideCustomSaveMessage === 'function') {
                hideCustomSaveMessage();
            }

            // Set up submenu toggles for all tabs
            const gameButtonIds = [
                'short-games-btn', 'my-games-short-games-btn', 'gm-games-short-games-btn',
                'medium-games-btn', 'my-games-medium-games-btn', 'gm-games-medium-games-btn',
                'long-games-btn', 'my-games-long-games-btn', 'gm-games-long-games-btn',
                'epic-games-btn', 'my-games-epic-games-btn', 'gm-games-epic-games-btn',
                'my-games-my-games-btn', 'gm-games-my-games-btn'
            ];
            
            const submenuIds = [
                'short-games-submenu', 'my-games-short-games-submenu', 'gm-games-short-games-submenu',
                'medium-games-submenu', 'my-games-medium-games-submenu', 'gm-games-medium-games-submenu',
                'long-games-submenu', 'my-games-long-games-submenu', 'gm-games-long-games-submenu',
                'epic-games-submenu', 'my-games-epic-games-submenu', 'gm-games-epic-games-submenu',
                'my-games-my-games-submenu', 'gm-games-my-games-submenu'
            ];
            
            gameButtonIds.forEach((buttonId, index) => {
                const button = document.getElementById(buttonId);
                const submenu = document.getElementById(submenuIds[index]);
                
                if (button && submenu) {
                    button.addEventListener('click', function(e) {
                        e.preventDefault();
                        console.log('Game button clicked:', buttonId);
                        
                        // Close all other submenus first
                        submenuIds.forEach((submenuId, submenuIndex) => {
                            if (submenuIndex !== index) {
                                const otherSubmenu = document.getElementById(submenuId);
                                const otherButton = document.getElementById(gameButtonIds[submenuIndex]);
                                if (otherSubmenu && otherButton) {
                                    otherSubmenu.classList.remove('show');
                                    otherButton.classList.remove('active');
                                }
                            }
                        });
                        
                        // Toggle the current submenu
                        if (submenu.classList.contains('show')) {
                            submenu.classList.remove('show');
                            button.classList.remove('active');
                        } else {
                            submenu.classList.add('show');
                            button.classList.add('active');
                        }
                    });
                }
            });

            // Game submenu button clicks
            const submenuButtons = document.querySelectorAll('.submenu-button');
            console.log('Found submenu buttons:', submenuButtons.length);
            
            submenuButtons.forEach(button => {
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    const gameId = this.getAttribute('href').substring(1);
                    console.log('Button clicked, gameId:', gameId);
                    displayGame(gameId);
                });
            });

            // Game header click to expand/collapse details - use event delegation
            document.addEventListener('click', function(e) {
                // Only handle clicks on the main game header, not the custom game header
                if (e.target.closest('#game-header') && !e.target.closest('#custom-game-header')) {
                    const gameHeader = document.getElementById('game-header');
                    const gameDetails = document.getElementById('game-details');
                    
                    if (gameHeader && gameDetails && gameHeader.style.display !== 'none') {
                        gameHeader.classList.toggle('expanded');
                        gameDetails.classList.toggle('show');
                        
                        // Remove any inline display style that might be overriding the CSS
                        if (gameDetails.classList.contains('show')) {
                            gameDetails.style.display = '';
                        } else {
                            gameDetails.style.display = 'none';
                        }
                    }
                }
            });

            // Move navigation button event listeners
            document.getElementById('btn-initial').addEventListener('click', goToInitialPosition);
            document.getElementById('btn-back').addEventListener('click', goToPreviousMove);
            document.getElementById('btn-forward').addEventListener('click', goToNextMove);
            document.getElementById('btn-final').addEventListener('click', goToFinalPosition);

            // Visual mode option event listeners
            const modeOptions = document.querySelectorAll('.mode-option');
            modeOptions.forEach(option => {
                option.addEventListener('click', function() {
                    const mode = this.dataset.mode;
                    switchVisualMode(mode);
                });
            });

            // Flip board button event listener
            document.getElementById('flip-board-btn').addEventListener('click', flipBoard);

            // Challenge button event listener
            const challengeBtn = document.getElementById('challenge-btn');
            challengeBtn.addEventListener('click', function() {
                toggleChallengeMode();
            });


            // Initialize move buttons as disabled
            updateMoveButtons();
            
            // Initialize game list badges
            updateGameListBadges();
        });
    </script>

    <!-- Sign In Modal -->
    <div id="signInModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Sign In</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <form id="signInForm" onsubmit="handleSignIn(event)">
                <div class="form-group">
                    <label class="form-label" for="signInEmail">Email</label>
                    <input type="email" id="signInEmail" class="form-input" placeholder="Enter your email" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="signInPassword">Password</label>
                    <input type="password" id="signInPassword" class="form-input" placeholder="Enter your password" required>
                </div>
            <div class="modal-buttons">
                <button type="submit" class="btn-modal btn-primary">Sign In</button>
                <button type="button" class="btn-modal btn-secondary" onclick="closeModal()">Cancel</button>
            </div>
        </form>
        <div class="google-signup">
            <button type="button" class="btn-modal btn-google" onclick="signInWithGoogle()">
                <div class="google-icon"></div>
                Sign in with Google
            </button>
        </div>
        <div class="register-link">
            <p>Don't have an account yet? <a href="#" onclick="showRegisterModal()">Register here</a></p>
        </div>
        </div>
    </div>

    <!-- Register Modal -->
    <div id="registerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Create Account</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <form id="registerForm" onsubmit="handleRegister(event)">
                <div class="form-group">
                    <label class="form-label" for="registerEmail">Email</label>
                    <input type="email" id="registerEmail" class="form-input" placeholder="Enter your email" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="registerPassword">Password</label>
                    <input type="password" id="registerPassword" class="form-input" placeholder="Create a password" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="registerName">Full Name</label>
                    <input type="text" id="registerName" class="form-input" placeholder="Enter your full name" required>
                </div>
                <div class="modal-buttons">
                    <button type="submit" class="btn-modal btn-primary">Create Account</button>
                    <button type="button" class="btn-modal btn-secondary" onclick="closeModal()">Cancel</button>
                </div>
            </form>
            <div class="google-signup">
                <button type="button" class="btn-modal btn-google" onclick="registerWithGoogle()">
                    <div class="google-icon"></div>
                    Register with Google
                </button>
            </div>
        </div>
    </div>

    <!-- Logout Confirmation Modal -->
    <div id="logoutConfirmModal" class="logout-confirm-modal">
        <div class="logout-confirm-content">
            <div class="logout-confirm-header">
                <h2>Confirm Logout</h2>
            </div>
            <div class="logout-confirm-message">
                Are you sure you want to log out? You'll need to sign in again to access your account.
            </div>
            <div class="logout-confirm-buttons">
                <button class="btn-logout-confirm btn-logout-yes" onclick="confirmLogout()">Yes, Logout</button>
                <button class="btn-logout-confirm btn-logout-no" onclick="cancelLogout()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Subscription Required Modal -->
    <div id="subscriptionRequiredModal" class="subscription-required-modal">
        <div class="subscription-required-content">
            <div class="subscription-required-header">
                <h2>ðŸ”’ Subscription Required</h2>
            </div>
            <div class="subscription-required-message">
                This content is locked and requires a premium subscription to access. Upgrade your account to unlock all games.
            </div>
            <div class="subscription-required-buttons">
                <button class="btn-subscription-required btn-subscription-yes" onclick="goToSubscription()">Get Subscription</button>
                <button class="btn-subscription-required btn-subscription-no" onclick="closeSubscriptionModal()">Cancel</button>
            </div>
        </div>
    </div>
</body>
</html>
